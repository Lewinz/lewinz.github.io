<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>WebSocket 协议 &mdash; 阿嫂</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/rouge-themes@master/dist/github.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/vendor/share.js/dist/css/share.min.css"><link rel="canonical" href="https://lewinz.org/2022/01/14/websocket/"><link rel="alternate" type="application/atom+xml" title="阿嫂" href="https://lewinz.org/feed.xml"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/favicon.ico"><meta property="og:title" content="WebSocket 协议"><meta name="keywords" content="WebSocket"><meta name="og:keywords" content="WebSocket"><meta name="description" content="原文地址，此文档仅做记载备份https://www.cnblogs.com/chyingp/p/websocket-deep-in.html"><meta name="og:description" content="原文地址，此文档仅做记载备份https://www.cnblogs.com/chyingp/p/websocket-deep-in.html"><meta property="og:url" content="https://lewinz.org/2022/01/14/websocket/"><meta property="og:site_name" content="阿嫂"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2022-01-14"> <script src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/js/main.js"></script> <script data-ad-client="ca-pub-7093222719567591" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://lewinz.org/" title="阿嫂"><span class="octicon octicon-mark-github"></span> 阿嫂</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://lewinz.org/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="https://lewinz.org/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="https://lewinz.org/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="https://lewinz.org/links/" class=" site-header-nav-item" target="" title="链接">链接</a> <a href="https://lewinz.org/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="WebSocket 协议"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">WebSocket 协议</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2022/01/14 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://lewinz.org/categories/#WebSocket" title="WebSocket">WebSocket</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 11286 字，约 33 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" > <ins class="adsbygoogle content-header-ad" data-ad-client="ca-pub-7093222719567591" data-ad-slot="1650902835"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script> <br /><article class="article-content markdown-body"><h2 id="原文地址此文档仅做记载备份">原文地址，此文档仅做记载备份</h2><p><a href="https://www.cnblogs.com/chyingp/p/websocket-deep-in.html">https://www.cnblogs.com/chyingp/p/websocket-deep-in.html</a></p><h2 id="内容概览">内容概览</h2><p>WebSocket 的出现，使得浏览器具备了实时双向通信的能力。本文由浅入深，介绍了 WebSocket 如何建立连接、交换数据的细节，以及数据帧的格式。此外，还简要介绍了针对 WebSocket 的安全攻击，以及协议是如何抵御类似攻击的。</p><h2 id="什么是-websocket">什么是 WebSocket</h2><p>HTML5 开始提供的一种浏览器与服务器进行全双工通讯的网络技术，属于应用层协议。它基于 TCP 传输协议，并复用 HTTP 的握手通道。</p><p>对大部分 web 开发者来说，上面这段描述有点枯燥，其实只要记住几点：</p><ol><li>WebSocket 可以在浏览器里使用</li><li>支持双向通信</li><li>使用很简单</li></ol><h3 id="有哪些优点">有哪些优点</h3><p>说到优点，这里的对比参照物是 HTTP 协议，概括地说就是：支持双向通信，更灵活，更高效，可扩展性更好。</p><ol><li>支持双向通信，实时性更强。</li><li>更好的二进制支持。</li><li>较少的控制开销。连接创建后，ws 客户端、服务端进行数据交换时，协议控制的数据包头部较小。在不包含头部的情况下，服务端到客户端的包头只有 2~10 字节（取决于数据包长度），客户端到服务端的的话，需要加上额外的 4 字节的掩码。而 HTTP 协议每次通信都需要携带完整的头部。</li><li>支持扩展。ws 协议定义了扩展，用户可以扩展协议，或者实现自定义的子协议。（比如支持自定义压缩算法等） 对于后面两点，没有研究过 WebSocket 协议规范的同学可能理解起来不够直观，但不影响对 WebSocket 的学习和使用。</li></ol><h3 id="需要学习哪些东西">需要学习哪些东西</h3><p>对网络应用层协议的学习来说，最重要的往往就是连接建立过程、数据交换教程。当然，数据的格式是逃不掉的，因为它直接决定了协议本身的能力。好的数据格式能让协议更高效、扩展性更好。</p><p>下文主要围绕下面几点展开：</p><ol><li>如何建立连接</li><li>如何交换数据</li><li>数据帧格式</li><li>如何维持连接</li></ol><h2 id="入门例子">入门例子</h2><p>在正式介绍协议细节前，先来看一个简单的例子，有个直观感受。例子包括了 WebSocket 服务端、WebSocket 客户端（网页端）。完整代码可以在 这里 找到。</p><p>这里服务端用了 ws 这个库。相比大家熟悉的 socket.io，ws 实现更轻量，更适合学习的目的。</p><h3 id="服务端">服务端</h3><p>代码如下，监听 8080 端口。当有新的连接请求到达时，打印日志，同时向客户端发送消息。当收到到来自客户端的消息时，同样打印日志。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">app</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">express</span><span class="dl">'</span><span class="p">)();</span>
<span class="kd">var</span> <span class="nx">server</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">http</span><span class="dl">'</span><span class="p">).</span><span class="nx">Server</span><span class="p">(</span><span class="nx">app</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">WebSocket</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">ws</span><span class="dl">'</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">wss</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WebSocket</span><span class="p">.</span><span class="nx">Server</span><span class="p">({</span> <span class="na">port</span><span class="p">:</span> <span class="mi">8080</span> <span class="p">});</span>

<span class="nx">wss</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">connection</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="nx">connection</span><span class="p">(</span><span class="nx">ws</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">server: receive connection.</span><span class="dl">'</span><span class="p">);</span>
    
    <span class="nx">ws</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">message</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="nx">incoming</span><span class="p">(</span><span class="nx">message</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">server: received: %s</span><span class="dl">'</span><span class="p">,</span> <span class="nx">message</span><span class="p">);</span>
    <span class="p">});</span>

    <span class="nx">ws</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="dl">'</span><span class="s1">world</span><span class="dl">'</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">app</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">/</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">sendfile</span><span class="p">(</span><span class="nx">__dirname</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">/index.html</span><span class="dl">'</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="mi">3000</span><span class="p">);</span>
</code></pre></div></div><h3 id="客户端">客户端</h3><p>代码如下，向 8080 端口发起 WebSocket 连接。连接建立后，打印日志，同时向服务端发送消息。接收到来自服务端的消息后，同样打印日志。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">script</span><span class="o">&gt;</span>
  <span class="kd">var</span> <span class="nx">ws</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WebSocket</span><span class="p">(</span><span class="dl">'</span><span class="s1">ws://localhost:8080</span><span class="dl">'</span><span class="p">);</span>
  <span class="nx">ws</span><span class="p">.</span><span class="nx">onopen</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">ws onopen</span><span class="dl">'</span><span class="p">);</span>
    <span class="nx">ws</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="dl">'</span><span class="s1">from client: hello</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">};</span>
  <span class="nx">ws</span><span class="p">.</span><span class="nx">onmessage</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">ws onmessage</span><span class="dl">'</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">from server: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">e</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
  <span class="p">};</span>
<span class="o">&lt;</span><span class="sr">/script</span><span class="err">&gt;
</span></code></pre></div></div><h3 id="运行结果">运行结果</h3><p>可分别查看服务端、客户端的日志，这里不展开。</p><p>服务端输出：</p><div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>server: receive connection.
server: received hello
</code></pre></div></div><p>客户端输出：</p><div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>client: ws connection is open
client: received world
</code></pre></div></div><h2 id="如何建立连接">如何建立连接</h2><p>前面提到，WebSocket 复用了 HTTP 的握手通道。具体指的是，客户端通过 HTTP 请求与 WebSocket 服务端协商升级协议。协议升级完成后，后续的数据交换则遵照 WebSocket 的协议。</p><h3 id="客户端申请协议升级">客户端：申请协议升级</h3><p>首先，客户端发起协议升级请求。可以看到，采用的是标准的 HTTP 报文格式，且只支持 GET 方法。</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET / HTTP/1.1
Host: localhost:8080
Origin: http://127.0.0.1:3000
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Version: 13
Sec-WebSocket-Key: w4v7O6xFTi36lq3RNcgctw==
</code></pre></div></div><p>重点请求首部意义如下：</p><ul><li>Connection: Upgrade：表示要升级协议</li><li>Upgrade: websocket：表示要升级到 websocket 协议。</li><li>Sec-WebSocket-Version: 13：表示 websocket 的版本。如果服务端不支持该版本，需要返回一个 Sec-WebSocket-Versionheader，里面包含服务端支持的版本号。</li><li>Sec-WebSocket-Key：与后面服务端响应首部的 Sec-WebSocket-Accept 是配套的，提供基本的防护，比如恶意的连接，或者无意的连接。 注意，上面请求省略了部分非重点请求首部。由于是标准的 HTTP 请求，类似 Host、Origin、Cookie 等请求首部会照常发送。在握手阶段，可以通过相关请求首部进行 安全限制、权限校验等。</li></ul><h3 id="服务端响应协议升级">服务端：响应协议升级</h3><p>服务端返回内容如下，状态代码 101 表示协议切换。到此完成协议升级，后续的数据交互都按照新的协议来。</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HTTP/1.1 101 Switching Protocols
Connection:Upgrade
Upgrade: websocket
Sec-WebSocket-Accept: Oy4NRAQ13jhfONC7bP8dTKb4PTU=
</code></pre></div></div><blockquote><p>备注：每个 header 都以 \r\n 结尾，并且最后一行加上一个额外的空行 \r\n。此外，服务端回应的 HTTP 状态码只能在握手阶段使用。过了握手阶段后，就只能采用特定的错误码。</p></blockquote><h3 id="sec-websocket-accept-的计算">Sec-WebSocket-Accept 的计算</h3><p>Sec-WebSocket-Accept 根据客户端请求首部的 Sec-WebSocket-Key 计算出来。</p><p>计算公式为：</p><ol><li>将 Sec-WebSocket-Key 跟 258EAFA5-E914-47DA-95CA-C5AB0DC85B11 拼接。</li><li>通过 SHA1 计算出摘要，并转成 base64 字符串。 伪代码如下：<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nx">toBase64</span><span class="p">(</span> <span class="nx">sha1</span><span class="p">(</span> <span class="nx">Sec</span><span class="o">-</span><span class="nx">WebSocket</span><span class="o">-</span><span class="nx">Key</span> <span class="o">+</span> <span class="mi">258</span><span class="nx">EAFA5</span><span class="o">-</span><span class="nx">E914</span><span class="o">-</span><span class="mi">47</span><span class="nx">DA</span><span class="o">-</span><span class="mi">95</span><span class="nx">CA</span><span class="o">-</span><span class="nx">C5AB0DC85B11</span> <span class="p">)</span>  <span class="p">)</span>
</code></pre></div></div></li></ol><p>验证下前面的返回结果：</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">crypto</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">crypto</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">magic</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">258EAFA5-E914-47DA-95CA-C5AB0DC85B11</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">secWebSocketKey</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">w4v7O6xFTi36lq3RNcgctw==</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">let</span> <span class="nx">secWebSocketAccept</span> <span class="o">=</span> <span class="nx">crypto</span><span class="p">.</span><span class="nx">createHash</span><span class="p">(</span><span class="dl">'</span><span class="s1">sha1</span><span class="dl">'</span><span class="p">)</span>
	<span class="p">.</span><span class="nx">update</span><span class="p">(</span><span class="nx">secWebSocketKey</span> <span class="o">+</span> <span class="nx">magic</span><span class="p">)</span>
	<span class="p">.</span><span class="nx">digest</span><span class="p">(</span><span class="dl">'</span><span class="s1">base64</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">secWebSocketAccept</span><span class="p">);</span>
<span class="c1">// Oy4NRAQ13jhfONC7bP8dTKb4PTU=</span>
</code></pre></div></div><h2 id="数据帧格式">数据帧格式</h2><p>客户端、服务端数据的交换，离不开数据帧格式的定义。因此，在实际讲解数据交换之前，我们先来看下 WebSocket 的数据帧格式。</p><p>WebSocket 客户端、服务端通信的最小单位是帧（frame），由 1 个或多个帧组成一条完整的消息（message）。</p><ol><li>发送端：将消息切割成多个帧，并发送给服务端；</li><li>接收端：接收消息帧，并将关联的帧重新组装成完整的消息； 本节的重点，就是讲解数据帧的格式。详细定义可参考 RFC6455 5.2 节 。</li></ol><h3 id="数据帧格式概览">数据帧格式概览</h3><p>下面给出了 WebSocket 数据帧的统一格式。熟悉 TCP/IP 协议的同学对这样的图应该不陌生。</p><ol><li>从左到右，单位是比特。比如 FIN、RSV1 各占据 1 比特，opcode 占据 4 比特。</li><li>内容包括了标识、操作代码、掩码、数据、数据长度等。（下一小节会展开）</li></ol><div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-------+-+-------------+-------------------------------+
 |F|R|R|R| opcode|M| Payload len |    Extended payload length    |
 |I|S|S|S|  <span class="o">(</span>4<span class="o">)</span>  |A|     <span class="o">(</span>7<span class="o">)</span>     |             <span class="o">(</span>16/64<span class="o">)</span>           |
 |N|V|V|V|       |S|             |   <span class="o">(</span><span class="k">if </span>payload <span class="nv">len</span><span class="o">==</span>126/127<span class="o">)</span>   |
 | |1|2|3|       |K|             |                               |
 +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
 |     Extended payload length continued, <span class="k">if </span>payload len <span class="o">==</span> 127  |
 + - - - - - - - - - - - - - - - +-------------------------------+
 |                               |Masking-key, <span class="k">if </span>MASK <span class="nb">set </span>to 1  |
 +-------------------------------+-------------------------------+
 | Masking-key <span class="o">(</span>continued<span class="o">)</span>       |          Payload Data         |
 +-------------------------------- - - - - - - - - - - - - - - - +
 :                     Payload Data continued ...                :
 + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
 |                     Payload Data continued ...                |
 +---------------------------------------------------------------+
</code></pre></div></div><h3 id="数据帧格式详解">数据帧格式详解</h3><p>针对前面的格式概览图，这里逐个字段进行讲解，如有不清楚之处，可参考协议规范，或留言交流。</p><p><strong>FIN</strong>：1 个比特。</p><p>如果是 1，表示这是消息（message）的最后一个分片（fragment），如果是 0，表示不是是消息（message）的最后一个分片（fragment）。</p><p><strong>RSV1, RSV2, RSV3</strong>：各占 1 个比特。</p><p>一般情况下全为 0。当客户端、服务端协商采用 WebSocket 扩展时，这三个标志位可以非 0，且值的含义由扩展进行定义。如果出现非零的值，且并没有采用 WebSocket 扩展，连接出错。</p><p><strong>Opcode</strong>: 4 个比特。</p><p>操作代码，Opcode 的值决定了应该如何解析后续的数据载荷（data payload）。如果操作代码是不认识的，那么接收端应该断开连接（fail the connection）。可选的操作代码如下：</p><ul><li>% x0：表示一个延续帧。当 Opcode 为 0 时，表示本次数据传输采用了数据分片，当前收到的数据帧为其中一个数据分片。</li><li>% x1：表示这是一个文本帧（frame）</li><li>% x2：表示这是一个二进制帧（frame）</li><li>% x3-7：保留的操作代码，用于后续定义的非控制帧。</li><li>% x8：表示连接断开。</li><li>% x9：表示这是一个 ping 操作。</li><li>% xA：表示这是一个 pong 操作。</li><li>% xB-F：保留的操作代码，用于后续定义的控制帧。</li></ul><p><strong>Mask</strong>: 1 个比特。</p><p>表示是否要对数据载荷进行掩码操作。从客户端向服务端发送数据时，需要对数据进行掩码操作；从服务端向客户端发送数据时，不需要对数据进行掩码操作。</p><p>如果服务端接收到的数据没有进行过掩码操作，服务端需要断开连接。</p><p>如果 Mask 是 1，那么在 Masking-key 中会定义一个掩码键（masking key），并用这个掩码键来对数据载荷进行反掩码。所有客户端发送到服务端的数据帧，Mask 都是 1。</p><p>掩码的算法、用途在下一小节讲解。</p><p><strong>Payload length</strong>：数据载荷的长度，单位是字节。为 7 位，或 7+16 位，或 1+64 位。</p><p>假设数 Payload length === x，如果</p><p>x 为 0~126：数据的长度为 x 字节。 x 为 126：后续 2 个字节代表一个 16 位的无符号整数，该无符号整数的值为数据的长度。 x 为 127：后续 8 个字节代表一个 64 位的无符号整数（最高位为 0），该无符号整数的值为数据的长度。 此外，如果 payload length 占用了多个字节的话，payload length 的二进制表达采用网络序（big endian，重要的位在前）。</p><p><strong>Masking-key</strong>：0 或 4 字节（32 位）</p><p>所有从客户端传送到服务端的数据帧，数据载荷都进行了掩码操作，Mask 为 1，且携带了 4 字节的 Masking-key。如果 Mask 为 0，则没有 Masking-key。</p><p>备注：载荷数据的长度，不包括 mask key 的长度。</p><p><strong>Payload data</strong>：(x+y) 字节</p><p>载荷数据：包括了扩展数据、应用数据。其中，扩展数据 x 字节，应用数据 y 字节。</p><p>扩展数据：如果没有协商使用扩展的话，扩展数据数据为 0 字节。所有的扩展都必须声明扩展数据的长度，或者可以如何计算出扩展数据的长度。此外，扩展如何使用必须在握手阶段就协商好。如果扩展数据存在，那么载荷数据长度必须将扩展数据的长度包含在内。</p><p>应用数据：任意的应用数据，在扩展数据之后（如果存在扩展数据），占据了数据帧剩余的位置。载荷数据长度 减去 扩展数据长度，就得到应用数据的长度。</p><h3 id="掩码算法">掩码算法</h3><p>掩码键（Masking-key）是由客户端挑选出来的 32 位的随机数。掩码操作不会影响数据载荷的长度。掩码、反掩码操作都采用如下算法：</p><p>首先，假设：</p><ul><li>original-octet-i：为原始数据的第 i 字节。</li><li>transformed-octet-i：为转换后的数据的第 i 字节。</li><li>j：为 i mod 4 的结果。</li><li>masking-key-octet-j：为 mask key 第 j 字节。 算法描述为： original-octet-i 与 masking-key-octet-j 异或后，得到 transformed-octet-i。</li></ul><blockquote><p>j = i MOD 4 transformed-octet-i = original-octet-i XOR masking-key-octet-j</p></blockquote><h2 id="数据传递">数据传递</h2><p>一旦 WebSocket 客户端、服务端建立连接后，后续的操作都是基于数据帧的传递。</p><p>WebSocket 根据 opcode 来区分操作的类型。比如 0x8 表示断开连接，0x0-0x2 表示数据交互。</p><h3 id="数据分片">数据分片</h3><p>WebSocket 的每条消息可能被切分成多个数据帧。当 WebSocket 的接收方收到一个数据帧时，会根据 FIN 的值来判断，是否已经收到消息的最后一个数据帧。</p><p>FIN=1 表示当前数据帧为消息的最后一个数据帧，此时接收方已经收到完整的消息，可以对消息进行处理。FIN=0，则接收方还需要继续监听接收其余的数据帧。</p><p>此外，opcode 在数据交换的场景下，表示的是数据的类型。0x01 表示文本，0x02 表示二进制。而 0x00 比较特殊，表示延续帧（continuation frame），顾名思义，就是完整消息对应的数据帧还没接收完。</p><h3 id="数据分片例子">数据分片例子</h3><p>直接看例子更形象些。下面例子来自 MDN，可以很好地演示数据的分片。客户端向服务端两次发送消息，服务端收到消息后回应客户端，这里主要看客户端往服务端发送的消息。</p><h4 id="第一条消息">第一条消息</h4><p>FIN=1, 表示是当前消息的最后一个数据帧。服务端收到当前数据帧后，可以处理消息。opcode=0x1，表示客户端发送的是文本类型。</p><h4 id="第二条消息">第二条消息</h4><ol><li>FIN=0，opcode=0x1，表示发送的是文本类型，且消息还没发送完成，还有后续的数据帧。</li><li>FIN=0，opcode=0x0，表示消息还没发送完成，还有后续的数据帧，当前的数据帧需要接在上一条数据帧之后。</li><li>FIN=1，opcode=0x0，表示消息已经发送完成，没有后续的数据帧，当前的数据帧需要接在上一条数据帧之后。服务端可以将关联的数据帧组装成完整的消息。</li></ol><div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Client: <span class="nv">FIN</span><span class="o">=</span>1, <span class="nv">opcode</span><span class="o">=</span>0x1, <span class="nv">msg</span><span class="o">=</span><span class="s2">"hello"</span>
Server: <span class="o">(</span>process <span class="nb">complete </span>message immediately<span class="o">)</span> Hi.
Client: <span class="nv">FIN</span><span class="o">=</span>0, <span class="nv">opcode</span><span class="o">=</span>0x1, <span class="nv">msg</span><span class="o">=</span><span class="s2">"and a"</span>
Server: <span class="o">(</span>listening, new message containing text started<span class="o">)</span>
Client: <span class="nv">FIN</span><span class="o">=</span>0, <span class="nv">opcode</span><span class="o">=</span>0x0, <span class="nv">msg</span><span class="o">=</span><span class="s2">"happy new"</span>
Server: <span class="o">(</span>listening, payload concatenated to previous message<span class="o">)</span>
Client: <span class="nv">FIN</span><span class="o">=</span>1, <span class="nv">opcode</span><span class="o">=</span>0x0, <span class="nv">msg</span><span class="o">=</span><span class="s2">"year!"</span>
Server: <span class="o">(</span>process <span class="nb">complete </span>message<span class="o">)</span> Happy new year to you too!
</code></pre></div></div><h2 id="连接保持--心跳">连接保持 + 心跳</h2><p>WebSocket 为了保持客户端、服务端的实时双向通信，需要确保客户端、服务端之间的 TCP 通道保持连接没有断开。然而，对于长时间没有数据往来的连接，如果依旧长时间保持着，可能会浪费包括的连接资源。</p><p>但不排除有些场景，客户端、服务端虽然长时间没有数据往来，但仍需要保持连接。这个时候，可以采用心跳来实现。</p><ul><li>发送方 -&gt; 接收方：ping</li><li>接收方 -&gt; 发送方：pong ping、pong 的操作，对应的是 WebSocket 的两个控制帧，opcode 分别是 0x9、0xA。</li></ul><p>举例，WebSocket 服务端向客户端发送 ping，只需要如下代码（采用 ws 模块）<br /> <code class="language-plaintext highlighter-rouge">ws.ping('', false, true);</code></p><h2 id="sec-websocket-keyaccept-的作用">Sec-WebSocket-Key/Accept 的作用</h2><p>前面提到了，Sec-WebSocket-Key/Sec-WebSocket-Accept 在主要作用在于提供基础的防护，减少恶意连接、意外连接。</p><p>作用大致归纳如下：</p><ol><li>避免服务端收到非法的 websocket 连接（比如 http 客户端不小心请求连接 websocket 服务，此时服务端可以直接拒绝连接）</li><li>确保服务端理解 websocket 连接。因为 ws 握手阶段采用的是 http 协议，因此可能 ws 连接是被一个 http 服务器处理并返回的，此时客户端可以通过 Sec-WebSocket-Key 来确保服务端认识 ws 协议。（并非百分百保险，比如总是存在那么些无聊的 http 服务器，光3. 处理 Sec-WebSocket-Key，但并没有实现 ws 协议。。。）</li><li>用浏览器里发起 ajax 请求，设置 header 时，Sec-WebSocket-Key 以及其他相关的 header 是被禁止的。这样可以避免客户端发送 ajax 请求时，意外请求协议升级（websocket upgrade）</li><li>可以防止反向代理（不理解 ws 协议）返回错误的数据。比如反向代理前后收到两次 ws 连接的升级请求，反向代理把第一次请求的返回给 cache 住，然后第二次请求到来时直接把 cache 住的请求给返回（无意义的返回）。</li><li>Sec-WebSocket-Key 主要目的并不是确保数据的安全性，因为 Sec-WebSocket-Key、Sec-WebSocket-Accept 的转换计算公式是公开的，而且非常简单，最主要的作用是预防一些常见的意外情况（非故意的）。<blockquote><p>强调：Sec-WebSocket-Key/Sec-WebSocket-Accept 的换算，只能带来基本的保障，但连接是否安全、数据是否安全、客户端 / 服务端是否合法的 ws 客户端、ws 服务端，其实并没有实际性的保证。</p></blockquote></li></ol><h2 id="数据掩码的作用">数据掩码的作用</h2><p>WebSocket 协议中，数据掩码的作用是增强协议的安全性。但数据掩码并不是为了保护数据本身，因为算法本身是公开的，运算也不复杂。除了加密通道本身，似乎没有太多有效的保护通信安全的办法。</p><p>那么为什么还要引入掩码计算呢，除了增加计算机器的运算量外似乎并没有太多的收益（这也是不少同学疑惑的点）。</p><p>答案还是两个字：安全。但并不是为了防止数据泄密，而是为了防止早期版本的协议中存在的代理缓存污染攻击（proxy cache poisoning attacks）等问题。</p><h3 id="代理缓存污染攻击">代理缓存污染攻击</h3><p>下面摘自 2010 年关于安全的一段讲话。其中提到了代理服务器在协议实现上的缺陷可能导致的安全问题。猛击出处。</p><blockquote><p>“We show, empirically, that the current version of the WebSocket consent mechanism is vulnerable to proxy cache poisoning attacks. Even though the WebSocket handshake is based on HTTP, which should be understood by most network intermediaries, the handshake uses the esoteric “Upgrade” mechanism of HTTP [5]. In our experiment, we find that many proxies do not implement the Upgrade mechanism properly, which causes the handshake to succeed even though subsequent traffic over the socket will be misinterpreted by the proxy.”</p></blockquote><blockquote><p>[TALKING] Huang, L-S., Chen, E., Barth, A., Rescorla, E., and C. Jackson, “Talking to Yourself for Fun and Profit”, 2010,</p></blockquote><p>在正式描述攻击步骤之前，我们假设有如下参与者：</p><ul><li>攻击者、攻击者自己控制的服务器（简称 “邪恶服务器”）、攻击者伪造的资源（简称 “邪恶资源”）</li><li>受害者、受害者想要访问的资源（简称 “正义资源”）</li><li>受害者实际想要访问的服务器（简称 “正义服务器”）</li><li>中间代理服务器</li></ul><h4 id="攻击步骤一">攻击步骤一</h4><ol><li>攻击者浏览器 向 邪恶服务器 发起 WebSocket 连接。根据前文，首先是一个协议升级请求。</li><li>协议升级请求 实际到达 代理服务器。</li><li>代理服务器 将协议升级请求转发到 邪恶服务器。</li><li>邪恶服务器 同意连接，代理服务器 将响应转发给 攻击者。 由于 upgrade 的实现上有缺陷，代理服务器 以为之前转发的是普通的 HTTP 消息。因此，当协议服务器 同意连接，代理服务器 以为本次会话已经结束。</li></ol><h4 id="攻击步骤二">攻击步骤二</h4><ol><li>攻击者 在之前建立的连接上，通过 WebSocket 的接口向 邪恶服务器 发送数据，且数据是精心构造的 HTTP 格式的文本。其中包含了 正义资源 的地址，以及一个伪造的 host（指向正义服务器）。（见后面报文）</li><li>请求到达 代理服务器 。虽然复用了之前的 TCP 连接，但 代理服务器 以为是新的 HTTP 请求。</li><li>代理服务器 向 邪恶服务器 请求 邪恶资源。</li><li><p>邪恶服务器 返回 邪恶资源。代理服务器 缓存住 邪恶资源（url 是对的，但 host 是 正义服务器 的地址）。 到这里，受害者可以登场了：</p></li><li>受害者 通过 代理服务器 访问 正义服务器 的 正义资源。</li><li>代理服务器 检查该资源的 url、host，发现本地有一份缓存（伪造的）。</li><li>代理服务器 将 邪恶资源 返回给 受害者。</li><li>受害者 卒。 附：前面提到的精心构造的 “HTTP 请求报文”。</li></ol><div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Client → Server:
POST /path/of/attackers/choice HTTP/1.1 Host: host-of-attackers-choice.com Sec-WebSocket-Key: &lt;connection-key&gt;
Server → Client:
HTTP/1.1 200 OK
Sec-WebSocket-Accept: &lt;connection-key&gt;
</code></pre></div></div><h3 id="当前解决方案">当前解决方案</h3><p>最初的提案是对数据进行加密处理。基于安全、效率的考虑，最终采用了折中的方案：对数据载荷进行掩码处理。</p><p>需要注意的是，这里只是限制了浏览器对数据载荷进行掩码处理，但是坏人完全可以实现自己的 WebSocket 客户端、服务端，不按规则来，攻击可以照常进行。</p><p>但是对浏览器加上这个限制后，可以大大增加攻击的难度，以及攻击的影响范围。如果没有这个限制，只需要在网上放个钓鱼网站骗人去访问，一下子就可以在短时间内展开大范围的攻击。</p><h2 id="写在后面">写在后面</h2><p>WebSocket 可写的东西还挺多，比如 WebSocket 扩展。客户端、服务端之间是如何协商、使用扩展的。WebSocket 扩展可以给协议本身增加很多能力和想象空间，比如数据的压缩、加密，以及多路复用等。</p><p>篇幅所限，这里先不展开，感兴趣的同学可以留言交流。文章如有错漏，敬请指出。</p><h2 id="相关链接">相关链接</h2><p>RFC6455：websocket 规范<br /> https://tools.ietf.org/html/rfc6455</p><p>规范：数据帧掩码细节<br /> https://tools.ietf.org/html/rfc6455#section-5.3</p><p>规范：数据帧格式<br /> https://tools.ietf.org/html/rfc6455#section-5.1</p><p>server-example<br /> https://github.com/websockets/ws#server-example</p><p>编写 websocket 服务器<br /> https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers</p><p>对网络基础设施的攻击（数据掩码操作所要预防的事情）<br /> https://tools.ietf.org/html/rfc6455#section-10.3</p><p>Talking to Yourself for Fun and Profit（含有攻击描述）<br /> http://w2spconf.com/2011/papers/websocket.pdf</p><p>What is Sec-WebSocket-Key for?<br /> https://stackoverflow.com/questions/18265128/what-is-sec-websocket-key-for</p><p>10.3. Attacks On Infrastructure (Masking)<br /> https://tools.ietf.org/html/rfc6455#section-10.3</p><p>Talking to Yourself for Fun and Profit<br /> http://w2spconf.com/2011/papers/websocket.pdf</p><p>Why are WebSockets masked?<br /> https://stackoverflow.com/questions/33250207/why-are-websockets-masked</p><p>How does websocket frame masking protect against cache poisoning?<br /> https://security.stackexchange.com/questions/36930/how-does-websocket-frame-masking-protect-against-cache-poisoning</p><p>What is the mask in a WebSocket frame?<br /> https://stackoverflow.com/questions/14174184/what-is-the-mask-in-a-websocket-frame</p><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="https://lewinz.org" target="_blank">Lewin</a></li><li>本文链接：<a href="https://lewinz.org/2022/01/14/websocket/" target="_blank">https://lewinz.org/2022/01/14/websocket/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名</li></ul></div></article><div class="share"><div class="share-component" data-disabled='qq,weibo,qzone'></div></div><div class="comment"><div id="gitalk-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/vendor/gitalk/gitalk.css"> <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> <script> var gitalk = new Gitalk({ id: '/2022/01/14/websocket/', clientID: '831a35f6d4f6fc049209', clientSecret: '6e80f9a3e9b50b498553e32179ad3adbd893ab7e', repo: 'blog-comments', owner: 'Lewinz', admin: ['Lewinz'], labels: ['gitment'], perPage: 50, }); gitalk.render('gitalk-container'); </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@built/assets/search_data.json?v=1643337221', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"> <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-7093222719567591" data-ad-slot="5263168187" data-ad-format="auto" data-full-width-responsive="true"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2021 <span title="Lewin">Lewin</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/Lewinz/lewinz.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://lewinz.org/" title="首页" target="">首页</a></li><li> <a href="https://lewinz.org/categories/" title="分类" target="">分类</a></li><li> <a href="https://lewinz.org/wiki/" title="维基" target="">维基</a></li><li> <a href="https://lewinz.org/links/" title="链接" target="">链接</a></li><li> <a href="https://lewinz.org/about/" title="关于" target="">关于</a></li><li><a href="https://lewinz.org/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul><script async src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/vendor/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="mobile-hidden" style="margin-top:8px"> <span id="busuanzi_container_site_pv" style="display:none"> 本站访问量<span id="busuanzi_value_site_pv"></span>次 </span> <span id="busuanzi_container_site_uv" style="display:none"> / 本站访客数<span id="busuanzi_value_site_uv"></span>人 </span> <span id="busuanzi_container_page_pv" style="display:none"> / 本页访问量<span id="busuanzi_value_page_pv"></span>次 / 统计始于2021-04-21 </span></div></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/vendor/share.js/dist/js/share.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script><div style="display:none"> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-80669434-1', 'auto'); ga('send', 'pageview'); </script></div></body></html>
