<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="https://lewinz.org/feed.xml" rel="self" type="application/atom+xml" /><link href="https://lewinz.org/" rel="alternate" type="text/html" /><updated>2021-07-30T17:30:18+08:00</updated><id>https://lewinz.org/feed.xml</id><title type="html">阿嫂</title><subtitle>阿嫂个人博客</subtitle><author><name>Lewin</name></author><entry><title type="html">Github 装逼指南 Travis CI 和 Codecov</title><link href="https://lewinz.org/2021/07/29/travis-ci-codecov/" rel="alternate" type="text/html" title="Github 装逼指南 Travis CI 和 Codecov" /><published>2021-07-29T00:00:00+08:00</published><updated>2021-07-29T00:00:00+08:00</updated><id>https://lewinz.org/2021/07/29/travis-ci-codecov</id><content type="html" xml:base="https://lewinz.org/2021/07/29/travis-ci-codecov/">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/travis_ci_codecov_1.png&quot; alt=&quot;travis_ci_codecov_1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;觉得挺酷的。打算在自己的开源组件中也整一套。
经过 Google 决定使用 TravisCI 来进行持续集成，Codecov 来统计单测覆盖率。&lt;/p&gt;

&lt;h2 id=&quot;travis-ci&quot;&gt;Travis CI&lt;/h2&gt;
&lt;p&gt;Travis CI 是国外的开源持续集成构建项目，支持 Github 项目。使用十分方便。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用 Github 账号登录 Travis CI；&lt;/li&gt;
  &lt;li&gt;登录之后会自动同步 Github 项目，选择需要使用 Travis CI 的项目&lt;/li&gt;
  &lt;li&gt;在项目的根目录新增.travis.yml 文件，内容如下：
``` sh
#指定运行环境
language: node_js
#指定nodejs版本，可以指定多个
node_js:
    &lt;ul&gt;
      &lt;li&gt;0.12.5&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;#运行的脚本命令
script:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;npm run ci&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;#指定分支，只有指定的分支提交时才会运行脚本
branches:
  only:
    - master&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
更多语法请看[这里](https://link.segmentfault.com/?url=https%3A%2F%2Fdocs.travis-ci.com%2F)。使用起来非常方便，这样当你每次向 github push 代码的时候，Travis CI 就会自动运行.travis.yml 里面的 script。自动进行编译以及运行单测。

由于 Travis CI 每次 build 之前都会运行 npm install 安装项目依赖的 npm 包，所以在提交代码的时候要保证把所有依赖的包都已经在 package.json 中声明了，否则 build 就会失败。

## Codecov
Codecov 是一个开源的测试结果展示平台，将测试结果可视化。Github 上许多开源项目都使用了 Codecov 来展示单测结果。

Codecov 跟 Travis CI 一样都支持 Github 账号登录，同样会同步 Github 中的项目。在 nodejs 环境下使用 Codecov 需要安装对于的 npm 包，运行下面这个命令进行安装：

`npm install codecov --save-dev`

这个包的作用是将我们运行单测产生的结果文件上传到 Codecov 上进行可视化展示。同时 codecov 支持的结果文件类型为 cobertura。所以需要保证单测执行的结果文件的类型为 cobertura。
前端项目进行单元测试推进 karma + 'jasmine' 的组合。这两个具体是什么东西大家 Google 一下就知道。使用 karma 可以通过简单的配置来运行单测。下面是我一个项目中的配置文件，供大家参考：
``` js
// Karma configuration
// Generated on Mon Feb 01 2016 21:34:22 GMT+0800 (中国标准时间)

module.exports = function(config) {
  config.set({

    // base path that will be used to resolve all patterns (eg. files, exclude)
    basePath: '',


    // frameworks to use
    // available frameworks: https://npmjs.org/browse/keyword/karma-adapter
    // 使用的测试框架jasmine, requirejs支持模块化加载
    frameworks: ['jasmine', 'requirejs'],


    // list of files / patterns to load in the browser
    files: [
        // karma中用到进行requirejs配置的文件
        'test/test-main.js',
        // 测试中需要用到的文件，includeed设为false表示在页面加载的时候不会加载相应的js文件，也就是可以通过requirejs进行异步加载
        {pattern: 'node_modules/jquery/dist/jquery.min.js', included: false},
        {pattern: 'node_modules/angular/angular.min.js', included: false},
        {pattern: 'node_modules/angular-mocks/angular-mocks.js', included: false},
        {pattern: 'src/bg-single-selector.js', included: false},
        {pattern: 'test/selector.spec.js', included: false}
    ],


    // list of files to exclude
    exclude: [
    ],


    // preprocess matching files before serving them to the browser
    // available preprocessors: https://npmjs.org/browse/keyword/karma-preprocessor
    // 针对bg-single-selector.js生成单测覆盖率结果
    preprocessors: {
        'src/bg-single-selector.js': 'coverage'
    },


    // test results reporter to use
    // possible values: 'dots', 'progress'
    // available reporters: https://npmjs.org/browse/keyword/karma-reporter
    // 测试结果的几种输出方式
    reporters: ['progress', 'coverage', 'verbose'],
    // 测试结果报告的类型
    coverageReporter:{
        reporters: [{
            type:'text-summary'
        }, {
            type: 'html',
            dir: 'test/coverage'
        }, {
            // 这就是Codecov支持的文件类型
            type: 'cobertura',
            subdir: '.',
            dir: 'test/coverage'
        }]
    },

    // web server port
    port: 9876,


    // enable / disable colors in the output (reporters and logs)
    colors: true,


    // level of logging
    // possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG
    logLevel: config.LOG_INFO,


    // enable / disable watching file and executing tests whenever any file changes
    autoWatch: true,

    // start these browsers
    // available browser launchers: https://npmjs.org/browse/keyword/karma-launcher
    browsers: ['PhantomJS'],
    // 运行测试依赖的插件
    plugins: [
        'karma-jasmine',
        'karma-coverage',
        'karma-verbose-reporter',
        'karma-phantomjs-launcher',
        'karma-requirejs'
    ],

    // Continuous Integration mode
    // if true, Karma captures browsers, runs the tests and exits
    singleRun: true
  })
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;通过 karma 进行单元测试，将命令写到.travis.yml 中就可以在每次 build 的时候运行单测，同时运行 codecov [cobertura-coverage.xml路径] 就会把单测结果上传到 Codecov。在本地运行 codecov 会失败，需要将这个过程加入到 Travis CI 的 build 脚本中，才能成功上传。因为在本地运行就会被作为私有项目，对于私有项目在上传结果时需要加上 Codecov 提供的 token。&lt;/p&gt;

&lt;h2 id=&quot;在-github-中加入图标&quot;&gt;在 github 中加入图标&lt;/h2&gt;
&lt;p&gt;到了最后一步，Travis CI 和 Codecov 都提供图标链接来展示结果。我们只需要将图标链接加入到项目的 README 中就可以看到结果了。&lt;br /&gt;
对于 Travis CI 来说，点击下图中的图标：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/travis_ci_codecov_2.png&quot; alt=&quot;travis_ci_codecov_2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;就会弹出图标的地址。&lt;br /&gt;
对于 Codecov 来说，打开项目的设置列表就会看到，如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/travis_ci_codecov_3.png&quot; alt=&quot;travis_ci_codecov_3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后只需要将对应的链接加到 README 文件中就可以了。下面是最后的效果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/travis_ci_codecov_4.png&quot; alt=&quot;travis_ci_codecov_4&quot; /&gt;&lt;/p&gt;</content><author><name>Lewin</name></author><category term="github" /><category term="travis" /><category term="codecov" /><summary type="html"></summary></entry><entry><title type="html">http 网络状态码大全</title><link href="https://lewinz.org/2021/07/28/http-status-code/" rel="alternate" type="text/html" title="http 网络状态码大全" /><published>2021-07-28T00:00:00+08:00</published><updated>2021-07-28T00:00:00+08:00</updated><id>https://lewinz.org/2021/07/28/http-status-code</id><content type="html" xml:base="https://lewinz.org/2021/07/28/http-status-code/">&lt;h2 id=&quot;1xx临时响应&quot;&gt;1xx（临时响应）&lt;/h2&gt;
&lt;p&gt;表示临时响应并需要请求者继续执行操作的状态代码。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;代码&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
      &lt;th&gt;详细&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;100&lt;/td&gt;
      &lt;td&gt;继续&lt;/td&gt;
      &lt;td&gt;请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;101&lt;/td&gt;
      &lt;td&gt;切换协议&lt;/td&gt;
      &lt;td&gt;请求者已要求服务器切换协议，服务器已确认并准备切换&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;2xx-成功&quot;&gt;2xx （成功）&lt;/h2&gt;
&lt;p&gt;表示成功处理了请求的状态代码。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;代码&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
      &lt;th&gt;详细&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;200&lt;/td&gt;
      &lt;td&gt;成功&lt;/td&gt;
      &lt;td&gt;服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;201&lt;/td&gt;
      &lt;td&gt;已创建&lt;/td&gt;
      &lt;td&gt;请求成功并且服务器创建了新的资源&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;202&lt;/td&gt;
      &lt;td&gt;已接受&lt;/td&gt;
      &lt;td&gt;服务器已接受请求，但尚未处理&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;203&lt;/td&gt;
      &lt;td&gt;非授权信息&lt;/td&gt;
      &lt;td&gt;服务器已成功处理了请求，但返回的信息可能来自另一来源&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;204&lt;/td&gt;
      &lt;td&gt;无内容&lt;/td&gt;
      &lt;td&gt;服务器成功处理了请求，但没有返回任何内容&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;205&lt;/td&gt;
      &lt;td&gt;重置内容&lt;/td&gt;
      &lt;td&gt;服务器成功处理了请求，但没有返回任何内容&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;206&lt;/td&gt;
      &lt;td&gt;部分内容&lt;/td&gt;
      &lt;td&gt;服务器成功处理了部分 GET 请求&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;3xx-重定向&quot;&gt;3xx （重定向）&lt;/h2&gt;
&lt;p&gt;表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;代码&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
      &lt;th&gt;详细&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;300&lt;/td&gt;
      &lt;td&gt;多种选择&lt;/td&gt;
      &lt;td&gt;针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;301&lt;/td&gt;
      &lt;td&gt;永久移动&lt;/td&gt;
      &lt;td&gt;请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;302&lt;/td&gt;
      &lt;td&gt;临时移动&lt;/td&gt;
      &lt;td&gt;服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;303&lt;/td&gt;
      &lt;td&gt;查看其他位置&lt;/td&gt;
      &lt;td&gt;请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;304&lt;/td&gt;
      &lt;td&gt;未修改&lt;/td&gt;
      &lt;td&gt;自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;305&lt;/td&gt;
      &lt;td&gt;使用代理&lt;/td&gt;
      &lt;td&gt;请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;307&lt;/td&gt;
      &lt;td&gt;临时重定向&lt;/td&gt;
      &lt;td&gt;服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;4xx请求错误&quot;&gt;4xx（请求错误）&lt;/h2&gt;
&lt;p&gt;这些状态代码表示请求可能出错，妨碍了服务器的处理。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;代码&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
      &lt;th&gt;详细&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;400&lt;/td&gt;
      &lt;td&gt;错误请求&lt;/td&gt;
      &lt;td&gt;服务器不理解请求的语法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;401&lt;/td&gt;
      &lt;td&gt;未授权&lt;/td&gt;
      &lt;td&gt;请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;403&lt;/td&gt;
      &lt;td&gt;禁止&lt;/td&gt;
      &lt;td&gt;对资源的访问权限不足&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;404&lt;/td&gt;
      &lt;td&gt;未找到&lt;/td&gt;
      &lt;td&gt;服务器找不到请求的网页&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;405&lt;/td&gt;
      &lt;td&gt;方法禁用&lt;/td&gt;
      &lt;td&gt;禁用请求中指定的方法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;406&lt;/td&gt;
      &lt;td&gt;不接受&lt;/td&gt;
      &lt;td&gt;无法使用请求的内容特性响应请求的网页&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;407&lt;/td&gt;
      &lt;td&gt;需要代理授权&lt;/td&gt;
      &lt;td&gt;此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;408&lt;/td&gt;
      &lt;td&gt;请求超时&lt;/td&gt;
      &lt;td&gt;服务器等候请求时发生超时&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;409&lt;/td&gt;
      &lt;td&gt;冲突&lt;/td&gt;
      &lt;td&gt;服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;410&lt;/td&gt;
      &lt;td&gt;已删除&lt;/td&gt;
      &lt;td&gt;如果请求的资源已永久删除，服务器就会返回此响应&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;411&lt;/td&gt;
      &lt;td&gt;需要有效长度&lt;/td&gt;
      &lt;td&gt;服务器不接受不含有效内容长度标头字段的请求&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;412&lt;/td&gt;
      &lt;td&gt;未满足前提条件&lt;/td&gt;
      &lt;td&gt;服务器未满足请求者在请求中设置的其中一个前提条件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;413&lt;/td&gt;
      &lt;td&gt;请求实体过大&lt;/td&gt;
      &lt;td&gt;服务器无法处理请求，因为请求实体过大，超出服务器的处理能力&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;414&lt;/td&gt;
      &lt;td&gt;请求的 URI 过长&lt;/td&gt;
      &lt;td&gt;请求的 URI（通常为网址）过长，服务器无法处理&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;415&lt;/td&gt;
      &lt;td&gt;不支持的媒体类型&lt;/td&gt;
      &lt;td&gt;请求的格式不受请求页面的支持&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;416&lt;/td&gt;
      &lt;td&gt;请求范围不符合要求&lt;/td&gt;
      &lt;td&gt;如果页面无法提供请求的范围，则服务器会返回此状态代码&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;417&lt;/td&gt;
      &lt;td&gt;未满足期望值&lt;/td&gt;
      &lt;td&gt;服务器未满足” 期望” 请求标头字段的要求&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;5xx服务器错误&quot;&gt;5xx（服务器错误）&lt;/h2&gt;
&lt;p&gt;这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;代码&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
      &lt;th&gt;详细&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;500&lt;/td&gt;
      &lt;td&gt;服务器内部错误&lt;/td&gt;
      &lt;td&gt;服务器遇到错误，无法完成请求。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;501&lt;/td&gt;
      &lt;td&gt;尚未实施&lt;/td&gt;
      &lt;td&gt;服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;502&lt;/td&gt;
      &lt;td&gt;错误网关&lt;/td&gt;
      &lt;td&gt;服务器作为网关或代理，从上游服务器收到无效响应。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;503&lt;/td&gt;
      &lt;td&gt;服务不可用&lt;/td&gt;
      &lt;td&gt;服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;504&lt;/td&gt;
      &lt;td&gt;网关超时&lt;/td&gt;
      &lt;td&gt;服务器作为网关或代理，但是没有及时从上游服务器收到请求。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;505&lt;/td&gt;
      &lt;td&gt;HTTP 版本不受支持&lt;/td&gt;
      &lt;td&gt;服务器不支持请求中所用的 HTTP 协议版本。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;扩展&quot;&gt;扩展&lt;/h2&gt;
&lt;p&gt;RFC 6585 最近刚刚发布，该文档描述了 4 个新的 HTTP 状态码。&lt;/p&gt;

&lt;p&gt;HTTP 协议还在变化？是的，HTTP 协议一直在演变，新的状态码对于开发 REST 服务或者说是基于 HTTP 的服务非常有用，下面我们为你详细介绍这四个新的状态码以及是否应该使用。&lt;/p&gt;

&lt;h3 id=&quot;428-precondition-required-要求先决条件&quot;&gt;428 Precondition Required (要求先决条件)&lt;/h3&gt;
&lt;p&gt;先决条件是客户端发送 HTTP 请求时，如果想要请求能成功必须满足一些预设的条件。&lt;/p&gt;

&lt;p&gt;一个好的例子就是 If-None-Match 头，经常在 GET 请求中使用，如果指定了 If-None-Match ，那么客户端只在响应中的 ETag 改变后才会重新接收回应。&lt;/p&gt;

&lt;p&gt;先决条件的另外一个例子就是 If-Match 头，这个一般用在 PUT 请求上用于指示只更新没被改变的资源，这在多个客户端使用 HTTP 服务时用来防止彼此间不会覆盖相同内容。&lt;/p&gt;

&lt;p&gt;当服务器端使用 428 Precondition Required 状态码时，表示客户端必须发送上述的请求头才能执行请求，这个方法为服务器提供一种有效的方法来阻止 ‘lost update’ 问题。&lt;/p&gt;

&lt;h3 id=&quot;429-too-many-requests-太多请求&quot;&gt;429 Too Many Requests (太多请求)&lt;/h3&gt;
&lt;p&gt;当你需要限制客户端请求某个服务数量时，该状态码就很有用，也就是请求速度限制。&lt;/p&gt;

&lt;p&gt;在此之前，有一些类似的状态码，例如 ‘509 Bandwidth Limit Exceeded’. Twitter 使用 420 （这不是 HTTP 定义的状态码）&lt;/p&gt;

&lt;p&gt;如果你希望限制客户端对服务的请求数，可使用 429 状态码，同时包含一个 Retry-After 响应头用于告诉客户端多长时间后可以再次请求服务。&lt;/p&gt;

&lt;h3 id=&quot;431-request-header-fields-too-large-请求头字段太大&quot;&gt;431 Request Header Fields Too Large (请求头字段太大)&lt;/h3&gt;
&lt;p&gt;某些情况下，客户端发送 HTTP 请求头会变得很大，那么服务器可发送 431 Request Header Fields Too Large 来指明该问题。&lt;/p&gt;

&lt;p&gt;我不太清楚为什么没有 430 状态码，而是直接从 429 跳到 431，我尝试搜索但没有结果。唯一的猜测是 430 Forbidden 跟 403 Forbidden 太像了，为了避免混淆才这么做的，天知道！&lt;/p&gt;

&lt;h3 id=&quot;511-network-authentication-required-要求网络认证&quot;&gt;511 Network Authentication Required (要求网络认证)&lt;/h3&gt;
&lt;p&gt;对我来说这个状态码很有趣，如果你在开发一个 HTTP 服务器，你不一定需要处理该状态码，但如果你在编写 HTTP 客户端，那这个状态码就非常重要。&lt;/p&gt;

&lt;p&gt;如果你频繁使用笔记本和智能手机，你可能会注意到大量的公用 WIFI 服务要求你必须接受一些协议或者必须登录后才能使用。&lt;/p&gt;

&lt;p&gt;这是通过拦截 HTTP 流量，当用户试图访问网络返回一个重定向和登录，这很讨厌，但是实际情况就是这样的。&lt;/p&gt;

&lt;p&gt;使用这些 “拦截” 客户端，会有一些讨厌的副作用。在 RFC 中有提到这两个的例子：&lt;/p&gt;

&lt;p&gt;如果你在登录 WIFI 前访问某个网站，网络设备将会拦截首个请求，这些设备往往也有自己的网站图标 ‘favicon.ico’。登录后您会发现，有一段时间内你访问的网站图标一直是 WIFI 登录网站的图标。&lt;/p&gt;

&lt;p&gt;如果客户端使用 HTTP 请求来查找文档（可能是 JSON），网络将会响应一个登录页，这样你的客户端就会解析错误并导致客户端运行异常，在现实中这种问题非常常见。&lt;/p&gt;

&lt;p&gt;因此 511 状态码的提出就是为了解决这个问题。&lt;/p&gt;

&lt;p&gt;如果你正在编写 HTTP 的客户端，你最好还是检查 511 状态码以确认是否需要认证后才能访问。&lt;/p&gt;</content><author><name>Lewin</name></author><category term="http" /><category term="status" /><summary type="html">1xx（临时响应） 表示临时响应并需要请求者继续执行操作的状态代码。</summary></entry><entry><title type="html">主流软件负载均衡器对比 (LVS、Nginx、HAproxy)</title><link href="https://lewinz.org/2021/07/28/lvs-nginx-haproxy/" rel="alternate" type="text/html" title="主流软件负载均衡器对比 (LVS、Nginx、HAproxy)" /><published>2021-07-28T00:00:00+08:00</published><updated>2021-07-28T00:00:00+08:00</updated><id>https://lewinz.org/2021/07/28/lvs-nginx-haproxy</id><content type="html" xml:base="https://lewinz.org/2021/07/28/lvs-nginx-haproxy/">&lt;h2 id=&quot;负载均衡的三种实现方式&quot;&gt;负载均衡的三种实现方式&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;基于 DNS 负载均衡
    &lt;ul&gt;
      &lt;li&gt;直接通过 DNS 来实现负载均衡。优点是非常简单，缺点是调整后不知道啥时生效 (当然正常情况下几十分钟，长的也可能更长)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;基于硬件负载均衡
    &lt;ul&gt;
      &lt;li&gt;购买硬件，也就是我们常常说的 F5（F5 Network Big-IP），不过 F5 就贵一般来说单台硬件也得几十万块，要是搞个双机，多机就更贵了&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;基于软件负载均衡
    &lt;ul&gt;
      &lt;li&gt;基于软件的方式也非常多，类似几个主流 LVS、Nginx、HAproxy (当然 IBM 也有个 HIS)，接下来就针对以下几种具体说明：&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;三大主流软件负载均衡器对比-lvsnginxhaproxy&quot;&gt;三大主流软件负载均衡器对比 (LVS、Nginx、HAproxy)&lt;/h2&gt;
&lt;h3 id=&quot;lvs&quot;&gt;LVS&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;抗负载能力强，性能高，能达到 F5 的 60%，对内存和 CPU 资源消耗比较低&lt;/li&gt;
  &lt;li&gt;工作在网络 4 层，通过 VRRP 协议 (仅作代理之用)，具体的流量是由 linux 内核来处理，因此没有流量的产生。&lt;/li&gt;
  &lt;li&gt;稳定，可靠性高，自身有完美的热备方案 (Keepalived+lvs)&lt;/li&gt;
  &lt;li&gt;不支持正则处理，不能做动静分离。&lt;/li&gt;
  &lt;li&gt;支持多种负载均衡算法：rr (轮询)，wrr (带权轮询)、lc (最小连接)、wlc (带权最小连接)&lt;/li&gt;
  &lt;li&gt;配置相对复杂，对网络依赖比较大，稳定性很高。&lt;/li&gt;
  &lt;li&gt;LVS 工作模式有 4 种：
    &lt;ul&gt;
      &lt;li&gt;nat 地址转换&lt;/li&gt;
      &lt;li&gt;dr 直接路由&lt;/li&gt;
      &lt;li&gt;tun 隧道&lt;/li&gt;
      &lt;li&gt;full-nat&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;工作在网络 4 层，相对性能上较高 (网络的七层模式：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;nginx&quot;&gt;Nginx&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;工作在网络 7 层，可以针对 http 应用做一些分流的策略，比如针对域名，目录结构&lt;/li&gt;
  &lt;li&gt;Nginx 对网络的依赖较小，理论上能 ping 通就能进行负载功能&lt;/li&gt;
  &lt;li&gt;Nginx 安装配置比较简单，测试起来很方便&lt;/li&gt;
  &lt;li&gt;也可以承担较高的负载压力且稳定，nginx 是为解决 c10k 问题而诞生的&lt;/li&gt;
  &lt;li&gt;对后端服务器的健康检查，只支持通过端口来检测，不支持通过 url 来检测&lt;/li&gt;
  &lt;li&gt;Nginx 对请求的异步处理可以帮助节点服务器减轻负载压力&lt;/li&gt;
  &lt;li&gt;Nginx 仅能支持 http、https 和 Email 协议，这样就在适用范围较小。&lt;/li&gt;
  &lt;li&gt;不支持 Session 的直接保持，但能通过 ip_hash 来解决。对 Big request header 的支持不是很好。&lt;/li&gt;
  &lt;li&gt;Nginx 还能做 Web 服务器即 Cache 功能。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;haproxy&quot;&gt;HAProxy&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;支持两种代理模式：TCP（四层）和 HTTP（七层），支持虚拟主机；&lt;/li&gt;
  &lt;li&gt;能够补充 Nginx 的一些缺点比如 Session 的保持，Cookie 的引导等工作&lt;/li&gt;
  &lt;li&gt;支持 url 检测后端的服务器出问题的检测会有很好的帮助。&lt;/li&gt;
  &lt;li&gt;更多的负载均衡策略比如：动态加权轮循 (Dynamic Round Robin)，加权源地址哈希 (Weighted Source Hash)，加权 URL 哈希和加权参数哈希 (Weighted Parameter Hash) 已经实现&lt;/li&gt;
  &lt;li&gt;单纯从效率上来讲 HAProxy 更会比 Nginx 有更出色的负载均衡速度。&lt;/li&gt;
  &lt;li&gt;HAProxy 可以对 Mysql 进行负载均衡，对后端的 DB 节点进行检测和负载均衡。&lt;/li&gt;
  &lt;li&gt;支持负载均衡算法：Round-robin（轮循）、Weight-round-robin（带权轮循）、source（原地址保持）、RI（请求 URL）、rdp-cookie（根据 cookie）&lt;/li&gt;
  &lt;li&gt;不能做 Web 服务器即 Cache。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;三大主流软件负载均衡器适用业务场景&quot;&gt;三大主流软件负载均衡器适用业务场景&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;网站建设初期，可以选用 Nginx、HAProxy 作为反向代理负载均衡 (流量不大时，可以不选用负载均衡)，因为其配置简单，性能也能满足一般业务场景。如果考虑到负载均衡器是有单点问题，可以采用 Nginx+Keepalived/HAproxy+Keepalived 避免负载均衡器自身的单点问题。&lt;/li&gt;
  &lt;li&gt;网站并发到达一定程度后，为了提高稳定性和转发效率，可以使用 lvs，毕竟 lvs 比 Nginx/HAProxy 要更稳定，转发效率也更高。
注：nginx 与 HAProxy 比较：nginx 只支持七层，用户量最大，稳定性比较可靠。Haproxy 支持四层和七层，支持更多的负载均衡算法，支持 session 等。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;衡量负载均衡器好坏的几个重要的因素&quot;&gt;衡量负载均衡器好坏的几个重要的因素：&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;会话率 ：单位时间内的处理的请求数&lt;/li&gt;
  &lt;li&gt;会话并发能力：并发处理能力&lt;/li&gt;
  &lt;li&gt;数据率：处理数据能力&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;负载均衡的策略&quot;&gt;负载均衡的策略&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;轮询策略&lt;/li&gt;
  &lt;li&gt;负载度策略&lt;/li&gt;
  &lt;li&gt;响应策略&lt;/li&gt;
  &lt;li&gt;哈希策略&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Lewin</name></author><category term="lvc" /><category term="nginx" /><category term="haproxy" /><summary type="html">负载均衡的三种实现方式 基于 DNS 负载均衡 直接通过 DNS 来实现负载均衡。优点是非常简单，缺点是调整后不知道啥时生效 (当然正常情况下几十分钟，长的也可能更长) 基于硬件负载均衡 购买硬件，也就是我们常常说的 F5（F5 Network Big-IP），不过 F5 就贵一般来说单台硬件也得几十万块，要是搞个双机，多机就更贵了 基于软件负载均衡 基于软件的方式也非常多，类似几个主流 LVS、Nginx、HAproxy (当然 IBM 也有个 HIS)，接下来就针对以下几种具体说明：</summary></entry><entry><title type="html">openstack 秒级创建虚机方案</title><link href="https://lewinz.org/2021/07/28/openstack-create-nova/" rel="alternate" type="text/html" title="openstack 秒级创建虚机方案" /><published>2021-07-28T00:00:00+08:00</published><updated>2021-07-28T00:00:00+08:00</updated><id>https://lewinz.org/2021/07/28/openstack-create-nova</id><content type="html" xml:base="https://lewinz.org/2021/07/28/openstack-create-nova/">&lt;p&gt;OpenStack 管理虚拟机生命周期的组件是 Nova，Nova 创建虚拟机从后端存储类型分为本地 LVM 存储和远程分布式存储（例如：Ceph/SheepDog/GlusterFS），从启动方式一般分为镜像启动和卷启动两大类，按启动方式和存储后端可以有 4 种组合&lt;/p&gt;

&lt;h2 id=&quot;本地-lvm--镜像启动&quot;&gt;本地 LVM + 镜像启动&lt;/h2&gt;

&lt;p&gt;此种方式，虚拟机镜像事先一般也会存放在远端的分布式存储上（Ceph 或 Swift）。当在计算节点首次创建虚拟机时，会从远端分布式存储下载镜像到计算节点做格式转换并缓存为 base-image，然后复制完整的镜像到 /var/lib/nova/instances/{instance-uuid} 目录下作为系统盘，耗时跟镜像大小和带宽有关，一般约数分数以上。&lt;/p&gt;

&lt;p&gt;如果在相同的计算节点上第二次以相同的镜像创建虚拟机，因为已经有了镜像缓存，不需要再到远端分布式存储下载镜像，直接从本地计算节点拷贝镜像到虚拟机启动目录作为系统盘，耗时跟镜像大小有关，一般也得数分钟以上。&lt;/p&gt;

&lt;h2 id=&quot;本地-lvm--卷启动&quot;&gt;本地 LVM + 卷启动&lt;/h2&gt;

&lt;p&gt;此种方式，虚拟机镜像事先一般也会存放在远端的分布式存储上（Ceph 或 Swift）。当在计算节点首次创建虚拟机时，会从远端分布式存储下载镜像到计算节点做格式转换并缓存为 base-image，然后调用 cinder 在控制节点以 base-image 创建可 bootable 的卷，最后以该卷启动虚拟机。耗时跟镜像大小和带宽有关，一般也得数分钟以上。&lt;/p&gt;

&lt;p&gt;如果在相同的计算节点上第二次以相同的镜像从卷启动创建虚拟机，因为已经有了镜像缓存，不需要再到远端分布式存储下载镜像，直接调用 cinder 在控制节点以 base-image 创建可 bootable 的卷，最后以该卷启动虚拟机。耗时跟镜像大小和带宽有关，一般也得数分钟以上。&lt;/p&gt;

&lt;h2 id=&quot;远程分布式存储-ceph--镜像启动采用默认配置&quot;&gt;远程分布式存储 Ceph + 镜像启动（采用默认配置）&lt;/h2&gt;

&lt;p&gt;此种方式，虚拟机镜像事先一般也会存放在远端的分布式存储 Ceph 上。当在计算节点首次创建虚拟机时，首先会从远程 Ceph 上下载镜像到该计算节点做格式转换并缓存为 base-image，然后上传 base-image 到远程 Ceph Rbd 的 pool 中作为系统盘，最后以 CephRbd pool 中的系统盘启动虚拟机。耗时跟镜像大小和带宽有关，一般也得数分钟以上。&lt;/p&gt;

&lt;p&gt;在相同的计算节点上第二次以相同的镜像创建虚拟机，因为已经有了镜像缓存，不需要再到远端 Ceph 下载镜像，直接上传 base-image 到远程 Ceph Rbd 的 pool 中作为系统盘，最后以 CephRbd pool 中的系统盘启动虚拟机。耗时跟镜像大小和带宽有关，一般也得数分钟以上。&lt;/p&gt;

&lt;h2 id=&quot;远程分布式存储-ceph--卷启动采用默认配置&quot;&gt;远程分布式存储 Ceph + 卷启动（采用默认配置）&lt;/h2&gt;

&lt;p&gt;此种方式，虚拟机镜像事先一般也会存放在远端的分布式存储 Ceph 上。当在计算节点首次创建虚拟机时，首先会从远程 Ceph 上下载镜像到该计算节点做格式转换并缓存为 base-image，然后调用 cinder 通过 base-image 在远程 Ceph Rbd 的 pool 中创建可 bootable 的启动卷，最后以 Ceph Rbd pool 中的卷启动虚拟机。耗时跟镜像大小和带宽有关，一般也得数分钟以上。&lt;/p&gt;

&lt;p&gt;在相同的计算节点上第二次以相同的镜像以卷启动创建虚拟机，因为已经有了镜像缓存，不需要再到远端 Ceph 下载镜像，直接调用 cinder 通过 base-image 在远程 Ceph Rbd 的 pool 中创建可 bootable 的启动卷，最后以 Ceph Rbd pool 中的卷启动虚拟机。耗时跟镜像大小和带宽有关，一般也得数分钟以上。&lt;/p&gt;

&lt;h2 id=&quot;秒级创建虚拟机优化方案&quot;&gt;秒级创建虚拟机优化方案&lt;/h2&gt;

&lt;p&gt;在优化之前，如果按照上述 4 种组合任一一种来创建虚拟机，如果批量创建几百台虚拟机，因为有镜像的下载、上传或者拷贝流程，整个创建流程会非常耗时，有些会因为接口超时导致失败。&lt;/p&gt;

&lt;p&gt;为了达到秒级创建虚拟机的性能，Glance、Cinder 和 Nova 的后端存储统一以 Ceph 作为共享存储。Glance 上传的虚拟机镜像会上传到 Ceph images pool 中，Cinder 创建的卷会保存在 Ceph volumes pool 中，Nova 系统盘保存在 Cephinstances pool 中。&lt;/p&gt;

&lt;p&gt;如果是以镜像启动创建虚拟机，在同一个计算节点选择相同的镜像不论是第一次还是第二次创建虚拟机，会直接基于 ceph images pool 的镜像先做 snapshot，然后基于该 snapshot 进行 clone（copy on write）到 Cephinstances pool，最后以该系统盘启动虚拟机。利用 ceph 写时复制特性，不存在镜像的上传、下载和完整拷贝，所以创建速度非常快，可以达到秒级。&lt;/p&gt;

&lt;p&gt;如果是以卷启动创建虚拟机，在同一个计算节点选择相同的镜像不论是第一次还是第二次创建虚拟机，会直接基于 ceph images pool 的镜像先做 snapshot，然后调用 cinder 基于该 snapshot 进行 clone（copy on write）到 Ceph volumes pool，最后以该卷启动虚拟机。利用 ceph 写时复制特性，不存在镜像的上传、下载和完整拷贝，所以创建速度非常快，可以达到秒级。&lt;/p&gt;

&lt;h2 id=&quot;秒级创建虚拟机的优化步骤&quot;&gt;秒级创建虚拟机的优化步骤&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;在 controller 控制节点上修改 /etc/glance/glance-api.conf 镜像配置文件，把 show_image_direct_url 参数设置为 True。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;vim /etc/glance/glance-api.conf&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/openstack_create_nova_1.png&quot; alt=&quot;openstack_create_nova_1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意：一定要在【DEFAULT】下添加。&lt;/p&gt;

&lt;p&gt;然后利用命令 serviceopenstack-glance-api restart 重启镜像管理服务。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;转换镜像格式，通过 glance 上传的镜像一定要是 raw 格式。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在上传之前需要命令转换好后上传，转换命令：&lt;/p&gt;

&lt;p&gt;qemu-img convert -O raw src-img.qcow2dst-img.raw&lt;/p&gt;

&lt;p&gt;用命令行转换成 raw 格式，主要是解决如下 no bootable device 问题。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/openstack_create_nova_2.png&quot; alt=&quot;openstack_create_nova_2&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在计算节点上进入 /var/lib/nova/instances/_base/ 目录，清空该目录下所有的缓存镜像。由于后台程序会先检测该目录下有没有缓存镜像，如果有，会把该缓存镜像上传到 ceph 中，如果没有，直接在 ceph 中 clone 镜像。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;步骤如下：&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@openstack _base]# &lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt;/var/lib/nova/instances/_base/

&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@openstack _base]# ll

&lt;span class=&quot;nt&quot;&gt;-rw-r--r--&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; 1 qemu qemu 41126400 Jul 24 01:01d7fca384a7c355afa3b70667b60f04dd08cd6f35

&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@openstack _base]# &lt;span class=&quot;nb&quot;&gt;rm&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-rfd7fca384a7c355afa3b70667b60f04dd08cd6f35&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@openstack _base]# ll

total 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;相关的流程源码如下：&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/openstack_create_nova_3.png&quot; alt=&quot;openstack_create_nova_3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/openstack_create_nova_4.png&quot; alt=&quot;openstack_create_nova_4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[root@openstack ~]# vim /usr/lib/python2.7/site-packages/nova/virt/libvirt/imagebackend.py&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/openstack_create_nova_5.png&quot; alt=&quot;openstack_create_nova_5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[root@openstack ~]# vim /usr/lib/python2.7/site-packages/nova/virt/libvirt/driver.py&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/openstack_create_nova_6.jpeg&quot; alt=&quot;openstack_create_nova_6&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[root@openstack ~]# vim/usr/lib/python2.7/site-packages/glance/api/v2/images.py&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/openstack_create_nova_7.jpeg&quot; alt=&quot;openstack_create_nova_7&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;上述介绍的不同种类的创建虚拟机的组合方式，从核心原理分析其实只有两类。一种是需要完整拷贝镜像，另一种是写时复制（copy on write）。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;完整拷贝镜像创建虚拟机&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;优点：是每个虚拟机独立，不会相互影响。&lt;/p&gt;

&lt;p&gt;缺点：存在镜像下载、上传或者拷贝，创建速度慢。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;写时复制（copyon write）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;优点：每次创建虚拟机都只有很小的增量文件，不存在全量镜像拷贝，创建速度很快。&lt;/p&gt;

&lt;p&gt;缺点：以相同的镜像创建的所有虚拟机依赖共同的 base-image，如果 base-image 意外损坏或删除，上层依赖的虚拟机都会受到影响。&lt;/p&gt;

&lt;p&gt;速度和安全性往往是一对矛盾体，两种方式需要做一定的权衡。可以在完整拷贝镜像创建虚拟机的方案中提升硬件性能，比如通过高配的磁盘和带宽来降低拷贝镜像的时间。也可以在写时复制（copy on write）的方案中，在虚拟机创建成功后的某个恰当时刻，通过后台执行 ceph 的 rbd flatten 命令断开 base-image 和增量 clone 虚拟磁盘的依赖链，达到每个虚拟机相互独立。&lt;/p&gt;</content><author><name>Lewin</name></author><category term="openstack" /><category term="nova" /><summary type="html">OpenStack 管理虚拟机生命周期的组件是 Nova，Nova 创建虚拟机从后端存储类型分为本地 LVM 存储和远程分布式存储（例如：Ceph/SheepDog/GlusterFS），从启动方式一般分为镜像启动和卷启动两大类，按启动方式和存储后端可以有 4 种组合</summary></entry><entry><title type="html">openstack nova 创建虚拟机步骤</title><link href="https://lewinz.org/2021/07/28/openstack-nova-step/" rel="alternate" type="text/html" title="openstack nova 创建虚拟机步骤" /><published>2021-07-28T00:00:00+08:00</published><updated>2021-07-28T00:00:00+08:00</updated><id>https://lewinz.org/2021/07/28/openstack-nova-step</id><content type="html" xml:base="https://lewinz.org/2021/07/28/openstack-nova-step/">&lt;h2 id=&quot;nova-创建虚机总流程&quot;&gt;nova 创建虚机总流程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/openstack_nova_step_1.png&quot; alt=&quot;openstack_nova_step&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;nova-创建虚机请求流&quot;&gt;nova 创建虚机请求流&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;Dashboard 或者 CLI 获取用户的登录信息，调用 Keystone 的 REST API 去做用户身份验证。&lt;/li&gt;
  &lt;li&gt;Keystone 对用户登录信息进行校验，然后产生验证 token 并发回。它会被用于后续 REST 调用请求。&lt;/li&gt;
  &lt;li&gt;Dashboard 或者 CLI 将创建虚机的 REST 请求中的‘launch instance’ 或‘nova-boot’ 部分进行转换，然后调用 nova-api 的 REST 接口。&lt;/li&gt;
  &lt;li&gt;nova-api 接到请求，向 keystone 发送 auth-token 校验和权限认证请求。&lt;/li&gt;
  &lt;li&gt;Keystone 校验 token，并将 auth headers 发回，它包括了 roles 和 permissions。&lt;/li&gt;
  &lt;li&gt;nova-api 和 nova-database 进行交互。&lt;/li&gt;
  &lt;li&gt;nova-database 为新实例创建一个数据库条目。&lt;/li&gt;
  &lt;li&gt;nova-api 向 nova-scheduler 发送  rpc.call 请求，期望它能通过附带的 host ID 获取到数据库条目。&lt;/li&gt;
  &lt;li&gt;nova-scheduler 从 queue 中获取到请求。&lt;/li&gt;
  &lt;li&gt;nova-scheduler 和 nova-database 交互，获取集群中计算节点的信息和状态。&lt;/li&gt;
  &lt;li&gt;nova-scheuler 通过过滤（filtering）和称重（weighting）找到一个合适的计算节点（host）。&lt;/li&gt;
  &lt;li&gt;nova-scheduler 向找到的那个 host 上的 nova-compute 发送 rpc.cast 请求去启动虚机。&lt;/li&gt;
  &lt;li&gt;目标 host 上的 nova-compute 从 queue 中获取到请求。&lt;/li&gt;
  &lt;li&gt;nova-compute 向 nova-condutor 发送 rpc.call 请求去获取待创建虚机的信息比如 host ID 和 flavor 等。&lt;/li&gt;
  &lt;li&gt;nova-conductor 从 queue 中获取到请求。&lt;/li&gt;
  &lt;li&gt;nova-conductor 和 nova-database 交互。&lt;/li&gt;
  &lt;li&gt;nova-database 向 nova-conductor 返回虚机的信息。&lt;/li&gt;
  &lt;li&gt;nova-conductor 向 nova-compute 发送 rpc.call，附带所请求的信息。图中应该是遗漏了一个步骤，就是 nova-compute 从 queue 中获取返回的数据。&lt;/li&gt;
  &lt;li&gt;nova-compute 调用 glance-api 的 REST API，传入 auth-token，去根据镜像 ID 获取镜像 URI，从镜像存储中下载（原文为 upload）镜像。&lt;/li&gt;
  &lt;li&gt;glance-api 向 keystone 校验 auth-token。&lt;/li&gt;
  &lt;li&gt;nova-compute 获取 image 的元数据。&lt;/li&gt;
  &lt;li&gt;nova-compute 调用 Neutron API ，传入 auth-token，去分配和配置网络，比如虚机的 IP 地址。&lt;/li&gt;
  &lt;li&gt;neutron-server 通过 keystone 校验 auth-token。&lt;/li&gt;
  &lt;li&gt;nova-compute 获得网络信息。&lt;/li&gt;
  &lt;li&gt;nova-compute 调用 Cinder API，传入 auth-token，去将 volume 挂接到实例。&lt;/li&gt;
  &lt;li&gt;cinder-api 通过 keystone 校验 auth-token。&lt;/li&gt;
  &lt;li&gt;nova-compute 获得块存储信息。&lt;/li&gt;
  &lt;li&gt;nova-compute 为 hypervisor driver 产生数据，并调用 Hypersior 执行请求（通过 libvirt 或者 api）。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;下表列出了每个步骤中实例的状态&quot;&gt;下表列出了每个步骤中实例的状态：&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Status&lt;/th&gt;
      &lt;th&gt;Task&lt;/th&gt;
      &lt;th&gt;Power state&lt;/th&gt;
      &lt;th&gt;Steps&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Build&lt;/td&gt;
      &lt;td&gt;scheduling&lt;/td&gt;
      &lt;td&gt;None&lt;/td&gt;
      &lt;td&gt;3-12&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Build&lt;/td&gt;
      &lt;td&gt;networking&lt;/td&gt;
      &lt;td&gt;None&lt;/td&gt;
      &lt;td&gt;22-24&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Build&lt;/td&gt;
      &lt;td&gt;block_device_mapping&lt;/td&gt;
      &lt;td&gt;None&lt;/td&gt;
      &lt;td&gt;25-27&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Build&lt;/td&gt;
      &lt;td&gt;spawing&lt;/td&gt;
      &lt;td&gt;None&lt;/td&gt;
      &lt;td&gt;28&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Active&lt;/td&gt;
      &lt;td&gt;none&lt;/td&gt;
      &lt;td&gt;Running&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;nova-compute-接到指令后开始创建虚机的代码分析-第-19-步之后&quot;&gt;nova compute 接到指令后开始创建虚机的代码分析 （第 19 步之后）&lt;/h2&gt;
&lt;p&gt;代码在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;https://github.com/openstack/nova/blob/master/nova/compute/manager.py&lt;/code&gt; 中的 def _build_and_run_instance 函数中：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;_build_resources&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;准备网络和磁盘&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Start&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;building&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;networks&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;asynchronously&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt;
    &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_build_networks_for_instance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;为&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;准备网络资源&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;，&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;实际上是创建一个&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;neutron&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;macs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;driver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;macs_for_instance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;分配mac地址&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;。&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;多绝大多数hypersivor&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;，&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;返回None&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;，&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;也就是不预先分配&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;network_info&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_allocate_network&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;开始异步网络分配&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;nwinfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;network_api&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;allocate_for_instance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Allocate&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;network&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resources&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;_validate_requested_port_ids&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;校验&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ids&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;_validate_requested_network_ids&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;校验&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;network&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ids&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;_clean_security_groups&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;删除&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;安全组&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;_process_security_groups&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Processes&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;validates&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requested&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;security&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;groups&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;allocation&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;_create_ports_for_instance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Create&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;network_requests&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;that&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;don&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'t have a port_id
                    _create_port_minimal //如果port 没有的话，则Attempts to create a port for the instance on the given network.
                        port_client.create_port //调用 port api 来创建 port，包括创建 port，分配MAC及IP地址，更新数据库
                            _generate_mac //生成MAC地址
                            _create_port_with_mac //创建 port
                                //DHCP 相关操作：port 创建完成后会通知 neutron-dhcp-agent去执行port_create_end函数，它会将port的ip和mac信息加载到dnsmasq所需的配置文件中
                            _allocate_ips_for_port //为 port 分配 IP，要么用户有指定，要么从subnets 中选择一个
                                _allocate_specific_ip //如果指定了IP
                                _generate_ip //如果没指定IP
                    return requests_and_created_ports
                _update_ports_for_instance //为特殊case 更新 port
                    _populate_neutron_extension_values
                    _populate_pci_mac_address //只用于处理 SRIOV_PF
                    _populate_mac_address
                    _update_port
                        port_client.update_port //将上述修改通过调用 port api 得以更新port
                    _update_port_dns_name
                        neutron.update_port(port_id, port_req_body) //将 port 的 dns_name 设置为 hostname
                nw_info = self.get_instance_nw_info
                    _build_network_info_model //Return list of ordered VIFs attached to instance
                        _gather_port_ids_and_networks //Return an instance'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;complete&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port_ids&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;networks&lt;/span&gt;
                            &lt;span class=&quot;n&quot;&gt;ifaces&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_network_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nw_info&lt;/span&gt;

    &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Start&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;building&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;block&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;device&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mappings&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt;
    &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_prep_block_device&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Set&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;up&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;block&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;device&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;an&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;logging&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;block_device_info&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;driver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_block_device_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bdms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Converts&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;block&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;device&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mappings&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;driver&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;format&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;mapping&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;driver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block_device_info_get_mapping&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block_device_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;block_device_mapping&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;driver_block_device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;attach_block_devices&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;virt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block_device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;py&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;_log_and_attach&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;首先找出instance&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;将从哪里启动&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;，&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;可能从&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;volume&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;，&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;snapshot&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;，&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;image&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;上启动&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;bdm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;attach&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;真正做&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;attach&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;操作&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_block_device_info_to_legacy&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;block_device_info&lt;/span&gt;

&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;driver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spawn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;调用&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;virt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libvirt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;driver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;py&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;中的&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spawn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;函数&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;，&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;首先创建&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;，&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;然后创建domain&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;disk_info&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blockinfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_disk_info&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;_create_configdrive&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;_create_image&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;创建镜像&lt;/span&gt;
           &lt;span class=&quot;n&quot;&gt;libvirt_utils&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fetch_raw_image&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;IMAGE_API&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;download&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;调用&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;glance&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;API&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;去下载镜像&lt;/span&gt;
           &lt;span class=&quot;n&quot;&gt;_create_and_inject_local_root&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;做文件注入&lt;/span&gt;
           &lt;span class=&quot;n&quot;&gt;_create_ephemeral&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;libvirt_utils&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;create_image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'raw'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'%dG'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ephemeral_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                   &lt;span class=&quot;n&quot;&gt;utils&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'qemu-img'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'create'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'-f'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;disk_format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
           &lt;span class=&quot;n&quot;&gt;_create_swap&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;libvirt_utils&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;create_image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'raw'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'%dM'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;swap_mb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;privsep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unprivileged_mkfs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'swap'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;xml&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_get_guest_xml&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;生成&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;domain&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xml&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;字符串&lt;/span&gt;
           &lt;span class=&quot;n&quot;&gt;conf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_get_guest_config&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;_get_guest_numa_config&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;_get_guest_memory_backing_config&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;_get_guest_config_meta&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;_update_guest_cputune&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;_cpu_config_to_vcpu_model&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;_configure_guest_by_virt_type&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;_set_features&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;_set_clock&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;_get_guest_storage_config&lt;/span&gt;
               &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vif_driver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_config&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;_create_consoles&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;_guest_add_spice_channel&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;_add_video_driver&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;_set_qemu_guest_agent&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;_guest_add_pci_devices&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;_guest_add_watchdog_action&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;_guest_add_memory_balloon&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;_guest_add_mdevs&lt;/span&gt;
               &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;guest&lt;/span&gt;
           &lt;span class=&quot;n&quot;&gt;xml&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;conf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to_xml&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
           &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xml&lt;/span&gt;

       &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_create_domain_and_network&lt;/span&gt;
           &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nova侧去等待neutron侧发送network&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vif&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pluggend事件&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;。&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;neutron&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;linuxbridge&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;agent服务检测tap设备&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;，&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;neutron&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;server发送event事件给nova&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;api&lt;/span&gt;
           &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;virtapi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wait_for_instance_event&lt;/span&gt;
           &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;plug_vifs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;network_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
           &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;firewall_driver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setup_basic_filtering&lt;/span&gt;
           &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;firewall_driver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prepare_instance_filter&lt;/span&gt;
           &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_create_domain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xml&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;libvirt_guest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Guest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xml&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_host&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                   &lt;span class=&quot;n&quot;&gt;write_instance_config&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;virt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libvirt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;host&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;py&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;中&lt;/span&gt;
                   &lt;span class=&quot;n&quot;&gt;domain&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_connection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;defineXML&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xml&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                   &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;libvirt_guest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Guest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;domain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
               &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;guest&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;_wait_for_boot&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;每隔&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;秒检查虚机是否启动&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;_update_instance_after_spawn&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;_update_scheduler_instance_info&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;scheduler_client&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;update_instance_info&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;_notify_about_instance_usage&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;补充&quot;&gt;补充：&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;port 创建成功后的 dhcp 相关操作（参考 &lt;a href=&quot;https://blog.csdn.net/gj19890923/article/details/51558598&quot;&gt;https://blog.csdn.net/gj19890923/article/details/51558598&lt;/a&gt;）：
    &lt;ul&gt;
      &lt;li&gt;创建 VM 时，nova-compute 与 neutron 的 plugin 交互，在 neutron 的数据库中创建 VM 所需的 port 信息。&lt;/li&gt;
      &lt;li&gt;neutron 数据库中的 port 信息创建完成后，通知 neutron-dhcp-agent 去执行 port_create_end 函数。该函数将数据库中的 port 中的 ip 和 mac 信息加载到 dnsmasq 所需的配置文件中 (包括 host 和 addn_hosts 文件)。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@nova 43c0e274-28e3-482e-a32b-d783980fc3ed]# &lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;addn_hosts

  1.1.1.1 host-1-1-1-1.openstacklocal host-1-1-1-1

  1.1.1.2 host-1-1-1-2.openstacklocal host-1-1-1-2

  1.1.1.10        host-1-1-1-10.openstacklocal host-1-1-1-10

&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@nova 43c0e274-28e3-482e-a32b-d783980fc3ed]# &lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;host

  fa:16:3e:d1:d7:72,host-1-1-1-1.openstacklocal,1.1.1.1

  fa:16:3e:da:42:50,host-1-1-1-2.openstacklocal,1.1.1.2

  fa:16:3e:3c:a3:3e,host-1-1-1-10.openstacklocal,1.1.1.10
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@nova 43c0e274-28e3-482e-a32b-d783980fc3ed]# &lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;leases

  1464599134 fa:16:3e:3c:a3:3e 1.1.1.10 host-1-1-1-10 01:fa:16:3e:3c:a3:3e

  1464598886 fa:16:3e:da:42:50 1.1.1.2 host-1-1-1-2 &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;

  1464598886 fa:16:3e:d1:d7:72 1.1.1.1 host-1-1-1-1 &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在 VM 启动时，广播 dhcp discover 请求，当 dnsmasq 进程的监听接口 ns-xxx 监听到这种请求时，dnsmasq 进程将根据配置文件 (host 和 leases 文件) 中的内容去判定是否有未分配的 ip 和 mac 为请求者进行提供。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最终 VM 便真实的获取到与保存在数据库中的 ip 和 mac 信息。neutron-dhcp-agent 只是将所创建 VM 的 ip 和 mac 信息从数据库中获取到自己的配置文件中，然后等到 VM 启动时，为它提供。因此 neutron-dhcp-agent 相当于在 VM 和数据库之间起了个中间桥梁的作用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;nova 在 domain 被创建后等待 neutron event 的过程（请参考 &lt;a href=&quot;http://www.aichengxu.com/linux/9307663.htm&quot;&gt;http://www.aichengxu.com/linux/9307663.htm&lt;/a&gt;）&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;创建VM时， nova-compute服务调用wait_for_instance_event函数等待neutron侧发送event事件。&lt;/li&gt;
      &lt;li&gt;neutron 的 neutron-linuxbridge-agent 定时检测 tap 设备的增加或删除，当创建 VM 时，将创建新的 tap 设备，此时将更新 neutron 数据库中的 ports 表，而 neutron-server 服务创建 core_plugin 时，将利用 sqlalchemy 自带的 event 对 neutron 数据库中的 ports 表进行监视，当 ports 表发生变化时，neutron-server 将通过 HTTP 请求的方式发送 event 事件给 nova。&lt;/li&gt;
      &lt;li&gt;nova侧收到neutron侧发送的event事件，便结束等待，继续创建VM下面的操作。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;虚机被创建后的-l2-网络操作&quot;&gt;虚机被创建后的 L2 网络操作&lt;/h2&gt;
&lt;p&gt;虚机被创建后，nova-compute 节点上的 neutron-linuxbridge-agent 会检测到新建的 tap 设备（通过轮询 /sys/class/net/ 里面的 tap 设备），找到后则执行一系列网络方面的操作，包括设置安全组，&lt;/p&gt;

&lt;p&gt;tap 设备示例：&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@test net]# &lt;span class=&quot;nb&quot;&gt;ls
&lt;/span&gt;brq8165bc3d-40 eth0 eth1 eth1.120 eth2 lo tap712a2c63-e6 tap83e7c095-f0 tap8f4fcfbb-2b
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;tap 设备信息：&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Port tap93121330-58 updated. Details: &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;u&lt;span class=&quot;s1&quot;&gt;'profile'&lt;/span&gt;: &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;, u&lt;span class=&quot;s1&quot;&gt;'allowed_address_pairs'&lt;/span&gt;: &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;, u&lt;span class=&quot;s1&quot;&gt;'admin_state_up'&lt;/span&gt;: True, u&lt;span class=&quot;s1&quot;&gt;'network_id'&lt;/span&gt;: u&lt;span class=&quot;s1&quot;&gt;'8165bc3d-400a-48a0-9186-bf59f7f94b05'&lt;/span&gt;, u&lt;span class=&quot;s1&quot;&gt;'segmentation_id'&lt;/span&gt;: 120,u&lt;span class=&quot;s1&quot;&gt;'device_owner'&lt;/span&gt;: u&lt;span class=&quot;s1&quot;&gt;'compute:nova'&lt;/span&gt;,
u&lt;span class=&quot;s1&quot;&gt;'physical_network'&lt;/span&gt;: u&lt;span class=&quot;s1&quot;&gt;'physnet1'&lt;/span&gt;, u&lt;span class=&quot;s1&quot;&gt;'mac_address'&lt;/span&gt;: u&lt;span class=&quot;s1&quot;&gt;'fa:16:3e:9f:6f:c5'&lt;/span&gt;, u&lt;span class=&quot;s1&quot;&gt;'device'&lt;/span&gt;: u&lt;span class=&quot;s1&quot;&gt;'tap93121330-58'&lt;/span&gt;, u&lt;span class=&quot;s1&quot;&gt;'port_security_enabled'&lt;/span&gt;: True, u&lt;span class=&quot;s1&quot;&gt;'port_id'&lt;/span&gt;: u&lt;span class=&quot;s1&quot;&gt;'93121330-58'&lt;/span&gt;, u&lt;span class=&quot;s1&quot;&gt;'fixed_ips'&lt;/span&gt;: &lt;span class=&quot;o&quot;&gt;[{&lt;/span&gt;u&lt;span class=&quot;s1&quot;&gt;'subnet_id'&lt;/span&gt;: u&lt;span class=&quot;s1&quot;&gt;'ec1028b2-7cb0-4feb-b974-6b8ea7e7f08f'&lt;/span&gt;, u&lt;span class=&quot;s1&quot;&gt;'ip_address'&lt;/span&gt;: u&lt;span class=&quot;s1&quot;&gt;'172.16.0.7'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}]&lt;/span&gt;,
u&lt;span class=&quot;s1&quot;&gt;'network_type'&lt;/span&gt;: u&lt;span class=&quot;s1&quot;&gt;'vlan'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Lewin</name></author><category term="openstack" /><category term="nova" /><summary type="html">nova 创建虚机总流程</summary></entry><entry><title type="html">golang 内存分配</title><link href="https://lewinz.org/2021/07/26/golang-memory-allocation/" rel="alternate" type="text/html" title="golang 内存分配" /><published>2021-07-26T00:00:00+08:00</published><updated>2021-07-26T00:00:00+08:00</updated><id>https://lewinz.org/2021/07/26/golang-memory-allocation</id><content type="html" xml:base="https://lewinz.org/2021/07/26/golang-memory-allocation/">&lt;p&gt;在内存从分配到回收的生命周期中，内存不再被使用的时候，标准库会自动执行 Go 的内存管理。虽然开发者不必操心这些细节，但是 Go 语言所做的底层管理经过了很好的优化，同时有很多有趣的概念。&lt;/p&gt;

&lt;h2 id=&quot;堆上的分配&quot;&gt;堆上的分配&lt;/h2&gt;
&lt;p&gt;内存管理被设计为可以在并发环境快速执行，同时与垃圾收集器集成在了一起。从一个简单的例子开始：&lt;/p&gt;
&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;smallStruct&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int64&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float64&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;smallAllocation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;//go:noinline&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;smallAllocation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;smallStruct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;smallStruct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;注释 //go:noinline 会禁用内联，以避免内联通过移除函数的方式优化这段代码，从而造成最终没有分配内存的情况出现。&lt;/p&gt;

&lt;p&gt;通过运行逃逸分析命令 go tool compile “-m” main.go 可以确认 Go 执行了的分配：
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main.go:14:9: &amp;amp;smallStruct literal escapes to heap&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;借助 go tool compile -S main.go 命令得到这段程序的汇编代码，可以同样明确地向我们展示具体的分配细节：&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0x001d 00029 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;main.go:14&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;   LEAQ   type.&lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;.smallStruct&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;SB&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, AX
0x0024 00036 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;main.go:14&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;  PCDATA &lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt;
0x0024 00036 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;main.go:14&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;  MOVQ   AX, &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;SP&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
0x0028 00040 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;main.go:14&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;  CALL   runtime.newobject&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;SB&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;函数 newobject 是用于新对象的分配以及代理 mallocgc 的内置函数，该函数在堆上管理这些内存。在 Go 语言中有两种策略，一种用于较小的内存空间的分配，而另一种则用于较大的内存空间的分配。&lt;/p&gt;

&lt;h2 id=&quot;较小内存空间的分配策略&quot;&gt;较小内存空间的分配策略&lt;/h2&gt;
&lt;p&gt;对于小于 32kb 的，较小的内存空间的分配策略，Go 会从被叫做 mcache 的本地缓存中尝试获取内存。 这个缓存持有一个被叫做 mspan 的内存块 (span ，32kb 大小的内存块) 列表，mspan 包含着可用于分配的内存：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/golang_memory_allocation_1.png&quot; alt=&quot;golang_memory_allocation_1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每个线程 M 被分配一个处理器 P，并且一次最多处理一个 goroutine。在分配内存时，当前的 goroutine 会使用它当前的 P 的本地缓存，在 span 链表中寻找第一个可用的空闲对象。使用这种本地缓存不需要锁操作，从而分配效率更高。&lt;/p&gt;

&lt;p&gt;span 链表被划分为 8 字节大小到 32k 字节大小的，约 70 个的大小等级，每个等级可以存储不同大小的对象。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/golang_memory_allocation_2.png&quot; alt=&quot;golang_memory_allocation_2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每个 span 链表会存在两份：一个链表用于不包含指针的对象而另一个用于包含指针的对象。这种区别使得垃圾收集器更加轻松，因为它不必扫描不包含任何指针的 span。&lt;/p&gt;

&lt;p&gt;在我们前面的例子中，结构体的大小是 32 字节，因此它会适合于 32 字节的 span ：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/golang_memory_allocation_3.png&quot; alt=&quot;golang_memory_allocation_3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现在，我们可能会好奇，如果在分配期间 span 没有空闲的插槽会发生什么。Go 维护着每个大小等级的 span 的中央链表，该中央链表被叫做 mcentral，其中维护着包含空闲对象的 span 和没有空闲对象的 span ：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/golang_memory_allocation_4.png&quot; alt=&quot;golang_memory_allocation_4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;mcentral 维护着 span 的双向链表；其中每个链表节点有着指向前一个 span 和后一个 span 的引用。非空链表中的 span 可能包含着一些正在使用的内存，“非空” 表示在链表中至少有一个空闲的插槽可供分配。当垃圾收集器清理内存时，可能会清理一部分 span，将这部分标记为不再使用，并将其放回非空链表。&lt;/p&gt;

&lt;p&gt;我们的程序现在可以在没有插槽的情况下向中央链表请求 span ：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/golang_memory_allocation_5.png&quot; alt=&quot;golang_memory_allocation_5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果空链表中没有可用的 span，Go 需要为中央链表获取新的 span 。新的 span 会从堆上分配，并链接到中央链表上：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/golang_memory_allocation_6.png&quot; alt=&quot;golang_memory_allocation_6&quot; /&gt;&lt;/p&gt;

&lt;p&gt;堆会在需要的时候从系统（ OS ）获取内存，如果需要更多的内存，堆会分配一个叫做 arena 的大块内存，在 64 位架构下为 64Mb，在其他架构下大多为 4Mb。arena 同样适用 span 映射内存。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/golang_memory_allocation_7.png&quot; alt=&quot;golang_memory_allocation_7&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;较大内存空间的分配策略&quot;&gt;较大内存空间的分配策略&lt;/h2&gt;
&lt;p&gt;Go 并不适用本地缓存来管理较大的内存空间分配。对于超过 32kb 的分配，会向上取整到页的大小，并直接从堆上分配。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/golang_memory_allocation_8.png&quot; alt=&quot;golang_memory_allocation_8&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;全景图&quot;&gt;全景图&lt;/h2&gt;
&lt;p&gt;现在我们对内存分配的时候发生了什么有了更好的认识。现在将所有的组成部分放在一起来得到完整的图画。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/golang_memory_allocation_9.png&quot; alt=&quot;golang_memory_allocation_9&quot; /&gt;&lt;/p&gt;</content><author><name>Lewin</name></author><category term="golang" /><category term="memory" /><category term="allocation" /><summary type="html">在内存从分配到回收的生命周期中，内存不再被使用的时候，标准库会自动执行 Go 的内存管理。虽然开发者不必操心这些细节，但是 Go 语言所做的底层管理经过了很好的优化，同时有很多有趣的概念。</summary></entry><entry><title type="html">golang 黑魔法(string 与 []byte 转换)</title><link href="https://lewinz.org/2021/07/26/golang-string-covert/" rel="alternate" type="text/html" title="golang 黑魔法(string 与 []byte 转换)" /><published>2021-07-26T00:00:00+08:00</published><updated>2021-07-26T00:00:00+08:00</updated><id>https://lewinz.org/2021/07/26/golang-string-covert</id><content type="html" xml:base="https://lewinz.org/2021/07/26/golang-string-covert/">&lt;p&gt;string 类型和 [] byte 类型是我们编程时最常使用到的数据结构。本文将探讨两者之间的转换方式，通过分析它们之间的内在联系来拨开迷雾。&lt;/p&gt;

&lt;h2 id=&quot;两种转换方式&quot;&gt;两种转换方式&lt;/h2&gt;
&lt;h3 id=&quot;标准转换&quot;&gt;标准转换&lt;/h3&gt;
&lt;p&gt;go 中 string 与 [] byte 的互换，相信每一位 gopher 都能立刻想到以下的转换方式，我们将之称为标准转换。&lt;/p&gt;
&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// string to []byte&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hello&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// []byte to string&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;s2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;强转换&quot;&gt;强转换&lt;/h3&gt;
&lt;p&gt;通过 unsafe 和 reflect 包，可以实现另外一种转换方式，我们将之称为强转换（也常常被人称作黑魔法）。&lt;/p&gt;
&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String2Bytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sh&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reflect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;StringHeader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;bh&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reflect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SliceHeader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sh&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Len&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;sh&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Cap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;sh&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bytes2String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;性能对比&quot;&gt;性能对比&lt;/h2&gt;
&lt;p&gt;既然有两种转换方式，那么我们有必要对它们做性能对比。&lt;/p&gt;
&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// 测试强转换功能&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TestBytes2String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;testing&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hello Gopher!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bytes2String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Fail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// 测试强转换功能&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TestString2Bytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;testing&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Hello Gopher!&quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String2Bytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bytes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Equal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Fail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// 测试标准转换string()性能&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Benchmark_NormalBytes2String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;testing&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hello Gopher! Hello Gopher! Hello Gopher!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// 测试强转换[]byte到string性能&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Benchmark_Byte2String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;testing&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hello Gopher! Hello Gopher! Hello Gopher!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bytes2String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// 测试标准转换[]byte性能&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Benchmark_NormalString2Bytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;testing&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Hello Gopher! Hello Gopher! Hello Gopher!&quot;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// 测试强转换string到[]byte性能&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Benchmark_String2Bytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;testing&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Hello Gopher! Hello Gopher! Hello Gopher!&quot;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String2Bytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;测试结果如下&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;go &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-bench&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;.&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-benchmem&lt;/span&gt;
goos: darwin
goarch: amd64
pkg: workspace/example/stringBytes
Benchmark_NormalBytes2String-8          38363413                27.9 ns/op            48 B/op          1 allocs/op
Benchmark_Byte2String-8                 1000000000               0.265 ns/op           0 B/op          0 allocs/op
Benchmark_NormalString2Bytes-8          32577080                34.8 ns/op            48 B/op          1 allocs/op
Benchmark_String2Bytes-8                1000000000               0.532 ns/op           0 B/op          0 allocs/op
PASS
ok      workspace/example/stringBytes   3.170s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;注意，-benchmem 可以提供每次操作分配内存的次数，以及每次操作分配的字节数。&lt;/p&gt;

&lt;p&gt;当 x 的数据均为 “Hello Gopher!” 时，测试结果如下&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;go &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-bench&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;.&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-benchmem&lt;/span&gt;
goos: darwin
goarch: amd64
pkg: workspace/example/stringBytes
Benchmark_NormalBytes2String-8          245907674                4.86 ns/op            0 B/op          0 allocs/op
Benchmark_Byte2String-8                 1000000000               0.266 ns/op           0 B/op          0 allocs/op
Benchmark_NormalString2Bytes-8          202329386                5.92 ns/op            0 B/op          0 allocs/op
Benchmark_String2Bytes-8                1000000000               0.532 ns/op           0 B/op          0 allocs/op
PASS
ok      workspace/example/stringBytes   4.383s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;强转换方式的性能会明显优于标准转换。&lt;/p&gt;

&lt;p&gt;读者可以思考以下问题&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;为啥强转换性能会比标准转换好？&lt;/li&gt;
  &lt;li&gt;为啥在上述测试中，当 x 的数据较大时，标准转换方式会有一次分配内存的操作，从而导致其性能更差，而强转换方式却不受影响？&lt;/li&gt;
  &lt;li&gt;既然强转换方式性能这么好，为啥 go 语言提供给我们使用的是标准转换方式？&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;原理分析&quot;&gt;原理分析&lt;/h2&gt;
&lt;p&gt;要回答以上三个问题，首先要明白是 string 和 [] byte 在 go 中到底是什么。&lt;/p&gt;
&lt;h3 id=&quot;byte&quot;&gt;[]byte&lt;/h3&gt;
&lt;p&gt;在 go 中，byte 是 uint8 的别名，在 go 标准库 builtin 中有如下说明：&lt;/p&gt;
&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// byte is an alias for uint8 and is equivalent to uint8 in all ways. It is&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// used, by convention, to distinguish byte values from 8-bit unsigned&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// integer values.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint8&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在 go 的源码中 src/runtime/slice.go，slice 的定义如下：&lt;/p&gt;
&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;slice&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;   &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;cap&lt;/span&gt;   &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;array 是底层数组的指针，len 表示长度，cap 表示容量。对于 [] byte 来说，array 指向的就是 byte 数组。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/golang_string_byte_coverted_1.png&quot; alt=&quot;golang_string_byte_coverted_1&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;string&quot;&gt;string&lt;/h3&gt;
&lt;p&gt;关于 string 类型，在 go 标准库 builtin 中有如下说明：&lt;/p&gt;
&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// string is the set of all strings of 8-bit bytes, conventionally but not&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// necessarily representing UTF-8-encoded text. A string may be empty, but&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// not nil. Values of string type are immutable.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;翻译过来就是：string 是 8 位字节的集合，通常但不一定代表 UTF-8 编码的文本。string 可以为空，但是不能为 nil。string 的值是不能改变的。&lt;/p&gt;

&lt;p&gt;在 go 的源码中 src/runtime/string.go，string 的定义如下：&lt;/p&gt;
&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stringStruct&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;stringStruct 代表的就是一个 string 对象，str 指针指向的是某个数组的首地址，len 代表的数组长度。那么这个数组是什么呢？我们可以在实例化 stringStruct 对象时找到答案。&lt;/p&gt;
&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;//go:nosplit&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gostringnocopy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ss&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stringStruct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;findnull&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ss&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;可以看到，入参 str 指针就是指向 byte 的指针，那么我们可以确定 string 的底层数据结构就是 byte 数组。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/golang_string_byte_coverted_2.png&quot; alt=&quot;golang_string_byte_coverted_2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;综上，string 与 [] byte 在底层结构上是非常的相近（后者的底层表达仅多了一个 cap 属性，因此它们在内存布局上是可对齐的），这也就是为何 builtin 中内置函数 copy 会有一种特殊情况 copy(dst []byte, src string) int 的原因了。&lt;/p&gt;
&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// The copy built-in function copies elements from a source slice into a&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// destination slice. (As a special case, it also will copy bytes from a&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// string to a slice of bytes.) The source and destination may overlap. Copy&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// returns the number of elements copied, which will be the minimum of&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// len(src) and len(dst).&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;src&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;区别&quot;&gt;区别&lt;/h3&gt;
&lt;p&gt;对于 [] byte 与 string 而言，两者之间最大的区别就是 string 的值不能改变。这该如何理解呢？下面通过两个例子来说明。&lt;/p&gt;

&lt;p&gt;对于 [] byte 来说，以下操作是可行的：&lt;/p&gt;
&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hello Gopher!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'T'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;string，修改操作是被禁止的：&lt;/p&gt;
&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Hello Gopher!&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'T'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;而 string 能支持这样的操作：&lt;/p&gt;
&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Hello Gopher!&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Tello Gopher!&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;字符串的值不能被更改，但可以被替换。 string 在底层都是结构体 stringStruct{str: str_point, len: str_len}，string 结构体的 str 指针指向的是一个字符常量的地址， 这个地址里面的内容是不可以被改变的，因为它是只读的，但是这个指针可以指向不同的地址。&lt;/p&gt;

&lt;p&gt;那么，以下操作的含义是不同的：&lt;/p&gt;
&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;S1&quot;&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 分配存储&quot;S1&quot;的内存空间，s结构体里的str指针指向这块内存&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;S2&quot;&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;// 分配存储&quot;S2&quot;的内存空间，s结构体里的str指针转为指向这块内存&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 分配存储'1'数组的内存空间，b结构体的array指针指向这个数组。&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;// 将array的内容改为'2'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;图解如下
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/golang_string_byte_coverted_3.png&quot; alt=&quot;golang_string_byte_coverted_3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;因为 string 的指针指向的内容是不可以更改的，所以每更改一次字符串，就得重新分配一次内存，之前分配的空间还需要 gc 回收，这是导致 string 相较于 [] byte 操作低效的根本原因。&lt;/p&gt;

&lt;h3 id=&quot;标准转换的实现细节&quot;&gt;标准转换的实现细节&lt;/h3&gt;
&lt;p&gt;[] byte (string) 的实现（源码在 src/runtime/string.go 中）&lt;/p&gt;
&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// The constant is known to the compiler.&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// There is no fundamental theory behind this number.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tmpStringBufSize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;32&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tmpBuf&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tmpStringBufSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stringtoslicebyte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tmpBuf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tmpBuf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rawbyteslice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// rawbyteslice allocates a new byte slice. The byte slice is not zeroed.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rawbyteslice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;cap&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;roundupsize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uintptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mallocgc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;cap&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uintptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;memclrNoHeapPointers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uintptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)),&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;cap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uintptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;slice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;slice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这里有两种情况：s 的长度是否大于 32。当大于 32 时，go 需要调用 mallocgc 分配一块新的内存（大小由 s 决定），这也就回答了上文中的问题 2：当 x 的数据较大时，标准转换方式会有一次分配内存的操作。&lt;/p&gt;

&lt;p&gt;最后通过 copy 函数实现 string 到 [] byte 的拷贝，具体实现在 src/runtime/slice.go 中的 slicestringcopy 方法。&lt;/p&gt;
&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;slicestringcopy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fm&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c&quot;&gt;// copy的长度取决与string和[]byte的长度最小值&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c&quot;&gt;// 如果开启了竞态检测 -race&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;raceenabled&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;callerpc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getcallerpc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;pc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;funcPC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;slicestringcopy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;racewriterangepc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]),&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uintptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;callerpc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;// 如果开启了memory sanitizer -msan&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msanenabled&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;msanwrite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]),&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uintptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c&quot;&gt;// 该方法将string的底层数组从头部复制n个到[]byte对应的底层数组中去（这里就是copy实现的核心方法，在汇编层面实现 源文件为memmove_*.s）&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;memmove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stringStructOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uintptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;copy 实现过程图解如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/golang_string_byte_coverted_4.png&quot; alt=&quot;golang_string_byte_coverted_4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;string ([] byte) 的实现（源码也在 src/runtime/string.go 中）&lt;/p&gt;
&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// Buf is a fixed-size buffer for the result,&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// it is not nil if the result does not escape.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;slicebytetostring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tmpBuf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;// Turns out to be a relatively common case.&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;// Consider that you want to parse out data between parens in &quot;foo()bar&quot;,&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;// you find the indices and convert the subslice to string.&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;// 如果开启了竞态检测 -race&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;raceenabled&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;racereadrangepc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]),&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;uintptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;getcallerpc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;funcPC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;slicebytetostring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;// 如果开启了memory sanitizer -msan&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msanenabled&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;msanread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]),&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uintptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;stringStructOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;staticbytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]])&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;stringStructOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mallocgc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uintptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)),&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;stringStructOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;stringStructOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;// 拷贝字节数组至字符串&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;memmove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;slice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uintptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// 实例stringStruct对象&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stringStructOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stringStruct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stringStruct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;可见，当数组长度超过 32 时，同样需要调用 mallocgc 分配一块新内存。最后通过 memmove 完成拷贝。&lt;/p&gt;

&lt;h3 id=&quot;强转换的实现细节&quot;&gt;强转换的实现细节&lt;/h3&gt;
&lt;p&gt;万能的 unsafe.Pointer 指针
在 go 中，任何类型的指针 \T 都可以转换为 unsafe.Pointer 类型的指针，它可以存储任何变量的地址。同时，unsafe.Pointer 类型的指针也可以转换回普通指针，而且可以不必和之前的类型 \T 相同。另外，unsafe.Pointer 类型还可以转换为 uintptr 类型，该类型保存了指针所指向地址的数值，从而可以使我们对地址进行数值计算。以上就是强转换方式的实现依据。&lt;/p&gt;

&lt;p&gt;而 string 和 slice 在 reflect 包中，对应的结构体是 reflect.StringHeader 和 reflect.SliceHeader，它们是 string 和 slice 的运行时表达。&lt;/p&gt;
&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StringHeader&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Data&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uintptr&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Len&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SliceHeader&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Data&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uintptr&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Len&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Cap&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;内存布局&quot;&gt;内存布局&lt;/h2&gt;
&lt;p&gt;从 string 和 slice 的运行时表达可以看出，除了 SilceHeader 多了一个 int 类型的 Cap 字段，Date 和 Len 字段是一致的。所以，它们的内存布局是可对齐的，这说明我们就可以直接通过 unsafe.Pointer 进行转换。&lt;/p&gt;

&lt;p&gt;[] byte 转 string 图解&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/golang_string_byte_coverted_5.png&quot; alt=&quot;golang_string_byte_coverted_5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;string 转 [] byte 图解&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/golang_string_byte_coverted_6.png&quot; alt=&quot;golang_string_byte_coverted_6&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;qa&quot;&gt;Q&amp;amp;A&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;为啥强转换性能会比标准转换好？
对于标准转换，无论是从 [] byte 转 string 还是 string 转 [] byte 都会涉及底层数组的拷贝。而强转换是直接替换指针的指向，从而使得 string 和 [] byte 指向同一个底层数组。这样，当然后者的性能会更好。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为啥在上述测试中，当 x 的数据较大时，标准转换方式会有一次分配内存的操作，从而导致其性能更差，而强转换方式却不受影响？
标准转换时，当数据长度大于 32 个字节时，需要通过 mallocgc 申请新的内存，之后再进行数据拷贝工作。而强转换只是更改指针指向。所以，当转换数据较大时，两者性能差距会愈加明显。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;既然强转换方式性能这么好，为啥 go 语言提供给我们使用的是标准转换方式？
首先，我们需要知道 Go 是一门类型安全的语言，而安全的代价就是性能的妥协。但是，性能的对比是相对的，这点性能的妥协对于现在的机器而言微乎其微。另外强转换的方式，会给我们的程序带来极大的安全隐患。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如下示例&lt;/p&gt;
&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hello&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String2Bytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'H'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;a 是 string 类型，前面我们讲到它的值是不可修改的。通过强转换将 a 的底层数组赋给 b，而 b 是一个 [] byte 类型，它的值是可以修改的，所以这时对底层数组的值进行修改，将会造成严重的错误（通过 defer+recover 也不能捕获）。&lt;/p&gt;

&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;unexpected&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fault&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;address&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0x10b6139&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;fatal&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fault&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;signal&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SIGBUS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bus&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0x2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0x10b6139&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0x1088f2c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;为啥 string 要设计为不可修改的？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我认为有必要思考一下该问题。string 不可修改，意味它是只读属性，这样的好处就是：在并发场景下，我们可以在不加锁的控制下，多次使用同一字符串，在保证高效共享的情况下而不用担心安全问题。&lt;/p&gt;

&lt;h2 id=&quot;取舍场景&quot;&gt;取舍场景&lt;/h2&gt;
&lt;p&gt;在你不确定安全隐患的条件下，尽量采用标准方式进行数据转换。&lt;br /&gt;
当程序对运行性能有高要求，同时满足对数据仅仅只有读操作的条件，且存在频繁转换（例如消息转发场景），可以使用强转换。&lt;/p&gt;</content><author><name>Lewin</name></author><category term="golang" /><category term="string" /><category term="byte" /><category term="coverted" /><summary type="html">string 类型和 [] byte 类型是我们编程时最常使用到的数据结构。本文将探讨两者之间的转换方式，通过分析它们之间的内在联系来拨开迷雾。</summary></entry><entry><title type="html">golang 不安全编程</title><link href="https://lewinz.org/2021/07/26/golang-unsafe-programming/" rel="alternate" type="text/html" title="golang 不安全编程" /><published>2021-07-26T00:00:00+08:00</published><updated>2021-07-26T00:00:00+08:00</updated><id>https://lewinz.org/2021/07/26/golang-unsafe-programming</id><content type="html" xml:base="https://lewinz.org/2021/07/26/golang-unsafe-programming/">&lt;p&gt;不安全编程？用 go 语言以来也没发现有啥不安全的啊，而且 go 里面有垃圾回收，也不需要我们来管理内存。当听到不安全编程这几个字，唯一能想到的也就是指针了，只有指针才可能导致不安全问题。我们知道 go 中是有指针的，但是 go 的指针并不能像 C 语言中的指针一样可以进行运算，因此在提供了指针的便利性的同时，又保证了安全。关于 go 中的指针我们之前已经说过了，以及它都做了哪些限制。&lt;/p&gt;

&lt;p&gt;但是在 go 中，可以通过一个叫做 unsafe 的包让指针突破限制，从而进行运算，可一旦用不好就会导致很严重的问题，所以我们说这是不安全编程。但即便如此我们还是可以使用的，因为用好了在某些场景下能够带来很大的便利，而且 go 的内部也在大量的使用 unsafe 这个包。&lt;/p&gt;

&lt;h2 id=&quot;go-语言中的指针&quot;&gt;go 语言中的指针&lt;/h2&gt;
&lt;p&gt;尽管 go 的指针没有 C 的指针那么强大，但是能够获取一个变量的地址，并且能通过地址来改变存储的值，我个人认为已经足够了。&lt;/p&gt;
&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;fmt&quot;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pass_by_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pass_by_pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pass_by_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;传递值：&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;//传递值： 1&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pass_by_pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;传递指针：&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;//传递指针： 3&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们知道 go 的函数传递方式是值传递，不管传递什么，都是拷贝一份出来。而且函数里面形参叫什么是无所谓，这里我们函数的形参不叫 num，叫其他的也无所谓。&lt;/p&gt;

&lt;p&gt;pass_by_value 中接收一个整型，当我们传递 num 的时候，会把 num 的值拷贝一份出来传进去，此时函数里面无论做什么修改，都不会影响外面的 num，因为不是一个东西。&lt;/p&gt;

&lt;p&gt;pass_by_pointer 中接收一个指针，那么传递 &amp;amp;num 的时候，依旧会把指针拷贝一份；我们说 go 只有值传递，传递指针的话也是把指针拷贝一份。由于是拷贝，所以两者没有任何关系，只不过它们存储的地址是一样的，但就变量本身来说，里面的 num 这个 * int 类型的变量和我们传递的 &amp;amp;num 没有关系。由于存储的地址一样，所以两者操作的都是同一片内存，因此 *num = 3 之后是会影响外面的 num 的。但是指针也是拷贝，所以函数里面的 num = nil 跟外面没关系。&lt;/p&gt;

&lt;p&gt;所以 go 的指针在改变内存的值的时候和 C 是一样的，但是它和 C 中的指针相比，又弱化了许多。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;弱化一：go中的指针不能进行数学运算&lt;/li&gt;
  &lt;li&gt;弱化二：go中不同类型的指针不能进行转化或者赋值&lt;/li&gt;
  &lt;li&gt;弱化三：go中不同类型的指针不能进行比较&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;unsafe不安全编程&quot;&gt;unsafe：不安全编程&lt;/h2&gt;
&lt;p&gt;我们知道 go 的指针实际上是类型安全的，因为 go 编译器对类型的检测是十分的严格，让你在享受指针带来的便利时，又给指针施加了很多制约来保证安全。但是保证安全是需要以牺牲效率为代价的，如果你能保证写出的程序就是安全的，那么你可以使用 go 中的不安全指针，从而绕过类型系统的检测，让你的程序运行的更快。&lt;/p&gt;

&lt;p&gt;如果是一个高阶 go 程序员的话，怎么能不会 unsafe 包呢？它可以绕过 go 的类型系统的检测，直接访问内存，增加效率。go 中的很多限制，比如不能操作结构体中的未导出成员等等，但是有了 unsafe 包，就可以直接突破这些限制。所以这个包叫做 unsafe，我们称使用 unsafe 为不安全编程，因为它很危险，官方也不推荐使用，估计正因为如此也设计了这么个名字吧。但是你底层都在大量使用，那我们为什么不能用。&lt;/p&gt;

&lt;p&gt;我们刚才提到了不安全指针，那么我们先来看看什么是不安全指针。&lt;/p&gt;
&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArbitraryType&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ArbitraryType&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArbitraryType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uintptr&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Offsetof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArbitraryType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uintptr&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Alignof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArbitraryType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uintptr&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;unsafe 包下面只有一个 unsafe.go 文件，这个文件里面把注释去掉就上面 6 行代码，是的你没有看错。当然功能肯定都内嵌在编译器里面，至于怎么实现的我们就不管啦，看看怎么用就行了。我们先来看看这两行：&lt;/p&gt;
&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArbitraryType&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ArbitraryType&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Arbitrary 表示任意的，所以这个 Pointer 可以是任何类型的指针，比如：&lt;em&gt;int、&lt;/em&gt;string、*float64 等等。也就是说任何类型的指针都可以传递给它。&lt;/p&gt;
&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;unsafe&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float64&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;//0xc000062080&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;//0xc00004e1c0&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;//0xc000062088&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;unsafe.Pointer() 是有返回值的，返回的当然也是一个指针，但是这个指针同样是无法进行运算的。如果无法运算，那么我们还是无法实现通过指针自增的方式，访问数组的下一个元素啊。别急，所以还有一个整数类型：uintptr，我们 unsafe.Pointer() 是可以和 uintptr 互相转化的，而这个 uintptr 是可以运算的，并且它还足够大。至少我们目前看到了两个功能：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;任何类型的指针都可以和unsafe.Pointer相互转化&lt;/li&gt;
  &lt;li&gt;unsafe.Pointer可以和uintptr互相转化&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;但是需要注意的是，uintptr 并没有指针的含义，所以它指向的内存是会被回收的；而 unsafe.Pointer 有指针的含义，可以确保其指向的对象不会被回收。&lt;/p&gt;

&lt;h2 id=&quot;使用-unsafe-带你突破限制&quot;&gt;使用 unsafe 带你突破限制&lt;/h2&gt;
&lt;p&gt;那么我们就来看看 unsafe 这个包具有哪些黑魔法，以及它有能帮助我们实现什么功能。&lt;/p&gt;

&lt;h3 id=&quot;像-c-语言一样访问数组或切片&quot;&gt;像 C 语言一样访问数组或切片&lt;/h3&gt;
&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;unsafe&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//这里把数字弄成没有规律的，就不用1 2 3 4 5 6了&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;177&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;221&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1211&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;//获取第二个元素的指针，我们也不从头获取&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//因为从中间获取都可以的话，那么从头获取肯定可以&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//然后传给unsafe.Pointer()，将*int转化成Pointer类型&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pointer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;//注意了：下面要将Pointer转成uintptr，因为Pointer是不能运算的&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;u_pointer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uintptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//此时的u_pointer就相当于C中的指针了，但是还有一点不同&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//C中的指针直接++即可，指针会自动移到到下一个元素的位置&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//而go中的uintptr相当于一个整型，我们不能++，而是需要+8，因为一个int占8个字节，所以go中需要加上元素所占的大小&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//所以我们发现C中的+n是从当前元素开始，移动n个元素，不管元素是什么类型。&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//但是go的+n是移动n个字节。&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//所以C中的指针+2 等于 go中uintptr + 2 * (元素类型所占的字节)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;u_pointer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;16&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;//移动两个元素&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;//然后再转回来，要先转成Pointer，再转成对应的指针类型&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pointer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u_pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;//这个pointer是我们通过&amp;amp;arr[1]也就是*int类型的指针得到的，那么结果也要转成*int&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;int_pointer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// 打印了221，结果是正确的&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;int_pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 221&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;//这里也可以转成*string，即便我们的pointer是通过*int得到的&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//因为Pointer可以是任何指针类型&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;string_pointer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//也是可以打印的，但是通过*来访问内存的话就会报错，panic: runtime error: invalid memory address or nil pointer dereference&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string_pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;//0xc00008c048&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;//这里我们再加上1，不加8，那么会出现什么后果&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//我们知道再加上8，就会访问221后面的5&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;u_pointer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u_pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 360287970189639680&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//我们看到此时得到的是一个我们也不知道从哪里来的脏数据，所以一定要加上对应的字节&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;所以我们发现 unsafe.Pointer 就类似于一座桥，*T 通过 Pointer 转成 uintptr，然后进行指针运算，运算完成之后，再通过 Pointer 转回 *T，此时的 *T 就是我们想要的了。&lt;/p&gt;

&lt;h3 id=&quot;指针访问结构体&quot;&gt;指针访问结构体&lt;/h3&gt;
&lt;p&gt;我们知道结构体是可以有字段的，那么我们也可以把结构体想象成数组，字段想象成数组的元素&lt;/p&gt;
&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;unsafe&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;score&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;math&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;english&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;history&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;score&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;math&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;90&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;english&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;92&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;history&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;85&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;//我们看到通过unsafe.Pointer的方式，获取结构体的指针，可以直接转换为结构体第一个字段的指针&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;//90&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//math字段是一个整型，那么p转为uintptr之后加上8，就可以转换成第二个字段的指针&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uintptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;//92&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//同理加上16就是第三个&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uintptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;//85&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;//这里显然就是一个乱七八糟的值了&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uintptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;29&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;//70709489434624&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;我们知道切片是一个结构体，有三个字段，分别是指向底层数组的指针，以及大小和容量。&lt;/p&gt;
&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;unsafe&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//申请大小为5，容量为10的切片&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;//第一个元素显然是指向底层数组的指针，大小也是8个字节。我们来看第二个和第三个&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//虽然有些长，但是从内往外的话，还是很好看懂的。如果不习惯的话可以多写几行&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;长度：%d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uintptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;//长度：5&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;容量：%d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uintptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;//容量：10&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;我们看到 unsafe 包还是很强大的，之所以叫 unsafe 是因为如果用不好后果会很严重。但是如果能正确使用的话，能够做到很多之前做不到的事情。&lt;/p&gt;

&lt;h3 id=&quot;获取对象的大小&quot;&gt;获取对象的大小&lt;/h3&gt;
&lt;p&gt;我们目前可以使用 unsafe 做很多事情了，但是还不够，我们看到 unsafe 这个包除了给我们提供了 Pointer 这个类型之外，还给我们提供了三个函数。&lt;/p&gt;
&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArbitraryType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uintptr&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Offsetof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArbitraryType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uintptr&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Alignof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArbitraryType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uintptr&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这三个函数返回的都是 uintptr 类型，这个类型你就看成是整型即可，它是可以和数字进行运算的，可以转为 int。我们先来看看 Sizeof：&lt;/p&gt;
&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;unsafe&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;123&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;h&quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;//8&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//关于字符串为什么是16&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//go中的字符串在底层是一个结构体，这个结构体有两个元素&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//一个是字符串的首地址，一个是字符串的长度&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//所以是16，因为go的字符串底层对应的是一个字符数组&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;//16&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;//切片我们说过底层也是一个结构体，有三个字段，指向底层数组的指针、大小、容量，所以是24个字节&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;//24&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;go 中的 Sizeof 和 C 中的 sizeof 还是比较类似的，但是 go 中的 Sizeof 不能接收类型本身， 比如你可以传入一个 123，但是你不能传入一个 int，这是不行的。至于获取一个字符串的大小结果是 16，这个是由 go 底层字符串的结构决定的。对了，当我们获取一个结构体的大小的时候，我们看到貌似是将结构体中的每一个字段的值的大小进行相加，至少目前看来是这样的。&lt;/p&gt;

&lt;h3 id=&quot;获取结构体成员的偏移量&quot;&gt;获取结构体成员的偏移量&lt;/h3&gt;
&lt;p&gt;对于一个结构体来说，可以使用 Offsetof 来获取结构体成员的偏移量，进而获取成员的地址，从而改变内存的值。这里提一句：结构体会被分配一块连续的内存，结构体的地址也 代表 了第一个成员的地址。但是你懂的，我们不可能直接通过对结构体的地址加上 * 来获取第一个成员的值，只能通过 unsafe.Pointer 转化，然后再转化成对应类型的指针，才能获取。&lt;/p&gt;
&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;unsafe&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;girl&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//对应的字节数&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;   &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;   &lt;span class=&quot;c&quot;&gt;// 16&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;age&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;      &lt;span class=&quot;c&quot;&gt;// 8&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;gender&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;   &lt;span class=&quot;c&quot;&gt;//16&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;hobby&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;//24&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;girl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;mashiro&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;17&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;f&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;画画&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;开车&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}}&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//首先这几步操作应该不需要解释了，直接想象成数组即可&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;                                          &lt;span class=&quot;c&quot;&gt;// mashiro&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uintptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;               &lt;span class=&quot;c&quot;&gt;// 17&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uintptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;16&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;        &lt;span class=&quot;c&quot;&gt;// f&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uintptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;16&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// [画画 开车]&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;//我们看到即使对具有不同字段类型的结构体，依旧可以自由操作，只要搞清楚每个字段的大小即可&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uintptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;16&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uintptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;16&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)),&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;料理&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// {mashiro 17 f [画画 开车 料理]}&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;//我们看到，即便操作起来没有问题，但是有一个缺陷，就是我们必须要事先计算好每一个字段占多少个字节，尽管我们可以通过unsafe.Sizeof可以很方便的计算。&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//但是有没有不用计算的方法呢？显然有，就是我们说的Offsetof。但是这个Offsetof又有点特殊，它表示的是偏移量&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//比如我想访问hobby这个字段，那么这么做可以，直接以&amp;amp;g为起点，此时偏移量为0，加上unsafe.Offsetof(g.hobby)，直接偏移到hobby&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uintptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Offsetof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hobby&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// [画画 开车 料理]&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;//其余的也是一样，获取哪个字段，直接传入哪个字段即可，个人觉得这个Offsetof比自己计算要方便一些&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uintptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Offsetof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;   &lt;span class=&quot;c&quot;&gt;// mashiro&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uintptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Offsetof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;       &lt;span class=&quot;c&quot;&gt;// 17&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uintptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Offsetof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// f&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;而且我们知道，如果在别的包里面，结构体里的字段没有大写，那么是无法导出的，然鹅即便如此，我们依旧可以通过 unsafe 包绕过这些限制。&lt;/p&gt;
&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hahaha&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OverWatch&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;   &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;age&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Gender&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;weapon&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这些字段有三个没有大写，理论上是无法导出的，因为 golang 会进行检测，但是使用 unsafe 就可以绕过这些检测。&lt;/p&gt;
&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;hahaha&quot;&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;unsafe&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;hero&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hahaha&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OverWatch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//设置name&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uintptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hero&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;麦克雷&quot;&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//设置age，因为Offsetof需要指定访问的字段，而字段又没有被导出，所以无法通过Offsetof的方式&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//因此需要手动计算对应类型的偏移量，因为是string类型，所以加上一个Sizeof(&quot;&quot;)，当然也可以手动填上16&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uintptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hero&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;37&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//这个就可以直接设置了，因为被导出了&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;hero&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Gender&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;男&quot;&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//老规矩，这里是两个string加上一个int的大小&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uintptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hero&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;维和者&quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hero&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// {麦克雷 37 男 维和者}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;参考于：&lt;a href=&quot;https://qcrao.com/2019/06/03/dive-into-go-unsafe/&quot;&gt;https://qcrao.com/2019/06/03/dive-into-go-unsafe/&lt;/a&gt;，用原文作者的话来说就是：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;unsafe 包绕过了 go 的类型系统，达到直接操作内存的目的，使用它有一定的风险性。但是在某些场景下，使用 unsafe 包提供的函数会提升代码的效率，go 源码中也是大量使用 unsafe 包。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;uintptr 可以和 unsafe.Pointer 进行相互转换，uintptr 可以进行数学运算。这样，通过 uintptr 和 unsafe.Pointer 的结合就解决了 go 指针不能进行数学运算的限制。通过 unsafe 相关函数，可以获取结构体私有成员的地址，进而对其做进一步的读写操作，突破 go 的类型安全限制。关于 unsafe 包，我们更多关注它的用法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;顺便说一句，unsafe 包用多了之后，也不觉得它的名字有多么地不 “美观” 了。相反，因为使用了官方并不提倡的东西，反而觉得有点酷炫，或许这就是叛逆的感觉吧。个人非常赞同，觉得真的很酷。&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>Lewin</name></author><category term="golang" /><category term="unsafe" /><category term="programming" /><summary type="html">不安全编程？用 go 语言以来也没发现有啥不安全的啊，而且 go 里面有垃圾回收，也不需要我们来管理内存。当听到不安全编程这几个字，唯一能想到的也就是指针了，只有指针才可能导致不安全问题。我们知道 go 中是有指针的，但是 go 的指针并不能像 C 语言中的指针一样可以进行运算，因此在提供了指针的便利性的同时，又保证了安全。关于 go 中的指针我们之前已经说过了，以及它都做了哪些限制。</summary></entry><entry><title type="html">Makefile</title><link href="https://lewinz.org/2021/07/26/makefile/" rel="alternate" type="text/html" title="Makefile" /><published>2021-07-26T00:00:00+08:00</published><updated>2021-07-26T00:00:00+08:00</updated><id>https://lewinz.org/2021/07/26/makefile</id><content type="html" xml:base="https://lewinz.org/2021/07/26/makefile/">&lt;h2 id=&quot;makefile-介绍&quot;&gt;makefile 介绍&lt;/h2&gt;
&lt;p&gt;make 命令执行时，需要一个 makefile 文件，以告诉 make 命令需要怎么样的去编译和链接程序。&lt;/p&gt;

&lt;p&gt;首先，我们用一个示例来说明 makefile 的书写规则，以便给大家一个感性认识。这个示例来源于 gnu 的 make 使用手册，在这个示例中，我们的工程有 8 个 c 文件，和 3 个头文件，我们要写一个 makefile 来告诉 make 命令如何编译和链接这几个文件。我们的规则是：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;如果这个工程没有编译过，那么我们的所有 c 文件都要编译并被链接。&lt;/li&gt;
  &lt;li&gt;如果这个工程的某几个 c 文件被修改，那么我们只编译被修改的 c 文件，并链接目标程序。&lt;/li&gt;
  &lt;li&gt;如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的 c 文件，并链接目标程序。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;只要我们的 makefile 写得够好，所有的这一切，我们只用一个 make 命令就可以完成，make 命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自动编译所需要的文件和链接目标程序。&lt;/p&gt;

&lt;h2 id=&quot;makefile-的规则&quot;&gt;makefile 的规则&lt;/h2&gt;
&lt;p&gt;在讲述这个 makefile 之前，还是让我们先来粗略地看一看 makefile 的规则。&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;target ... &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;prerequisites ...&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;command&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;target&quot;&gt;target&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;可以是一个 object file（目标文件），也可以是一个执行文件，还可以是一个标签（label）。对于标签这种特性，在后续的 “伪目标” 章节中会有叙述。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;prerequisites&quot;&gt;prerequisites&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;生成该 target 所依赖的文件和 / 或 target&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;command&quot;&gt;command&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;该 target 要执行的命令（任意的 shell 命令）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这是一个文件的依赖关系，也就是说，target 这一个或多个的目标文件依赖于 prerequisites 中的文件，其生成规则定义在 command 中。说白一点就是说:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。
这就是 makefile 的规则，也就是 makefile 中最核心的内容。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;说到底，makefile 的东西就是这样一点，好像我的这篇文档也该结束了。呵呵。还不尽然，这是 makefile 的主线和核心，但要写好一个 makefile 还不够，我会在后面一点一点地结合我的工作经验给你慢慢道来。内容还多着呢。:)&lt;/p&gt;

&lt;h2 id=&quot;一个示例&quot;&gt;一个示例&lt;/h2&gt;
&lt;p&gt;正如前面所说，如果一个工程有 3 个头文件和 8 个 c 文件，为了完成前面所述的那三个规则，我们的 makefile 应该是下面的这个样子的。&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;edit &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main.o kbd.o command.o display.o &lt;/span&gt;\
&lt;span class=&quot;nf&quot;&gt;        insert.o search.o files.o utils.o&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;cc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;edit&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;main.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;kbd.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;command.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;display.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;
        &lt;span class=&quot;err&quot;&gt;insert.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;search.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;files.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;utils.o&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;main.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main.c defs.h&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;cc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;main.c&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;kbd.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;kbd.c defs.h command.h&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;cc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;kbd.c&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;command.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;command.c defs.h command.h&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;cc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;command.c&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;display.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;display.c defs.h buffer.h&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;cc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;display.c&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;insert.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;insert.c defs.h buffer.h&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;cc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;insert.c&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;search.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;search.c defs.h buffer.h&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;cc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;search.c&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;files.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;files.c defs.h buffer.h command.h&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;cc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;files.c&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;utils.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;utils.c defs.h&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;cc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;utils.c&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;clean &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;rm&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;edit&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;main.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;kbd.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;command.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;display.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;
        &lt;span class=&quot;err&quot;&gt;insert.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;search.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;files.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;utils.o&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;反斜杠（ \ ）是换行符的意思。这样比较便于 makefile 的阅读。我们可以把这个内容保存在名字为 “makefile” 或 “Makefile” 的文件中，然后在该目录下直接输入命令 make 就可以生成执行文件 edit。如果要删除执行文件和所有的中间目标文件，那么，只要简单地执行一下 make clean 就可以了。&lt;/p&gt;

&lt;p&gt;在这个 makefile 中，目标文件（target）包含：执行文件 edit 和中间目标文件（ *.o ），依赖文件（prerequisites）就是冒号后面的那些 .c 文件和 .h 文件。每一个 .o 文件都有一组依赖文件，而这些 .o 文件又是执行文件 edit 的依赖文件。依赖关系的实质就是说明了目标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的。&lt;/p&gt;

&lt;p&gt;在定义好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令，一定要以一个 Tab 键作为开头。记住，make 并不管命令是怎么工作的，他只管执行所定义的命令。make 会比较 targets 文件和 prerequisites 文件的修改日期，如果 prerequisites 文件的日期要比 targets 文件的日期要新，或者 target 不存在的话，那么，make 就会执行后续定义的命令。&lt;/p&gt;

&lt;p&gt;这里要说明一点的是， clean 不是一个文件，它只不过是一个动作名字，有点像 c 语言中的 label 一样，其冒号后什么也没有，那么，make 就不会自动去找它的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在 make 命令后明显得指出这个 label 的名字。这样的方法非常有用，我们可以在一个 makefile 中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。&lt;/p&gt;

&lt;h2 id=&quot;make-是如何工作的&quot;&gt;make 是如何工作的&lt;/h2&gt;
&lt;p&gt;在默认的方式下，也就是我们只输入 make 命令。那么，&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;make 会在当前目录下找名字叫 “Makefile” 或 “makefile” 的文件。&lt;/li&gt;
  &lt;li&gt;如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到 “edit” 这个文件，并把这个文件作为最终的目标文件。&lt;/li&gt;
  &lt;li&gt;如果 edit 文件不存在，或是 edit 所依赖的后面的 .o 文件的文件修改时间要比 edit 这个文件新，那么，他就会执行后面所定义的命令来生成 edit 这个文件。&lt;/li&gt;
  &lt;li&gt;如果 edit 所依赖的 .o 文件也不存在，那么 make 会在当前文件中找目标为 .o 文件的依赖性，如果找到则再根据那一个规则生成 .o 文件。（这有点像一个堆栈的过程）&lt;/li&gt;
  &lt;li&gt;当然，你的 C 文件和 H 文件是存在的啦，于是 make 会生成 .o 文件，然后再用 .o 文件生成 make 的终极任务，也就是执行文件 edit 了。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这就是整个 make 的依赖性，make 会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么 make 就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make 根本不理。make 只管文件的依赖性，即，如果在我找了依赖关系之后，冒号后面的文件还是不在，那么对不起，我就不工作啦。&lt;/p&gt;

&lt;p&gt;通过上述分析，我们知道，像 clean 这种，没有被第一个目标文件直接或间接关联，那么它后面所定义的命令将不会被自动执行，不过，我们可以显示要 make 执行。即命令 —— make clean ，以此来清除所有的目标文件，以便重编译。&lt;/p&gt;

&lt;p&gt;于是在我们编程中，如果这个工程已被编译过了，当我们修改了其中一个源文件，比如 file.c ，那么根据我们的依赖性，我们的目标 file.o 会被重编译（也就是在这个依性关系后面所定义的命令），于是 file.o 的文件也是最新的啦，于是 file.o 的文件修改时间要比 edit 要新，所以 edit 也会被重新链接了（详见 edit 目标文件后定义的命令）。&lt;/p&gt;

&lt;p&gt;而如果我们改变了 command.h ，那么， kdb.o 、 command.o 和 files.o 都会被重编译，并且， edit 会被重链接。&lt;/p&gt;

&lt;h2 id=&quot;makefile-中使用变量&quot;&gt;makefile 中使用变量&lt;/h2&gt;
&lt;p&gt;在上面的例子中，先让我们看看 edit 的规则：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;edit &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main.o kbd.o command.o display.o &lt;/span&gt;\
&lt;span class=&quot;nf&quot;&gt;        insert.o search.o files.o utils.o&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;cc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;edit&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;main.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;kbd.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;command.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;display.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;
        &lt;span class=&quot;err&quot;&gt;insert.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;search.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;files.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;utils.o&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;我们可以看到 .o 文件的字符串被重复了两次，如果我们的工程需要加入一个新的 .o 文件，那么我们需要在两个地方加（应该是三个地方，还有一个地方在 clean 中）。当然，我们的 makefile 并不复杂，所以在两个地方加也不累，但如果 makefile 变得复杂，那么我们就有可能会忘掉一个需要加入的地方，而导致编译失败。所以，为了 makefile 的易维护，在 makefile 中我们可以使用变量。makefile 的变量也就是一个字符串，理解成 C 语言中的宏可能会更好。&lt;/p&gt;

&lt;p&gt;比如，我们声明一个变量，叫 objects ， OBJECTS ， objs ， OBJS ， obj 或是 OBJ ，反正不管什么啦，只要能够表示 obj 文件就行了。我们在 makefile 一开始就这样定义：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;objects&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; main.o kbd.o command.o display.o &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
     insert.o search.o files.o utils.o
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;于是，我们就可以很方便地在我们的 makefile 中以 $(objects) 的方式来使用这个变量了，于是我们的改良版 makefile 就变成下面这个样子：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;objects&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; main.o kbd.o command.o display.o &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    insert.o search.o files.o utils.o

&lt;span class=&quot;nl&quot;&gt;edit &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;$(objects)&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;cc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;edit&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$(objects)&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;main.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main.c defs.h&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;cc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;main.c&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;kbd.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;kbd.c defs.h command.h&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;cc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;kbd.c&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;command.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;command.c defs.h command.h&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;cc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;command.c&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;display.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;display.c defs.h buffer.h&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;cc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;display.c&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;insert.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;insert.c defs.h buffer.h&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;cc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;insert.c&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;search.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;search.c defs.h buffer.h&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;cc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;search.c&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;files.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;files.c defs.h buffer.h command.h&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;cc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;files.c&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;utils.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;utils.c defs.h&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;cc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;utils.c&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;clean &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;rm&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;edit&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$(objects)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;于是如果有新的 .o 文件加入，我们只需简单地修改一下 objects 变量就可以了。&lt;/p&gt;

&lt;h2 id=&quot;让-make-自动推导&quot;&gt;让 make 自动推导&lt;/h2&gt;
&lt;p&gt;GNU 的 make 很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个 .o 文件后都写上类似的命令，因为，我们的 make 会自动识别，并自己推导命令。&lt;/p&gt;

&lt;p&gt;只要 make 看到一个 .o 文件，它就会自动的把 .c 文件加在依赖关系中，如果 make 找到一个 whatever.o ，那么 whatever.c 就会是 whatever.o 的依赖文件。并且 cc -c whatever.c 也会被推导出来，于是，我们的 makefile 再也不用写得这么复杂。我们的新 makefile 又出炉了。&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;objects&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; main.o kbd.o command.o display.o &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    insert.o search.o files.o utils.o

&lt;span class=&quot;nl&quot;&gt;edit &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;$(objects)&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;cc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;edit&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$(objects)&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;main.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;defs.h&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;kbd.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;defs.h command.h&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;command.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;defs.h command.h&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;display.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;defs.h buffer.h&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;insert.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;defs.h buffer.h&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;search.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;defs.h buffer.h&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;files.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;defs.h buffer.h command.h&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;utils.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;defs.h&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;.PHONY &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;clean&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;clean &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;rm&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;edit&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$(objects)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这种方法，也就是 make 的 “隐晦规则”。上面文件内容中， .PHONY 表示 clean 是个伪目标文件。&lt;/p&gt;

&lt;h2 id=&quot;另类风格的-makefiles&quot;&gt;另类风格的 makefiles&lt;/h2&gt;
&lt;p&gt;既然我们的 make 可以自动推导命令，那么我看到那堆 .o 和 .h 的依赖就有点不爽，那么多的重复的 .h ，能不能把其收拢起来，好吧，没有问题，这个对于 make 来说很容易，谁叫它提供了自动推导命令和文件的功能呢？来看看最新风格的 makefile 吧。&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;objects&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; main.o kbd.o command.o display.o &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    insert.o search.o files.o utils.o

&lt;span class=&quot;nl&quot;&gt;edit &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;$(objects)&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;cc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;edit&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$(objects)&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;$(objects) &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;defs.h&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;kbd.o command.o files.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;command.h&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;display.o insert.o search.o files.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;buffer.h&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;.PHONY &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;clean&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;clean &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;rm&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;edit&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$(objects)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这种风格，让我们的 makefile 变得很简单，但我们的文件依赖关系就显得有点凌乱了。鱼和熊掌不可兼得。还看你的喜好了。我是不喜欢这种风格的，一是文件的依赖关系看不清楚，二是如果文件一多，要加入几个新的 .o 文件，那就理不清楚了。&lt;/p&gt;

&lt;h2 id=&quot;清空目标文件的规则&quot;&gt;清空目标文件的规则&lt;/h2&gt;
&lt;p&gt;每个 Makefile 中都应该写一个清空目标文件（ .o 和执行文件）的规则，这不仅便于重编译，也很利于保持文件的清洁。这是一个 “修养”（呵呵，还记得我的《编程修养》吗）。一般的风格都是：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;clean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;rm&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;edit&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$(objects)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;更为稳健的做法是：&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;.PHONY &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;clean&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;clean &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;-rm&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;edit&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$(objects)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;前面说过， .PHONY 表示 clean 是一个 “伪目标”。而在 rm 命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。当然， clean 的规则不要放在文件的开头，不然，这就会变成 make 的默认目标，相信谁也不愿意这样。不成文的规矩是 ——“clean 从来都是放在文件的最后”。&lt;/p&gt;

&lt;p&gt;上面就是一个 makefile 的概貌，也是 makefile 的基础，下面还有很多 makefile 的相关细节，准备好了吗？准备好了就来。&lt;/p&gt;

&lt;h2 id=&quot;makefile-里有什么&quot;&gt;Makefile 里有什么？&lt;/h2&gt;
&lt;p&gt;Makefile 里主要包含了五个东西：&lt;strong&gt;显式规则&lt;/strong&gt;、&lt;strong&gt;隐晦规则&lt;/strong&gt;、&lt;strong&gt;变量定义&lt;/strong&gt;、&lt;strong&gt;文件指示和注释&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;显式规则&quot;&gt;显式规则&lt;/h3&gt;
&lt;p&gt;显式规则说明了如何生成一个或多个目标文件。这是由 Makefile 的书写者明显指出要生成的文件、文件的依赖文件和生成的命令。&lt;/p&gt;

&lt;h3 id=&quot;隐晦规则&quot;&gt;隐晦规则&lt;/h3&gt;
&lt;p&gt;由于我们的 make 有自动推导的功能，所以隐晦的规则可以让我们比较简略地书写 Makefile，这是由 make 所支持的。&lt;/p&gt;

&lt;h3 id=&quot;变量定义&quot;&gt;变量定义&lt;/h3&gt;
&lt;p&gt;在 Makefile 中我们要定义一系列的变量，变量一般都是字符串，这个有点像你 C 语言中的宏，当 Makefile 被执行时，其中的变量都会被扩展到相应的引用位置上。&lt;/p&gt;

&lt;h3 id=&quot;文件指示&quot;&gt;文件指示&lt;/h3&gt;
&lt;p&gt;其包括了三个部分，一个是在一个 Makefile 中引用另一个 Makefile，就像 C 语言中的 include 一样；另一个是指根据某些情况指定 Makefile 中的有效部分，就像 C 语言中的预编译 #if 一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。&lt;/p&gt;

&lt;h3 id=&quot;注释&quot;&gt;注释&lt;/h3&gt;
&lt;p&gt;Makefile 中只有行注释，和 UNIX 的 Shell 脚本一样，其注释是用 # 字符，这个就像 C/C++ 中的 // 一样。如果你要在你的 Makefile 中使用 # 字符，可以用反斜杠进行转义，如： # 。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;最后，还值得一提的是，在 Makefile 中的命令，必须要以 Tab 键开始。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;makefile-的文件名&quot;&gt;Makefile 的文件名&lt;/h2&gt;
&lt;p&gt;默认的情况下，make 命令会在当前目录下按顺序找寻文件名为 “GNUmakefile”、“makefile”、“Makefile” 的文件，找到了解释这个文件。在这三个文件名中，最好使用 “Makefile” 这个文件名，因为，这个文件名第一个字符为大写，这样有一种显目的感觉。最好不要用 “GNUmakefile”，这个文件是 GNU 的 make 识别的。有另外一些 make 只对全小写的 “makefile” 文件名敏感，但是基本上来说，大多数的 make 都支持 “makefile” 和 “Makefile” 这两种默认文件名。&lt;/p&gt;

&lt;p&gt;当然，你可以使用别的文件名来书写 Makefile，比如：“Make.Linux”，“Make.Solaris”，“Make.AIX” 等，如果要指定特定的 Makefile，你可以使用 make 的 -f 和 –file 参数，如： make -f Make.Linux 或 make –file Make.AIX 。&lt;/p&gt;

&lt;h2 id=&quot;引用其它的-makefile&quot;&gt;引用其它的 Makefile&lt;/h2&gt;
&lt;p&gt;在 Makefile 使用 include 关键字可以把别的 Makefile 包含进来，这很像 C 语言的 #include ，被包含的文件会原模原样的放在当前文件的包含位置。 include 的语法是：&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;include &amp;lt;filename&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;filename 可以是当前操作系统 Shell 的文件模式（可以包含路径和通配符）。&lt;/p&gt;

&lt;p&gt;在 include 前面可以有一些空字符，但是绝不能是 Tab 键开始。 include 和 &lt;filename&gt; 可以用一个或多个空格隔开。举个例子，你有这样几个 Makefile： a.mk 、 b.mk 、 c.mk ，还有一个文件叫 foo.make ，以及一个变量 $(bar) ，其包含了 e.mk 和 f.mk ，那么，下面的语句：&lt;/filename&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;include foo.make *.mk $(bar)&lt;/code&gt;&lt;br /&gt;
等价于：&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;include foo.make a.mk b.mk c.mk e.mk f.mk&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;make 命令开始时，会找寻 include 所指出的其它 Makefile，并把其内容安置在当前的位置。就好像 C/C++ 的 #include 指令一样。如果文件都没有指定绝对路径或是相对路径的话，make 会在当前目录下首先寻找，如果当前目录下没有找到，那么，make 还会在下面的几个目录下找：&lt;/p&gt;

&lt;p&gt;如果 make 执行时，有 -I 或 –include-dir 参数，那么 make 就会在这个参数所指定的目录下去寻找。&lt;br /&gt;
如果目录 &lt;prefix&gt;/include （一般是： /usr/local/bin 或 /usr/include ）存在的话，make 也会去找。  
如果有文件没有找到的话，make 会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成 makefile 的读取，make 会再重试这些没有找到，或是不能读取的文件，如果还是不行，make 才会出现一条致命信息。如果你想让 make 不理那些无法读取的文件，而继续执行，你可以在 include 前加一个减号 “-”。如：  
`-include &lt;filename&gt;`&lt;/filename&gt;&lt;/prefix&gt;&lt;/p&gt;

&lt;p&gt;其表示，无论 include 过程中出现什么错误，都不要报错继续执行。和其它版本 make 兼容的相关命令是 sinclude，其作用和这一个是一样的。&lt;/p&gt;

&lt;h2 id=&quot;环境变量-makefiles&quot;&gt;环境变量 MAKEFILES&lt;/h2&gt;
&lt;p&gt;如果你的当前环境中定义了环境变量 MAKEFILES ，那么，make 会把这个变量中的值做一个类似于 include 的动作。这个变量中的值是其它的 Makefile，用空格分隔。只是，它和 include 不同的是，从这个环境变量中引入的 Makefile 的 “目标” 不会起作用，如果环境变量中定义的文件发现错误，make 也会不理。&lt;/p&gt;

&lt;p&gt;但是在这里我还是建议不要使用这个环境变量，因为只要这个变量一被定义，那么当你使用 make 时，所有的 Makefile 都会受到它的影响，这绝不是你想看到的。在这里提这个事，只是为了告诉大家，也许有时候你的 Makefile 出现了怪事，那么你可以看看当前环境中有没有定义这个变量。&lt;/p&gt;

&lt;h2 id=&quot;make-的工作方式&quot;&gt;make 的工作方式&lt;/h2&gt;
&lt;p&gt;GNU 的 make 工作时的执行步骤如下：（想来其它的 make 也是类似）&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;读入所有的 Makefile。&lt;/li&gt;
  &lt;li&gt;读入被 include 的其它 Makefile。&lt;/li&gt;
  &lt;li&gt;初始化文件中的变量。&lt;/li&gt;
  &lt;li&gt;推导隐晦规则，并分析所有规则。&lt;/li&gt;
  &lt;li&gt;为所有的目标文件创建依赖关系链。&lt;/li&gt;
  &lt;li&gt;根据依赖关系，决定哪些目标要重新生成。&lt;/li&gt;
  &lt;li&gt;执行生成命令。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1-5 步为第一个阶段，6-7 为第二个阶段。第一个阶段中，如果定义的变量被使用了，那么，make 会把其展开在使用的位置。但 make 并不会完全马上展开，make 使用的是拖延战术，如果变量出现在依赖关系的规则中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。&lt;/p&gt;

&lt;p&gt;当然，这个工作方式你不一定要清楚，但是知道这个方式你也会对 make 更为熟悉。有了这个基础，后续部分也就容易看懂了。&lt;/p&gt;</content><author><name>Lewin</name></author><category term="makefile" /><summary type="html">makefile 介绍 make 命令执行时，需要一个 makefile 文件，以告诉 make 命令需要怎么样的去编译和链接程序。</summary></entry><entry><title type="html">OpenStack 社区部署工具 Devstack</title><link href="https://lewinz.org/2021/07/26/openstack-devstack/" rel="alternate" type="text/html" title="OpenStack 社区部署工具 Devstack" /><published>2021-07-26T00:00:00+08:00</published><updated>2021-07-26T00:00:00+08:00</updated><id>https://lewinz.org/2021/07/26/openstack-devstack</id><content type="html" xml:base="https://lewinz.org/2021/07/26/openstack-devstack/">&lt;h2 id=&quot;为什么需要devstack&quot;&gt;为什么需要Devstack&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OpenStack&lt;/code&gt; 是一个十分复杂的分布式系统，部署难度较大，调试也较困难。&lt;/p&gt;

&lt;p&gt;对于开发者，首先需要一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;allinone&lt;/code&gt; 的开发环境，可以随时修改代码并查看结果。各大厂商的部署工具一般都支持 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;allinone&lt;/code&gt; 的快速部署，比如红帽的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RDO&lt;/code&gt; 工具等。&lt;/p&gt;

&lt;p&gt;不过这些厂商的代码包通常是随着 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OpenStack&lt;/code&gt; 的大版本发布而更新，不能实时与社区代码同步，而对于开发者而言，往往需要的是最新的代码，精确到最新的一次 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;commit&lt;/code&gt; ，因此使用厂商提供的部署工具难以满足开发需求。&lt;/p&gt;

&lt;p&gt;幸运的是社区已经提供了现成的快速部署工具，即 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DevStack(Develop OpenStack)&lt;/code&gt; ，从英文名称上也能看出这是专为开发 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OpenStack&lt;/code&gt; 量身打造的工具。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DevStack&lt;/code&gt; 不依赖于任何自动化部署工具，纯 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bash&lt;/code&gt; 脚本实现，因此不需要花费大量时间耗在部署工具准备上，而只需要简单地编辑配置文件，然后运行脚本即可实现一键部署 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OpenStack&lt;/code&gt; 环境。利用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DevStack&lt;/code&gt; 基本可以部署所有的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OpenStack&lt;/code&gt; 组件，但并不是所有的开发者都需要部署所有的服务，比如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nova&lt;/code&gt; 开发者可能只需要部署核心组件就够了，其它服务比如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Swift&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Heat&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Sahara&lt;/code&gt; 等其实并不需要。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DevStack&lt;/code&gt; 充分考虑这种情况，一开始的设计就是可扩展的，除了核心组件，其它组件都是以插件的形式提供，开发者只需要根据自己的需求定制配置自己的插件即可。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DevStack&lt;/code&gt; 除了给开发者快速部署最新的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OpenStack&lt;/code&gt; 开发环境，社区项目的功能测试也是通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DevStack&lt;/code&gt; 完成，开发者提交的代码在合并到主分支之前，必须通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DevStack&lt;/code&gt; 的所有功能集测试。另外，前面提到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DevStack&lt;/code&gt; 是基于代码仓库的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;master&lt;/code&gt; 分支部署，如果你想尝试 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OpenStack&lt;/code&gt; 的最新功能或者新项目，也可以通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DevStack&lt;/code&gt; 工具快速部署最新代码的测试环境。&lt;/p&gt;

&lt;h2 id=&quot;三步玩转devstack&quot;&gt;三步玩转DevStack&lt;/h2&gt;
&lt;p&gt;刚刚提到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DevStack&lt;/code&gt; 的强大之处，是不是“蠢蠢欲动”想要小试牛刀？不过在开始之前，我得友情提醒下，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DevStack&lt;/code&gt; 运行后会安装大量 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OpenStack&lt;/code&gt; 依赖的软件包和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Python&lt;/code&gt; 库，如果你怕弄乱你的系统，建议开一个虚拟机（你说用容器？&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;you can，you up&lt;/code&gt;)，在虚拟机里跑 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DevStack&lt;/code&gt; 就不用担心会弄坏你的系统了。目前 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DevStack&lt;/code&gt; 支持&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ubuntu 14.04/16.04&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Fedora 23/24&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CentOS/RHEL 7&lt;/code&gt;以及 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Debian&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OpenSUSE&lt;/code&gt; 操作系统，不过官方建议使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ubuntu 16.04&lt;/code&gt;，因为该操作系统社区测试最全面，出现的问题最少。
OK，让我们开始一步步走起吧。&lt;/p&gt;

&lt;h3 id=&quot;创建stack用户&quot;&gt;创建stack用户&lt;/h3&gt;
&lt;p&gt;为了系统的安全， &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DevStack&lt;/code&gt; 最好不要在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root&lt;/code&gt; 用户下直接运行，因此需要创建一个专门的用户 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stack&lt;/code&gt; ，该用户需要有免密码 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo&lt;/code&gt; 权限，配置如下:&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;adduser stack
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;stack ALL=(ALL) NOPASSWD: ALL&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; /etc/sudoers &lt;span class=&quot;c&quot;&gt;# 建议使用visudo&lt;/span&gt;
su stack
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果已经下载了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DevStack&lt;/code&gt; 代码， &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DevStack&lt;/code&gt; 也提供了一个专门的脚本创建 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stack&lt;/code&gt; 用户，该脚本位于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;devstack/tools/create-stack-user.sh&lt;/code&gt;，直接运行该脚本即可。&lt;br /&gt;
最后请务必检查当前工作用户为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stack&lt;/code&gt; ，并且能够不输入密码执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo&lt;/code&gt; 命令。&lt;/p&gt;

&lt;h3 id=&quot;配置devstack&quot;&gt;配置DevStack&lt;/h3&gt;
&lt;p&gt;在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DevStack&lt;/code&gt; 根目录下创建 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;local.conf&lt;/code&gt; 配置文件，包含 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;admin&lt;/code&gt; 密码、数据库密码、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RabbitMQ&lt;/code&gt; 密码以及 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Service&lt;/code&gt; 密码：&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;|localrc]]
&lt;span class=&quot;nv&quot;&gt;ADMIN_PASSWORD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;secret
&lt;span class=&quot;nv&quot;&gt;DATABASE_PASSWORD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$ADMIN_PASSWORD&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;RABBIT_PASSWORD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$ADMIN_PASSWORD&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;SERVICE_PASSWORD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$ADMIN_PASSWORD&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;你也可以直接从 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sample&lt;/code&gt; 目录下拷贝一个模板文件，然后在模板文件中修改。
部署一个最简单的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OpenStack&lt;/code&gt; 环境以上配置就够了，是不是特别简单？&lt;/p&gt;

&lt;h3 id=&quot;let-devstack-fly&quot;&gt;Let DevStack Fly&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;./stack.sh&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;就这么简单？是的，一键部署，只需要一个命令！接下来你唯一需要做的，就是砌一杯咖啡静静地等待，取决于你的网络，通常需要等待半个小时。部署完后，会输出 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dashboard&lt;/code&gt; 地址以及默认创建的两个账号，一个是管理员账号 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;admin&lt;/code&gt; ，另一个是普通账号 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;demo&lt;/code&gt; ，如下：&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;This is your host IP address: 172.16.0.41
This is your host IPv6 address: ::1
Horizon is now available at http://172.16.0.41/dashboard
Keystone is serving at http://172.16.0.41:5000/
The default &lt;span class=&quot;nb&quot;&gt;users &lt;/span&gt;are: admin and demo
The password: secret
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注意以上部署的是一个精简版的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OpenStack&lt;/code&gt; 环境，默认只包含核心组件和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Horizon&lt;/code&gt; ，包括 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Keystone&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Glance&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nova&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Neutron&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cinder&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Horizon&lt;/code&gt; 等，其它服务则需要通过配置文件开启对应的插件完成，将在下面小节介绍。&lt;/p&gt;

&lt;h3 id=&quot;关于下载速度优化&quot;&gt;关于下载速度优化&lt;/h3&gt;
&lt;p&gt;由于众所周知的原因，运行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DevStack&lt;/code&gt; 时下载 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OpenStack&lt;/code&gt; 依赖包和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Python&lt;/code&gt; 库时非常慢，拉取 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OpenStack&lt;/code&gt; 源码也非常耗时。为了避免这个问题，很多人都会从以下几个方面优化下载速度，加快部署速率：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用国内的镜像源
对于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ubuntu&lt;/code&gt; 系统就是修改 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;APT&lt;/code&gt; 源，比如阿里云镜像源，只需要修改 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/apt/source.list&lt;/code&gt; 配置文件即可，替换为需要使用的镜像源。如：
    &lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;使用国内的pip源
只需要在当前家目录 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pip&lt;/code&gt; 目录创建 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pip.conf&lt;/code&gt; 配置文件，以使用阿里云为例，配置文件内容如下：
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cat ~/.pip/pip.conf&lt;/code&gt;
    &lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;global]
index-url &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; http://mirrors.aliyun.com/pypi/simple/
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
trusted-host&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;mirrors.aliyun.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;修改 OpenStack 源码地址
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DevStack&lt;/code&gt; 默认会从 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git.openstack.org&lt;/code&gt; 下拉取代码，国内访问速度很慢，建议替换为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;github&lt;/code&gt; 地址或者国内的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;trystack&lt;/code&gt; 仓库，在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[[local|localrc]]&lt;/code&gt;配置下增加以下配置项：
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GIT_BASE=http://git.trystack.cn&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果你本地已经有最新的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OpenStack&lt;/code&gt; 源码了，也可以指定你本地的源码路径，比如使用本地的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nova&lt;/code&gt; 源代码并且使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new_feature&lt;/code&gt; 分支:&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;|localrc]]
&lt;span class=&quot;nv&quot;&gt;NOVA_REPO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/home/int32bit/nova
&lt;span class=&quot;nv&quot;&gt;NOVA_BRANCH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;new_feature
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;需要注意的是，国内源存在同步滞后，可能包不兼容或者下载某些包失败问题，出现这种情况时只需要重新替换原来的镜像源，然后重新运行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;./stack.sh&lt;/code&gt; 即可。&lt;/p&gt;

&lt;h2 id=&quot;使用devstack环境开发&quot;&gt;使用DevStack环境开发&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DevStack&lt;/code&gt; 使用了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Linux&lt;/code&gt; 的终端复用工具 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;screen&lt;/code&gt; ，不同的服务运行在不同的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;window&lt;/code&gt; 中，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;screen&lt;/code&gt; 的使用方法可参考官方文档。通常情况下，我们都是针对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OpenStack&lt;/code&gt; 的某个组件进行开发，比如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nova&lt;/code&gt; ，只需要找到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nova&lt;/code&gt; 的源码路径，修改对应的源码，然后重启对应的服务即可。比如你修改了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nova&lt;/code&gt; 源码下的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nova/compute/manager.py&lt;/code&gt; 代码，则需要重启 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nova-compute&lt;/code&gt; 服务，重启步骤如下：&lt;/p&gt;

&lt;p&gt;使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;screen -ls&lt;/code&gt; 命令查找 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stack session&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# screen -ls&lt;/span&gt;
os3:~&amp;gt; screen &lt;span class=&quot;nt&quot;&gt;-list&lt;/span&gt;
There is a screen on:
   28994.stack     &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;08/10/2016 09:01:33 PM&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Detached&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
1 Socket &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; /var/run/screen/S-sdague.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;screen -r socket attach&lt;/code&gt;到前台运行，其中 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;socket&lt;/code&gt; 为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scrren&lt;/code&gt; 的名称，以上为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;28994.stack&lt;/code&gt; 。&lt;br /&gt;
使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ctrl-a n&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ctrl-a p&lt;/code&gt;遍历 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;windows&lt;/code&gt; ，直到找到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nova-compute&lt;/code&gt; 服务。&lt;br /&gt;
使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ctrl-c&lt;/code&gt;杀掉&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nova-compute&lt;/code&gt;进程。&lt;br /&gt;
使用上下方向键遍历历史命令，找到跑 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nova-compute&lt;/code&gt; 服务的命令，重新运行即可。&lt;/p&gt;

&lt;p&gt;有些服务跑在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Web&lt;/code&gt; 服务器中，比如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Keystone&lt;/code&gt; 服务，此时重启 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Keystone&lt;/code&gt; 服务只需要重启 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Apache&lt;/code&gt; 服务即可。&lt;br /&gt;
如果你需要修改 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;oslo&lt;/code&gt; 代码或者 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python-xxxclient&lt;/code&gt; 代码就相对麻烦点，因为这些代码不同于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OpenStack&lt;/code&gt; 源码，它默认不是从代码仓库中拉取，而是从已发布的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pypi&lt;/code&gt; 仓库中直接安装。你需要覆盖默认配置，手动配置代码仓库源:&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;|localrc]]
&lt;span class=&quot;nv&quot;&gt;LIBS_FROM_GIT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;oslo.policy
&lt;span class=&quot;nv&quot;&gt;OSLOPOLICY_REPO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/home/sdague/oslo.policy
&lt;span class=&quot;nv&quot;&gt;OSLOPOLICY_BRANCH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;better_exception
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;由于这些公共库需要被许多不同的项目依赖，因此社区的推荐做法是需要重新部署整个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DevStack&lt;/code&gt; 环境:&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;./unstack.sh &amp;amp;&amp;amp; ./stack.sh&lt;/code&gt;
这个过程虽然不用重复从网络上下载包，相比第一次部署节省了不少时间，但仍然还是挺耗时间的，不利于单步调试。个人更倾向于改什么就重启什么服务，比如我修改了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;oslo.db&lt;/code&gt; 代码，并且主要是解决 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nova&lt;/code&gt; 问题，那我只需要重启 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nova&lt;/code&gt; 服务即可，暂时不需要重新部署整个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DevStack&lt;/code&gt; 。而若修改了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;client&lt;/code&gt; 代码，不需要重启任何服务，直接就可以测试功能。当然这种方式没有考虑其它服务的依赖，可能引入新问题，因此在确定开发完成后，最好还是完完全全走一遍 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unstack&lt;/code&gt; 、 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stack&lt;/code&gt; 流程。&lt;/p&gt;

&lt;h2 id=&quot;使用devstack部署其它openstack服务&quot;&gt;使用DevStack部署其它OpenStack服务&lt;/h2&gt;
&lt;p&gt;前面我们使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DevStack&lt;/code&gt; 部署了一个精简版的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OpenStack&lt;/code&gt; 环境，其中只包含了几个核心组件。其它 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OpenStack&lt;/code&gt; 服务是通过插件形式安装， &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DevStack&lt;/code&gt; 支持部署的所有插件列表可参考 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DevStack Plugin Registry&lt;/code&gt; ，截至2017年2月份，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DevStack&lt;/code&gt; 共包含132个安装插件。其中包含：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;trove: 数据库服务。&lt;/li&gt;
  &lt;li&gt;sahara: 大数据服务。&lt;/li&gt;
  &lt;li&gt;ironic: 裸机服务。&lt;/li&gt;
  &lt;li&gt;magnum: 容器编排服务。&lt;/li&gt;
  &lt;li&gt;manila: 文件共享服务。&lt;/li&gt;
  &lt;li&gt;cloudkitty: 计费服务。
…&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;需要开启部署某个服务，只需要使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;enable_plugin&lt;/code&gt; 配置指定对应插件即可，该配置项语法为:&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;enable_plugin plugin_name [code repo]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;其中 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;plugin_name&lt;/code&gt; 为插件名称，可以在插件列表中找到，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;code repo&lt;/code&gt; 为代码仓库地址，不配置就使用默认的地址。&lt;br /&gt;
比如我们需要开启 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Sahara&lt;/code&gt; 服务，只需要在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;local.conf&lt;/code&gt; 增加以下配置项:&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;enable_plugin sahara https://github.com/openstack/sahara.git
enable_plugin sahara-dashboard https://github.com/openstack/sahara-dashboard.git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注意以上我们同时开启了两个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Sahara&lt;/code&gt; 相关的插件，前者是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Sahara&lt;/code&gt; 插件，而后者是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dashboard&lt;/code&gt; 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Sahara&lt;/code&gt; 插件，若不配置该插件，在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dashboard&lt;/code&gt; 中将看不到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Sahara&lt;/code&gt; 面板。&lt;br /&gt;
除了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OpenStack&lt;/code&gt; 服务外，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DevStack&lt;/code&gt; 还支持其它和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Openstack&lt;/code&gt; 相关的插件，比如默认情况下都是使用本地文件系统存储作为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OpenStack&lt;/code&gt; 存储后端，如果需要测试 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ceph&lt;/code&gt; 后端，则需要开启 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;devstack-plugin-ceph&lt;/code&gt; 插件，该插件会自动部署一个单节点 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ceph&lt;/code&gt; 集群，然后就可以配置 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Glance&lt;/code&gt; 、 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nova&lt;/code&gt; 、 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cinder&lt;/code&gt; 、 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Manila&lt;/code&gt; 等服务使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ceph&lt;/code&gt; 后端了。&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;enable_plugin devstack-plugin-ceph git://git.openstack.org/openstack/devstack-plugin-ceph
&lt;span class=&quot;nv&quot;&gt;ENABLE_CEPH_CINDER&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;True     &lt;span class=&quot;c&quot;&gt;# ceph backend for cinder&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;ENABLE_CEPH_GLANCE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;True     &lt;span class=&quot;c&quot;&gt;# store images in ceph&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;ENABLE_CEPH_C_BAK&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;True      &lt;span class=&quot;c&quot;&gt;# cinder-backup volumes to ceph&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;ENABLE_CEPH_NOVA&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;True       &lt;span class=&quot;c&quot;&gt;# allow nova to use ceph resources&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本章首先介绍了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DevStack&lt;/code&gt; 的功能，然后详细介绍了如何使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DevStack&lt;/code&gt; 快速部署一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OpenStack&lt;/code&gt; 环境，最后介绍了使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DevStack&lt;/code&gt; 部署其它 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OpenStack&lt;/code&gt; 服务。 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DevStack&lt;/code&gt; 项目是由社区维护的、专门为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OpenStack&lt;/code&gt; 开发人员准备的快速部署开发环境的脚本工具，该脚本工具具有非常灵活的扩展性，能够通过配置定制化部署 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OpenStack&lt;/code&gt; 服务。除此之外，社区项目的功能测试也是通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DevStack&lt;/code&gt; 完成的。由此可见，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DevStack&lt;/code&gt; 是社区一个非常重要的项目，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DevStack&lt;/code&gt; 出现问题不仅影响开发者开发，还将可能导致社区的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CI&lt;/code&gt; 系统奔溃。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DevStack&lt;/code&gt; 使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Shell&lt;/code&gt; 脚本实现，如果想学习 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Shell&lt;/code&gt; 编程， &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DevStack&lt;/code&gt; 源码将是一个很好的学习案例。&lt;/p&gt;</content><author><name>Lewin</name></author><category term="openstack" /><category term="devstack" /><summary type="html">为什么需要Devstack OpenStack 是一个十分复杂的分布式系统，部署难度较大，调试也较困难。</summary></entry></feed>