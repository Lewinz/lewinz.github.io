<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="https://lewinz.org/feed.xml" rel="self" type="application/atom+xml" /><link href="https://lewinz.org/" rel="alternate" type="text/html" /><updated>2021-08-01T22:03:11+08:00</updated><id>https://lewinz.org/feed.xml</id><title type="html">阿嫂</title><subtitle>阿嫂个人博客</subtitle><author><name>Lewin</name></author><entry><title type="html">Golang 基于 viper 的配置热加载或动态变更方法介绍</title><link href="https://lewinz.org/2021/08/01/golang-viper/" rel="alternate" type="text/html" title="Golang 基于 viper 的配置热加载或动态变更方法介绍" /><published>2021-08-01T00:00:00+08:00</published><updated>2021-08-01T00:00:00+08:00</updated><id>https://lewinz.org/2021/08/01/golang-viper</id><content type="html" xml:base="https://lewinz.org/2021/08/01/golang-viper/">&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;
&lt;p&gt;在写 web server 时，往往需要引入各种各样的配置信息，如依赖的其他中间件（redis、elasticsearch）等，一旦这些服务发生变更，我们需要重新启动 web server，以使配置生效。在 Golang 中，基于 viper 的动态配置就可以省去这些繁琐的步骤了。接下来用一个示例来说明如何使用 viper 的配置热加载：&lt;/p&gt;

&lt;h2 id=&quot;项目结构&quot;&gt;项目结构&lt;/h2&gt;
&lt;p&gt;整个项目的目录结构:&lt;/p&gt;
&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DynamicConfigDemo&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 项目地址&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;conf&lt;/span&gt;   &lt;span class=&quot;c&quot;&gt;// 配置文件目录&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;yaml&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;// 采用yaml格式文件，viper同样支持toml、json等格式的配置文件&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;src&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 代码文件夹&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dynamic_config&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 动态配置文件夹&lt;/span&gt;
			&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dynamic_config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 配置加载脚本&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;go&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mod&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// go package管理依赖的包文件&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;go&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// go package管理打包产生的文件&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// web server的入口，主函数&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;代码细节&quot;&gt;代码细节&lt;/h2&gt;
&lt;p&gt;各文件的主体内容：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# conf/base.yaml
service:
  redis:
    host: 127.0.0.1
    port: 6379
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;conf/base.yaml 文件定义了配置项，包含 redis 的 host 及 port 信息。&lt;/p&gt;
&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dynamic_config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dynamic_config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dynamic_config&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;github.com/fsnotify/fsnotify&quot;&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;github.com/spf13/viper&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GlobalConfig&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;viper&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Viper&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Loading configuration logics...&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;GlobalConfig&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;initConfig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dynamicConfig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;initConfig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;viper&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Viper&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;GlobalConfig&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;viper&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;New&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;GlobalConfig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SetConfigName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;base&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;GlobalConfig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AddConfigPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;conf/&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;GlobalConfig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SetConfigType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;yaml&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GlobalConfig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReadInConfig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Failed to get the configuration.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GlobalConfig&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dynamicConfig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;GlobalConfig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WatchConfig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;GlobalConfig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OnConfigChange&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fsnotify&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Detect config change: %s &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;src/dynamic_config/dynamic_config.go 定义了全局配置信息的加载及动态监控方法，init 函数为初始化执行的脚本，initConfig 为初始化当前配置，dynamicConfig 为冬天监听，通过 viper 的内部方法 WatchConfig 实现。&lt;/p&gt;
&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;DynamicConfigDemo/src/dynamic_config&quot;&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;github.com/gin-gonic/gin&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;gin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SetMode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReleaseMode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Default&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GET&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/ping&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Current redis host is: &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dynamic_config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GlobalConfig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;service.redis.host&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;JSON&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
			&lt;span class=&quot;m&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;H&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
				&lt;span class=&quot;s&quot;&gt;&quot;message&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;You are welcome!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;:9292&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;main.go 为主函数，调用 gin 包定义 web server 服务，实现了一个简单的 http server 服务器，每次请求发送时会打印配置的 redis host 信息。&lt;/p&gt;

&lt;h2 id=&quot;调用示例&quot;&gt;调用示例&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;第一次调用，打印出当前 redis host 为 127.0.0.1&lt;/li&gt;
  &lt;li&gt;随后我们将 redis host 修改为 127.0.0.2&lt;/li&gt;
  &lt;li&gt;src/dynamic_config/dynamic_config.go 文件中的如下代码 GlobalConfig.OnConfigChange(func(event fsnotify.Event) { fmt.Printf(“Detect config change: %s \n”, event.String()) }) 监控到配置文件变更时会输出变更通知，如图中红框所示；&lt;/li&gt;
  &lt;li&gt;第二次调用时，则打印出最新配置的 redis host 信息&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/golang_viper_file_reload.png&quot; alt=&quot;golang_viper_file_reload&quot; /&gt;&lt;/p&gt;</content><author><name>Lewin</name></author><category term="golang" /><category term="viper" /><category term="file" /><category term="reload" /><summary type="html">概述 在写 web server 时，往往需要引入各种各样的配置信息，如依赖的其他中间件（redis、elasticsearch）等，一旦这些服务发生变更，我们需要重新启动 web server，以使配置生效。在 Golang 中，基于 viper 的动态配置就可以省去这些繁琐的步骤了。接下来用一个示例来说明如何使用 viper 的配置热加载：</summary></entry><entry><title type="html">nova 虚拟机镜像从创建到文件系统 resize 完整流程</title><link href="https://lewinz.org/2021/08/01/openstack-nova-image-resize/" rel="alternate" type="text/html" title="nova 虚拟机镜像从创建到文件系统 resize 完整流程" /><published>2021-08-01T00:00:00+08:00</published><updated>2021-08-01T00:00:00+08:00</updated><id>https://lewinz.org/2021/08/01/openstack-nova-image-resize</id><content type="html" xml:base="https://lewinz.org/2021/08/01/openstack-nova-image-resize/">&lt;h2 id=&quot;虚拟机镜像的创建和-resize-流程&quot;&gt;虚拟机镜像的创建和 resize 流程&lt;/h2&gt;
&lt;p&gt;nova 创建虚拟机涉及的组件比较多，调用比较复杂，这里只列出跟虚拟机镜像创建相关的流程，方便理清虚拟机状态变化的整个流程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;nova-api&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;api&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;openstack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;servers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ServersController&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 接受创建请求，解析出image_uuid
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;api&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;API&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;api&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;API&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_create_instance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 调用glance api获取image对象
&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;conductor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;api&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LocalComputeTaskAPI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;build_instances&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;conductor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;manager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConductorManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;build_instances&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 此处虽然接收block_device_mapping参数，但是是为了兼容旧版，没有使用。实际通过nova.objects.BlockDeviceMappingList.get_by_instance_uuid()获取
&lt;/span&gt;          &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rpcapi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ComputeAPI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;build_and_run_instance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 使用cast方法调用nova-compute的build_and_run_instance方法。
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;nova-compute&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;manager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ComputeManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;build_and_run_instance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;manager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ComputeManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_do_build_and_run_instance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;manager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ComputeManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_build_and_run_instance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

      &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;manager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ComputeManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_build_resources&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;manager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ComputeManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_prep_block_device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;virt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block_device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;attach_block_devices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;virt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block_device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DriverImageBlockDevice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;attach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;volume&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cinder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;API&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

      &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;virt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libvirt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;driver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LibvirtDriver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spwan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;virt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libvirt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;driver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LibvirtDriver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_create_image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 此处会判断如果不是从volume启动，则调用imagebackend去创建虚拟机镜像
&lt;/span&gt;          &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;virt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libvirt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;driver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LibvirtDriver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_try_fetch_image_cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;virt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libvirt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;imagebackend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

              &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;virt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libvirt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;imagebackend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Rbd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;create_image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;virt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libvirt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;imagebackend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Rbd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;clone&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
                  &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;virt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libvirt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;storage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rbd_utils&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RBDDriver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;clone&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 创建虚拟机镜像，此处如果所使用的image后端不支持clone，或者镜像不可clone（比如rbd中不是raw格式的镜像），会触发异常，create_image调用下面的fetch_image函数
&lt;/span&gt;                
                &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;virt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libvirt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;utils&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fetch_image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
                  &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;virt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;images&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fetch_to_raw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;virt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;images&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
                      &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;API&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;download&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;virt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;images&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;convert_image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
                      &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;virt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;images&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_convert_image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 将镜像拷贝到本地的/var/lib/instances/_base/目录下，文件名为md5(image).part，然后用qemu-img convert转换为raw格式，名为md5(image).converted，最后重命名为md5(image)
&lt;/span&gt;                &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;virt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libvirt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;storage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rbd_utils&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RBDDriver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;import_image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 这一步是在clone失败，执行fetch_image的情况下，判断虚拟机镜像不存在，执行import_image将fetch的镜像导入到RBD后端作为虚拟机镜像。
&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;virt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libvirt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;storage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rbd_utils&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RBDDriver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 调整虚拟机镜像大小
&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;virt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libvirt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;imagebackend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Rbd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resize_image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 调整虚拟机镜像大小，RBD后端实际上在create_image时已经resize了，不会执行这一步，这里应该是为了确保其他后端能够正确设置虚拟机镜像的大小
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;为了便于分析，用 graphviz 画了在 nova-compute 的调用关系图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/openstack_nova_image_resize.png&quot; alt=&quot;openstack_nova_image_resize&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注：存储后端用的是 Ceph，所以调用的后端代码是 nova.virt.libvirt.imagebackend.Rbd，如果 nova 使用了不同的后端，比如本地的 qcow2 镜像、raw 镜像、lvm 等，只需要对照 nova.virt.libvirt.imagebackend 中提供的对应实现，出入不会太大，因为它们都继承 nova.virt.libvirt.imagebackend.Image，有相同的接口。&lt;/p&gt;

&lt;p&gt;至此，虚拟机的镜像已经创建完毕，并且 resize 为 flavor 所设置的大小。后面是虚拟机启动后，resize 分区和文件系统的过程。&lt;/p&gt;

&lt;p&gt;一般虚拟机镜像中会安装 cloud-init 或者配置启动脚本来对虚拟机做初始化配置。在 cloud-init 或启动脚本中调用 growpart 和 resizefs 来完成分区和文件系统的扩容。&lt;/p&gt;

&lt;h2 id=&quot;分区的-resize&quot;&gt;分区的 resize&lt;/h2&gt;
&lt;p&gt;cloud-init 支持使用 growpart 和 gpart 对分区进行扩容，时配置的 mode 而定，默认会按顺序检测系统中是否安装了这两个工具，使用第一个找到的。&lt;/p&gt;

&lt;p&gt;growpart 是 AWS 的扩展分区工具，它分别使用 sfdisk 和 sgdisk 对 MBR 和 GPT 分区表操作，先将分区表导出，然后改写分区的其实扇区位置，最后将改写后的分区表导入，完成分区的扩容。&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# growpart [diskdev] [partnum]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;gpart 是 FreeBSD 推出的磁盘管理工具，GPT 分区表将 metadata 的主本保存在硬盘的开始，将副本保存在硬盘的末尾，所以当虚拟机镜像被扩容，相当于硬盘的容量变大，在 GPT 看来末尾的 metadata 副本丢失了，需要先执行 recover 命令恢复，然后再进行扩容。&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# gpart recover [diskdev]&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# gpart resize -i [partnum] [diskdev]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;文件系统的-resize&quot;&gt;文件系统的 resize&lt;/h2&gt;
&lt;p&gt;cloud-init 通过依次尝试解析 /proc/$$/mountinfo、/etc/mtab 和 mount 命令的输出，来获取根目录所挂载的分区和文件系统格式。&lt;/p&gt;

&lt;p&gt;针对不通的文件系统，使用不同的命令扩容：&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# resize2fs [devpth]    # ext文件系统&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# xfs_growfs [devpth]    # xfs文件系统&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# growfs [devpth]        # ufs文件系统&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# btrfs filesystem resize max [mount_point]    # btrfs文件系统&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Lewin</name></author><category term="openstack" /><category term="nova" /><category term="image" /><category term="resize" /><summary type="html">虚拟机镜像的创建和 resize 流程 nova 创建虚拟机涉及的组件比较多，调用比较复杂，这里只列出跟虚拟机镜像创建相关的流程，方便理清虚拟机状态变化的整个流程。</summary></entry><entry><title type="html">SLB 压力测试</title><link href="https://lewinz.org/2021/08/01/slb-pressure-test/" rel="alternate" type="text/html" title="SLB 压力测试" /><published>2021-08-01T00:00:00+08:00</published><updated>2021-08-01T00:00:00+08:00</updated><id>https://lewinz.org/2021/08/01/slb-pressure-test</id><content type="html" xml:base="https://lewinz.org/2021/08/01/slb-pressure-test/">&lt;h2 id=&quot;如何进行压力测试-concept_lqx_1fd_xdb-concept&quot;&gt;如何进行压力测试 {#concept_lqx_1fd_xdb .concept}&lt;/h2&gt;
&lt;h3 id=&quot;压力测试性能概述-section_rnj_cfd_xdb-section&quot;&gt;压力测试性能概述 {#section_rnj_cfd_xdb .section}&lt;/h3&gt;
&lt;p&gt;四层负载均衡采用开源软件LVS（Linux Virtual Server）+ Keepalived的方式实现负载均衡，七层负载均衡由Tengine实现。其中四层监听经过LVS后直接到达后端服务器，而七层监听经过LVS后，还需要再经过Tengine，最后达到后端服务器。七层比四层多了一个处理环节，因此，七层性能没有四层性能好。&lt;/p&gt;

&lt;p&gt;如果您使用七层监听进行压来测试，发现根本跑不上去，挂了两台ECS的七层负载均衡监听性能还不如一台ECS的性能，除了七层本身的性能比四层低外，以下情况也可能会造成七层测压性能低：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;客户端端口不足&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;尤其容易发生在压测的时候，客户端端口不足会导致建立连接失败，负载均衡默认会抹除TCP连接的timestamp属性，Linux协议栈的tw_reuse(time_wait 状态连接复用)无法生效，time_wait状态连接堆积导致客户端端口不足。&lt;/p&gt;

&lt;p&gt;解决方法：客户端端使用长连接代替短连接。使用RST报文断开连接（socket设置SO_LINGER属性），而不是发FIN包这种方式断开。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;后端服务器accept队列满&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;后端服务器accept队列满，导致后端服务器不回复syn_ack报文，客户端超时&lt;/p&gt;

&lt;p&gt;解决方法：默认的net.core.somaxconn的值为128，执行sysctl -w net.core.somaxconn=1024更改它的值，并重启后端服务器上的应用。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;后端服务器连接过多&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由于架构设计的原因，使用七层负载均衡时，用户长连接经过Tengine后变成短连接，可能造成后端服务器连接过多，从而表现为压测性能上不去。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;后端服务器依赖的应用成为瓶颈&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;请求经过负载均衡达到后端服务器后，后端服务器本身负载都正常，但由于所有的后端服务器上的应用又依赖其它应用，比如数据库，数据库成为瓶颈，也会引起性能低。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;后端服务器的健康检查状态异常&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;尤其在压测的时候容易忽略后端服务器的健康检查状态，如果有后端服务器健康检查失败或者健康检查状态经常跳跃（好到坏，又从坏到好，反复变化）也会导致性能跑不上去。&lt;/p&gt;

&lt;h3 id=&quot;压力测试建议-section_unj_cfd_xdb-section&quot;&gt;压力测试建议 {#section_unj_cfd_xdb .section}&lt;/h3&gt;
&lt;p&gt;在进行压力测试，注意如下配置：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;压测负载均衡转发能力建议使用短链接&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一般来说压测除了验证会话保持，均衡性等功能外，主要想验证的是负载均衡的转发能力，因此使用短链接比较合适，用于测试负载均衡和后端服务器处理能力。但使用短连接测试时注意上述的客户端端口不足问题。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;压测负载均衡吞吐量建议使用长连接，用于测试带宽上限或特殊业务&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;压测工具的超时时间建议设置为一个较小值（5秒）。超时时间太大的话，测试结果会体现在平均RT加长，不利于判断压测水位是否已到达。超时时间调小，测试结果会体现在成功率上，便于快速判断压测水位。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;后端服务器提供一个静态网页用于压测，以避免应用逻辑带来的损耗&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;压测时，监听配置建议如下：&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;不开启会话保持功能，否则压力会集中在个别的后端服务器。&lt;/li&gt;
      &lt;li&gt;监听关闭健康检查功能，减少健康检查请求对后端服务器的访问请求。&lt;/li&gt;
      &lt;li&gt;用多个客户端进行进行压测最好多于5个，源IP分散，能够更好的模拟线上实际情况。
        &lt;h3 id=&quot;压力测试工具建议-section_xnj_cfd_xdb-section&quot;&gt;压力测试工具建议 {#section_xnj_cfd_xdb .section}&lt;/h3&gt;
        &lt;p&gt;不建议您使用Apache ab作为压力测试工具。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Apache ab在大量并发场景下存在3s，6s，9s阶梯式停顿的现象。Apache ab会通过判断content length来确定请求是否成功，而负载均衡挂载多台后端服务器时，返回的content length会不一致，导致测试结果有误。&lt;/p&gt;

&lt;p&gt;可以选择多个客户端作为压力测试源，测试结果清晰，并且可以通过配置监控，获取压力测试时后端服务器的性能数据。&lt;/p&gt;

&lt;h3 id=&quot;使用pts简单压测示例-section_ynj_cfd_xdb-section&quot;&gt;使用PTS简单压测示例 {#section_ynj_cfd_xdb .section}&lt;/h3&gt;
&lt;p&gt;创建一个负载均实例，添加两台ECS实例作为后端服务器，分别创建一个TCP监听和HTTP监听，后端端口设置为80。ECS服务器的配置为CPU 1核，内存512M使用CentOS 6.3 64位的操作系统。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;安装Apache Web Server提供Web服务。&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yum install -y httpd&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;初始化默认首页index.html。&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;echo &quot;testvm&quot; &amp;gt; /var/www/html/index.html&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;启动HTTP服务。&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;service httpd start&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;访问本地的80端口，确认Web服务可用。&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;curl localhost&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在PTS中创建测试脚本，开始压力测试。&lt;br /&gt;
注意关闭长连接和设置超时时间：&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;设置超时时间为5秒： PTS.HttpUtilities.setTimeout(5000)&lt;/li&gt;
      &lt;li&gt;关闭长连接： PTS.HttpUtilities.setKeepAlive(False)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>Lewin</name></author><category term="slb" /><category term="pressure" /><category term="test" /><summary type="html">如何进行压力测试 {#concept_lqx_1fd_xdb .concept} 压力测试性能概述 {#section_rnj_cfd_xdb .section} 四层负载均衡采用开源软件LVS（Linux Virtual Server）+ Keepalived的方式实现负载均衡，七层负载均衡由Tengine实现。其中四层监听经过LVS后直接到达后端服务器，而七层监听经过LVS后，还需要再经过Tengine，最后达到后端服务器。七层比四层多了一个处理环节，因此，七层性能没有四层性能好。</summary></entry><entry><title type="html">ssl 证书生成</title><link href="https://lewinz.org/2021/08/01/ssl-cert/" rel="alternate" type="text/html" title="ssl 证书生成" /><published>2021-08-01T00:00:00+08:00</published><updated>2021-08-01T00:00:00+08:00</updated><id>https://lewinz.org/2021/08/01/ssl-cert</id><content type="html" xml:base="https://lewinz.org/2021/08/01/ssl-cert/">&lt;h2 id=&quot;用-openssl-生成-nginxkey&quot;&gt;用 openssl 生成 nginx.key&lt;/h2&gt;

&lt;p&gt;1.key 的生成
openssl genrsa -des3 -out server.key 2048
这样是生成 rsa 私钥，des3 算法，openssl 格式，2048 位强度。server.key 是密钥文件名。为了生成这样的密钥，需要一个至少四位的密码。
可以通过以下方法生成没有密码的 key:
openssl rsa -in server.key -out server.key
server.key 就是没有密码的版本了。&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;生成 CA 的 crt
openssl req -new -x509 -key server.key -out ca.crt -days 3650
生成的 ca.crt 文件是用来签署下面的 server.csr 文件。&lt;/li&gt;
  &lt;li&gt;csr 的生成方法
openssl req -new -key server.key -out server.csr
需要依次输入国家，地区，组织，email。最重要的是有一个 common name，可以写你的名字或者域名。如果为了 https 申请，这个必须和域名吻合，否则会引发浏览器警报。生成的 csr 文件交给 CA 签名后形成服务端自己的证书。&lt;/li&gt;
  &lt;li&gt;crt 生成方法
CSR 文件必须有 CA 的签名才可形成证书，可将此文件发送到 verisign 等地方由它验证，要交一大笔钱，何不自己做 CA 呢。
openssl x509 -req -days 3650 -in server.csr -CA ca.crt -CAkey server.key -CAcreateserial -out server.crt
输入 key 的密钥后，完成证书生成。-CA 选项指明用于被签名的 csr 证书，-CAkey 选项指明用于签名的密钥，-CAserial 指明序列号文件，而 - CAcreateserial 指明文件不存在时自动生成。
最后生成了私用密钥：server.key 和自己认证的 SSL 证书：server.crt
证书合并：
cat server.key server.crt &amp;gt; server.pem
     其中第一步生成的无密码 key 就是我们想要的 nginx.key
使用 StartSSL 免费 SSL 证书：
     登录网站：https://www.startssl.com
     找到 StartSSL Free，点击 Start Now
     这里提示需要登录，通过邮箱进行注册并登录
     然后在 Validations Wizard 这里选择要进行网站认证还是邮箱认证
     按照网站提示一步一步进行
提交 nginx.key 生成 nginx.crt 证书：
     在 StartSSL 审核通过后，会提示输入本地 key
     我们的需求是要配置 nginx 的 SSL 验证，将前面用 openssl 生成 nginx.key 添加到网站指定的输入框中，提交审核，等待网站审核通过
     网站审核通过后，会提示可以在 Tool Box 中下载以生成的证书
     下载后，得到一个以认证域名命名的压缩包
     解压缩后，包内有 ApacheServer.zip, IISServer.zip, NginxServer.zip, OtherServer.zip
     我们需要的文件在 NginxServer.zip 中，解压后得到 1_gjtest.parteam.cn_bundle.crt 文件
得到 crt 证书后，服务器上的设置：
     在服务器 /etc/nginx/ssl/ 文件夹下创建 gjtest.parteam.cn.crt 文件，用命令行 cat 命令查看        1_gjtest.parteam.cn_bundle.crt 文件，并将内容拷贝到 gjtest.parteam.cn.crt 中。
     在服务器 /etc/nginx/ssl/ 文件夹下创建 gjtest.parteam.cn.key 文件，将开始生成的 nginx.key 内容拷贝进去。
在 nginx 配置文件 /etc/nginx/conf.d/**.conf 的 443 端口监听 server 中，设置 SSL 安全监测：
ssl_certificate      ssl/gjtest_parteam_cn.crt;
ssl_certificate_key  ssl/gjtest_parteam_cn.key;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;ssl_ciphers          ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128    -GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES    256-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:    AES128-GCM-SHA256:AES256-GCM-SHA384:DES-CBC3-SHA;&lt;/p&gt;

&lt;p&gt;ssl_prefer_server_ciphers  on;&lt;/p&gt;

&lt;p&gt;ssl_protocols        TLSv1 TLSv1.1 TLSv1.2;
重新启动 nginx 服务，使得新的修改生效。
可能会出现以下错误信息：
error：nginx[15608]: nginx: [emerg] SSL_CTX_use_PrivateKey_file(“/etc/nginx/ssl/gjtest_parteam_cn.ke
       PS：检查 ssl 文件夹中的 key 和 crt 文件是否对照成对&lt;/p&gt;

&lt;p&gt;● nginx.service - A high performance web server and a reverse proxy server
Loaded: loaded (/lib/systemd/system/nginx.service; enabled; vendor preset: enabled)
Active: failed (Result: exit-code) since Thu 2016-11-10 15:13:17 CST; 5s ago
Process: 15430 ExecStop=/sbin/start-stop-daemon –quiet –stop –retry QUIT/5 –pidfile /run/nginx.pid (code=exited, status=0/SUCCE
Process: 929 ExecStart=/usr/sbin/nginx -g daemon on; master_process on; (code=exited, status=0/SUCCESS)
Process: 15532 ExecStartPre=/usr/sbin/nginx -t -q -g daemon on; master_process on; (code=exited, status=1/FAILURE)
Main PID: 951 (code=exited, status=0/SUCCESS)
Nov 10 15:13:17 iZ2zeipvbenilb2wia99kqZ systemd[1]: Stopped A high performance web server and a reverse proxy server.
Nov 10 15:13:17 iZ2zeipvbenilb2wia99kqZ systemd[1]: Starting A high performance web server and a reverse proxy server…
Nov 10 15:13:17 iZ2zeipvbenilb2wia99kqZ nginx[15532]: Enter PEM pass phrase:
Nov 10 15:13:17 iZ2zeipvbenilb2wia99kqZ nginx[15532]: nginx: [emerg] SSL_CTX_use_PrivateKey_file(“/etc/nginx/ssl/gjtest_parteam_cn.ke
Nov 10 15:13:17 iZ2zeipvbenilb2wia99kqZ nginx[15532]: nginx: configuration file /etc/nginx/nginx.conf test failed
Nov 10 15:13:17 iZ2zeipvbenilb2wia99kqZ systemd[1]: nginx.service: Control process exited, code=exited status=1
Nov 10 15:13:17 iZ2zeipvbenilb2wia99kqZ systemd[1]: Failed to start A high performance web server and a reverse proxy server.
Nov 10 15:13:17 iZ2zeipvbenilb2wia99kqZ systemd[1]: nginx.service: Unit entered failed state.
Nov 10 15:13:17 iZ2zeipvbenilb2wia99kqZ systemd[1]: nginx.service: Failed with result ‘exit-code’.
root@iZ2zeipvbenilb2wia99kqZ:/etc/nginx/ssl# service nginx restart
Job for nginx.service failed because the control process exited with error code. See “systemctl status nginx.service” and “journalctl -xe” for details.
PS：出现这样的错误时，
       1、openssl rsa -in server.key -out unserver.key
      输入一次私钥的密码：&lt;strong&gt;**&lt;/strong&gt;
      把 unserver.key 文件修改为 server.key
      重启 nginx 问题解决。
      2、openssl req -new -x509 -nodes -out server.crt -keyout server.key，重新生成 key（此处的 server 就是 nginx）&lt;/p&gt;

&lt;p&gt;阿里云开发文档
https://help.aliyun.com/document_detail/85969.html?spm=a2c4g.11186623.6.764.216b5cf9U3AU6K&lt;/p&gt;</content><author><name>Lewin</name></author><category term="ssl" /><category term="cert" /><category term="create" /><summary type="html">用 openssl 生成 nginx.key</summary></entry><entry><title type="html">Github 装逼指南 Travis CI 和 Codecov</title><link href="https://lewinz.org/2021/07/29/travis-ci-codecov/" rel="alternate" type="text/html" title="Github 装逼指南 Travis CI 和 Codecov" /><published>2021-07-29T00:00:00+08:00</published><updated>2021-07-29T00:00:00+08:00</updated><id>https://lewinz.org/2021/07/29/travis-ci-codecov</id><content type="html" xml:base="https://lewinz.org/2021/07/29/travis-ci-codecov/">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/travis_ci_codecov_1.png&quot; alt=&quot;travis_ci_codecov_1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;觉得挺酷的。打算在自己的开源组件中也整一套。
经过 Google 决定使用 TravisCI 来进行持续集成，Codecov 来统计单测覆盖率。&lt;/p&gt;

&lt;h2 id=&quot;travis-ci&quot;&gt;Travis CI&lt;/h2&gt;
&lt;p&gt;Travis CI 是国外的开源持续集成构建项目，支持 Github 项目。使用十分方便。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用 Github 账号登录 Travis CI；&lt;/li&gt;
  &lt;li&gt;登录之后会自动同步 Github 项目，选择需要使用 Travis CI 的项目&lt;/li&gt;
  &lt;li&gt;在项目的根目录新增.travis.yml 文件，内容如下：
``` sh
#指定运行环境
language: node_js
#指定nodejs版本，可以指定多个
node_js:
    &lt;ul&gt;
      &lt;li&gt;0.12.5&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;#运行的脚本命令
script:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;npm run ci&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;#指定分支，只有指定的分支提交时才会运行脚本
branches:
  only:
    - master&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
更多语法请看[这里](https://link.segmentfault.com/?url=https%3A%2F%2Fdocs.travis-ci.com%2F)。使用起来非常方便，这样当你每次向 github push 代码的时候，Travis CI 就会自动运行.travis.yml 里面的 script。自动进行编译以及运行单测。

由于 Travis CI 每次 build 之前都会运行 npm install 安装项目依赖的 npm 包，所以在提交代码的时候要保证把所有依赖的包都已经在 package.json 中声明了，否则 build 就会失败。

## Codecov
Codecov 是一个开源的测试结果展示平台，将测试结果可视化。Github 上许多开源项目都使用了 Codecov 来展示单测结果。

Codecov 跟 Travis CI 一样都支持 Github 账号登录，同样会同步 Github 中的项目。在 nodejs 环境下使用 Codecov 需要安装对于的 npm 包，运行下面这个命令进行安装：

`npm install codecov --save-dev`

这个包的作用是将我们运行单测产生的结果文件上传到 Codecov 上进行可视化展示。同时 codecov 支持的结果文件类型为 cobertura。所以需要保证单测执行的结果文件的类型为 cobertura。
前端项目进行单元测试推进 karma + 'jasmine' 的组合。这两个具体是什么东西大家 Google 一下就知道。使用 karma 可以通过简单的配置来运行单测。下面是我一个项目中的配置文件，供大家参考：
``` js
// Karma configuration
// Generated on Mon Feb 01 2016 21:34:22 GMT+0800 (中国标准时间)

module.exports = function(config) {
  config.set({

    // base path that will be used to resolve all patterns (eg. files, exclude)
    basePath: '',


    // frameworks to use
    // available frameworks: https://npmjs.org/browse/keyword/karma-adapter
    // 使用的测试框架jasmine, requirejs支持模块化加载
    frameworks: ['jasmine', 'requirejs'],


    // list of files / patterns to load in the browser
    files: [
        // karma中用到进行requirejs配置的文件
        'test/test-main.js',
        // 测试中需要用到的文件，includeed设为false表示在页面加载的时候不会加载相应的js文件，也就是可以通过requirejs进行异步加载
        {pattern: 'node_modules/jquery/dist/jquery.min.js', included: false},
        {pattern: 'node_modules/angular/angular.min.js', included: false},
        {pattern: 'node_modules/angular-mocks/angular-mocks.js', included: false},
        {pattern: 'src/bg-single-selector.js', included: false},
        {pattern: 'test/selector.spec.js', included: false}
    ],


    // list of files to exclude
    exclude: [
    ],


    // preprocess matching files before serving them to the browser
    // available preprocessors: https://npmjs.org/browse/keyword/karma-preprocessor
    // 针对bg-single-selector.js生成单测覆盖率结果
    preprocessors: {
        'src/bg-single-selector.js': 'coverage'
    },


    // test results reporter to use
    // possible values: 'dots', 'progress'
    // available reporters: https://npmjs.org/browse/keyword/karma-reporter
    // 测试结果的几种输出方式
    reporters: ['progress', 'coverage', 'verbose'],
    // 测试结果报告的类型
    coverageReporter:{
        reporters: [{
            type:'text-summary'
        }, {
            type: 'html',
            dir: 'test/coverage'
        }, {
            // 这就是Codecov支持的文件类型
            type: 'cobertura',
            subdir: '.',
            dir: 'test/coverage'
        }]
    },

    // web server port
    port: 9876,


    // enable / disable colors in the output (reporters and logs)
    colors: true,


    // level of logging
    // possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG
    logLevel: config.LOG_INFO,


    // enable / disable watching file and executing tests whenever any file changes
    autoWatch: true,

    // start these browsers
    // available browser launchers: https://npmjs.org/browse/keyword/karma-launcher
    browsers: ['PhantomJS'],
    // 运行测试依赖的插件
    plugins: [
        'karma-jasmine',
        'karma-coverage',
        'karma-verbose-reporter',
        'karma-phantomjs-launcher',
        'karma-requirejs'
    ],

    // Continuous Integration mode
    // if true, Karma captures browsers, runs the tests and exits
    singleRun: true
  })
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;通过 karma 进行单元测试，将命令写到.travis.yml 中就可以在每次 build 的时候运行单测，同时运行 codecov [cobertura-coverage.xml路径] 就会把单测结果上传到 Codecov。在本地运行 codecov 会失败，需要将这个过程加入到 Travis CI 的 build 脚本中，才能成功上传。因为在本地运行就会被作为私有项目，对于私有项目在上传结果时需要加上 Codecov 提供的 token。&lt;/p&gt;

&lt;h2 id=&quot;在-github-中加入图标&quot;&gt;在 github 中加入图标&lt;/h2&gt;
&lt;p&gt;到了最后一步，Travis CI 和 Codecov 都提供图标链接来展示结果。我们只需要将图标链接加入到项目的 README 中就可以看到结果了。&lt;br /&gt;
对于 Travis CI 来说，点击下图中的图标：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/travis_ci_codecov_2.png&quot; alt=&quot;travis_ci_codecov_2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;就会弹出图标的地址。&lt;br /&gt;
对于 Codecov 来说，打开项目的设置列表就会看到，如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/travis_ci_codecov_3.png&quot; alt=&quot;travis_ci_codecov_3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后只需要将对应的链接加到 README 文件中就可以了。下面是最后的效果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/travis_ci_codecov_4.png&quot; alt=&quot;travis_ci_codecov_4&quot; /&gt;&lt;/p&gt;</content><author><name>Lewin</name></author><category term="github" /><category term="travis" /><category term="codecov" /><summary type="html"></summary></entry><entry><title type="html">http 网络状态码大全</title><link href="https://lewinz.org/2021/07/28/http-status-code/" rel="alternate" type="text/html" title="http 网络状态码大全" /><published>2021-07-28T00:00:00+08:00</published><updated>2021-07-28T00:00:00+08:00</updated><id>https://lewinz.org/2021/07/28/http-status-code</id><content type="html" xml:base="https://lewinz.org/2021/07/28/http-status-code/">&lt;h2 id=&quot;1xx临时响应&quot;&gt;1xx（临时响应）&lt;/h2&gt;
&lt;p&gt;表示临时响应并需要请求者继续执行操作的状态代码。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;代码&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
      &lt;th&gt;详细&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;100&lt;/td&gt;
      &lt;td&gt;继续&lt;/td&gt;
      &lt;td&gt;请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;101&lt;/td&gt;
      &lt;td&gt;切换协议&lt;/td&gt;
      &lt;td&gt;请求者已要求服务器切换协议，服务器已确认并准备切换&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;2xx-成功&quot;&gt;2xx （成功）&lt;/h2&gt;
&lt;p&gt;表示成功处理了请求的状态代码。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;代码&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
      &lt;th&gt;详细&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;200&lt;/td&gt;
      &lt;td&gt;成功&lt;/td&gt;
      &lt;td&gt;服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;201&lt;/td&gt;
      &lt;td&gt;已创建&lt;/td&gt;
      &lt;td&gt;请求成功并且服务器创建了新的资源&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;202&lt;/td&gt;
      &lt;td&gt;已接受&lt;/td&gt;
      &lt;td&gt;服务器已接受请求，但尚未处理&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;203&lt;/td&gt;
      &lt;td&gt;非授权信息&lt;/td&gt;
      &lt;td&gt;服务器已成功处理了请求，但返回的信息可能来自另一来源&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;204&lt;/td&gt;
      &lt;td&gt;无内容&lt;/td&gt;
      &lt;td&gt;服务器成功处理了请求，但没有返回任何内容&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;205&lt;/td&gt;
      &lt;td&gt;重置内容&lt;/td&gt;
      &lt;td&gt;服务器成功处理了请求，但没有返回任何内容&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;206&lt;/td&gt;
      &lt;td&gt;部分内容&lt;/td&gt;
      &lt;td&gt;服务器成功处理了部分 GET 请求&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;3xx-重定向&quot;&gt;3xx （重定向）&lt;/h2&gt;
&lt;p&gt;表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;代码&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
      &lt;th&gt;详细&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;300&lt;/td&gt;
      &lt;td&gt;多种选择&lt;/td&gt;
      &lt;td&gt;针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;301&lt;/td&gt;
      &lt;td&gt;永久移动&lt;/td&gt;
      &lt;td&gt;请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;302&lt;/td&gt;
      &lt;td&gt;临时移动&lt;/td&gt;
      &lt;td&gt;服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;303&lt;/td&gt;
      &lt;td&gt;查看其他位置&lt;/td&gt;
      &lt;td&gt;请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;304&lt;/td&gt;
      &lt;td&gt;未修改&lt;/td&gt;
      &lt;td&gt;自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;305&lt;/td&gt;
      &lt;td&gt;使用代理&lt;/td&gt;
      &lt;td&gt;请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;307&lt;/td&gt;
      &lt;td&gt;临时重定向&lt;/td&gt;
      &lt;td&gt;服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;4xx请求错误&quot;&gt;4xx（请求错误）&lt;/h2&gt;
&lt;p&gt;这些状态代码表示请求可能出错，妨碍了服务器的处理。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;代码&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
      &lt;th&gt;详细&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;400&lt;/td&gt;
      &lt;td&gt;错误请求&lt;/td&gt;
      &lt;td&gt;服务器不理解请求的语法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;401&lt;/td&gt;
      &lt;td&gt;未授权&lt;/td&gt;
      &lt;td&gt;请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;403&lt;/td&gt;
      &lt;td&gt;禁止&lt;/td&gt;
      &lt;td&gt;对资源的访问权限不足&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;404&lt;/td&gt;
      &lt;td&gt;未找到&lt;/td&gt;
      &lt;td&gt;服务器找不到请求的网页&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;405&lt;/td&gt;
      &lt;td&gt;方法禁用&lt;/td&gt;
      &lt;td&gt;禁用请求中指定的方法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;406&lt;/td&gt;
      &lt;td&gt;不接受&lt;/td&gt;
      &lt;td&gt;无法使用请求的内容特性响应请求的网页&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;407&lt;/td&gt;
      &lt;td&gt;需要代理授权&lt;/td&gt;
      &lt;td&gt;此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;408&lt;/td&gt;
      &lt;td&gt;请求超时&lt;/td&gt;
      &lt;td&gt;服务器等候请求时发生超时&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;409&lt;/td&gt;
      &lt;td&gt;冲突&lt;/td&gt;
      &lt;td&gt;服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;410&lt;/td&gt;
      &lt;td&gt;已删除&lt;/td&gt;
      &lt;td&gt;如果请求的资源已永久删除，服务器就会返回此响应&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;411&lt;/td&gt;
      &lt;td&gt;需要有效长度&lt;/td&gt;
      &lt;td&gt;服务器不接受不含有效内容长度标头字段的请求&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;412&lt;/td&gt;
      &lt;td&gt;未满足前提条件&lt;/td&gt;
      &lt;td&gt;服务器未满足请求者在请求中设置的其中一个前提条件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;413&lt;/td&gt;
      &lt;td&gt;请求实体过大&lt;/td&gt;
      &lt;td&gt;服务器无法处理请求，因为请求实体过大，超出服务器的处理能力&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;414&lt;/td&gt;
      &lt;td&gt;请求的 URI 过长&lt;/td&gt;
      &lt;td&gt;请求的 URI（通常为网址）过长，服务器无法处理&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;415&lt;/td&gt;
      &lt;td&gt;不支持的媒体类型&lt;/td&gt;
      &lt;td&gt;请求的格式不受请求页面的支持&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;416&lt;/td&gt;
      &lt;td&gt;请求范围不符合要求&lt;/td&gt;
      &lt;td&gt;如果页面无法提供请求的范围，则服务器会返回此状态代码&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;417&lt;/td&gt;
      &lt;td&gt;未满足期望值&lt;/td&gt;
      &lt;td&gt;服务器未满足” 期望” 请求标头字段的要求&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;5xx服务器错误&quot;&gt;5xx（服务器错误）&lt;/h2&gt;
&lt;p&gt;这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;代码&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
      &lt;th&gt;详细&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;500&lt;/td&gt;
      &lt;td&gt;服务器内部错误&lt;/td&gt;
      &lt;td&gt;服务器遇到错误，无法完成请求。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;501&lt;/td&gt;
      &lt;td&gt;尚未实施&lt;/td&gt;
      &lt;td&gt;服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;502&lt;/td&gt;
      &lt;td&gt;错误网关&lt;/td&gt;
      &lt;td&gt;服务器作为网关或代理，从上游服务器收到无效响应。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;503&lt;/td&gt;
      &lt;td&gt;服务不可用&lt;/td&gt;
      &lt;td&gt;服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;504&lt;/td&gt;
      &lt;td&gt;网关超时&lt;/td&gt;
      &lt;td&gt;服务器作为网关或代理，但是没有及时从上游服务器收到请求。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;505&lt;/td&gt;
      &lt;td&gt;HTTP 版本不受支持&lt;/td&gt;
      &lt;td&gt;服务器不支持请求中所用的 HTTP 协议版本。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;扩展&quot;&gt;扩展&lt;/h2&gt;
&lt;p&gt;RFC 6585 最近刚刚发布，该文档描述了 4 个新的 HTTP 状态码。&lt;/p&gt;

&lt;p&gt;HTTP 协议还在变化？是的，HTTP 协议一直在演变，新的状态码对于开发 REST 服务或者说是基于 HTTP 的服务非常有用，下面我们为你详细介绍这四个新的状态码以及是否应该使用。&lt;/p&gt;

&lt;h3 id=&quot;428-precondition-required-要求先决条件&quot;&gt;428 Precondition Required (要求先决条件)&lt;/h3&gt;
&lt;p&gt;先决条件是客户端发送 HTTP 请求时，如果想要请求能成功必须满足一些预设的条件。&lt;/p&gt;

&lt;p&gt;一个好的例子就是 If-None-Match 头，经常在 GET 请求中使用，如果指定了 If-None-Match ，那么客户端只在响应中的 ETag 改变后才会重新接收回应。&lt;/p&gt;

&lt;p&gt;先决条件的另外一个例子就是 If-Match 头，这个一般用在 PUT 请求上用于指示只更新没被改变的资源，这在多个客户端使用 HTTP 服务时用来防止彼此间不会覆盖相同内容。&lt;/p&gt;

&lt;p&gt;当服务器端使用 428 Precondition Required 状态码时，表示客户端必须发送上述的请求头才能执行请求，这个方法为服务器提供一种有效的方法来阻止 ‘lost update’ 问题。&lt;/p&gt;

&lt;h3 id=&quot;429-too-many-requests-太多请求&quot;&gt;429 Too Many Requests (太多请求)&lt;/h3&gt;
&lt;p&gt;当你需要限制客户端请求某个服务数量时，该状态码就很有用，也就是请求速度限制。&lt;/p&gt;

&lt;p&gt;在此之前，有一些类似的状态码，例如 ‘509 Bandwidth Limit Exceeded’. Twitter 使用 420 （这不是 HTTP 定义的状态码）&lt;/p&gt;

&lt;p&gt;如果你希望限制客户端对服务的请求数，可使用 429 状态码，同时包含一个 Retry-After 响应头用于告诉客户端多长时间后可以再次请求服务。&lt;/p&gt;

&lt;h3 id=&quot;431-request-header-fields-too-large-请求头字段太大&quot;&gt;431 Request Header Fields Too Large (请求头字段太大)&lt;/h3&gt;
&lt;p&gt;某些情况下，客户端发送 HTTP 请求头会变得很大，那么服务器可发送 431 Request Header Fields Too Large 来指明该问题。&lt;/p&gt;

&lt;p&gt;我不太清楚为什么没有 430 状态码，而是直接从 429 跳到 431，我尝试搜索但没有结果。唯一的猜测是 430 Forbidden 跟 403 Forbidden 太像了，为了避免混淆才这么做的，天知道！&lt;/p&gt;

&lt;h3 id=&quot;511-network-authentication-required-要求网络认证&quot;&gt;511 Network Authentication Required (要求网络认证)&lt;/h3&gt;
&lt;p&gt;对我来说这个状态码很有趣，如果你在开发一个 HTTP 服务器，你不一定需要处理该状态码，但如果你在编写 HTTP 客户端，那这个状态码就非常重要。&lt;/p&gt;

&lt;p&gt;如果你频繁使用笔记本和智能手机，你可能会注意到大量的公用 WIFI 服务要求你必须接受一些协议或者必须登录后才能使用。&lt;/p&gt;

&lt;p&gt;这是通过拦截 HTTP 流量，当用户试图访问网络返回一个重定向和登录，这很讨厌，但是实际情况就是这样的。&lt;/p&gt;

&lt;p&gt;使用这些 “拦截” 客户端，会有一些讨厌的副作用。在 RFC 中有提到这两个的例子：&lt;/p&gt;

&lt;p&gt;如果你在登录 WIFI 前访问某个网站，网络设备将会拦截首个请求，这些设备往往也有自己的网站图标 ‘favicon.ico’。登录后您会发现，有一段时间内你访问的网站图标一直是 WIFI 登录网站的图标。&lt;/p&gt;

&lt;p&gt;如果客户端使用 HTTP 请求来查找文档（可能是 JSON），网络将会响应一个登录页，这样你的客户端就会解析错误并导致客户端运行异常，在现实中这种问题非常常见。&lt;/p&gt;

&lt;p&gt;因此 511 状态码的提出就是为了解决这个问题。&lt;/p&gt;

&lt;p&gt;如果你正在编写 HTTP 的客户端，你最好还是检查 511 状态码以确认是否需要认证后才能访问。&lt;/p&gt;</content><author><name>Lewin</name></author><category term="http" /><category term="status" /><summary type="html">1xx（临时响应） 表示临时响应并需要请求者继续执行操作的状态代码。</summary></entry><entry><title type="html">主流软件负载均衡器对比 (LVS、Nginx、HAproxy)</title><link href="https://lewinz.org/2021/07/28/lvs-nginx-haproxy/" rel="alternate" type="text/html" title="主流软件负载均衡器对比 (LVS、Nginx、HAproxy)" /><published>2021-07-28T00:00:00+08:00</published><updated>2021-07-28T00:00:00+08:00</updated><id>https://lewinz.org/2021/07/28/lvs-nginx-haproxy</id><content type="html" xml:base="https://lewinz.org/2021/07/28/lvs-nginx-haproxy/">&lt;h2 id=&quot;负载均衡的三种实现方式&quot;&gt;负载均衡的三种实现方式&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;基于 DNS 负载均衡
    &lt;ul&gt;
      &lt;li&gt;直接通过 DNS 来实现负载均衡。优点是非常简单，缺点是调整后不知道啥时生效 (当然正常情况下几十分钟，长的也可能更长)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;基于硬件负载均衡
    &lt;ul&gt;
      &lt;li&gt;购买硬件，也就是我们常常说的 F5（F5 Network Big-IP），不过 F5 就贵一般来说单台硬件也得几十万块，要是搞个双机，多机就更贵了&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;基于软件负载均衡
    &lt;ul&gt;
      &lt;li&gt;基于软件的方式也非常多，类似几个主流 LVS、Nginx、HAproxy (当然 IBM 也有个 HIS)，接下来就针对以下几种具体说明：&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;三大主流软件负载均衡器对比-lvsnginxhaproxy&quot;&gt;三大主流软件负载均衡器对比 (LVS、Nginx、HAproxy)&lt;/h2&gt;
&lt;h3 id=&quot;lvs&quot;&gt;LVS&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;抗负载能力强，性能高，能达到 F5 的 60%，对内存和 CPU 资源消耗比较低&lt;/li&gt;
  &lt;li&gt;工作在网络 4 层，通过 VRRP 协议 (仅作代理之用)，具体的流量是由 linux 内核来处理，因此没有流量的产生。&lt;/li&gt;
  &lt;li&gt;稳定，可靠性高，自身有完美的热备方案 (Keepalived+lvs)&lt;/li&gt;
  &lt;li&gt;不支持正则处理，不能做动静分离。&lt;/li&gt;
  &lt;li&gt;支持多种负载均衡算法：rr (轮询)，wrr (带权轮询)、lc (最小连接)、wlc (带权最小连接)&lt;/li&gt;
  &lt;li&gt;配置相对复杂，对网络依赖比较大，稳定性很高。&lt;/li&gt;
  &lt;li&gt;LVS 工作模式有 4 种：
    &lt;ul&gt;
      &lt;li&gt;nat 地址转换&lt;/li&gt;
      &lt;li&gt;dr 直接路由&lt;/li&gt;
      &lt;li&gt;tun 隧道&lt;/li&gt;
      &lt;li&gt;full-nat&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;工作在网络 4 层，相对性能上较高 (网络的七层模式：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;nginx&quot;&gt;Nginx&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;工作在网络 7 层，可以针对 http 应用做一些分流的策略，比如针对域名，目录结构&lt;/li&gt;
  &lt;li&gt;Nginx 对网络的依赖较小，理论上能 ping 通就能进行负载功能&lt;/li&gt;
  &lt;li&gt;Nginx 安装配置比较简单，测试起来很方便&lt;/li&gt;
  &lt;li&gt;也可以承担较高的负载压力且稳定，nginx 是为解决 c10k 问题而诞生的&lt;/li&gt;
  &lt;li&gt;对后端服务器的健康检查，只支持通过端口来检测，不支持通过 url 来检测&lt;/li&gt;
  &lt;li&gt;Nginx 对请求的异步处理可以帮助节点服务器减轻负载压力&lt;/li&gt;
  &lt;li&gt;Nginx 仅能支持 http、https 和 Email 协议，这样就在适用范围较小。&lt;/li&gt;
  &lt;li&gt;不支持 Session 的直接保持，但能通过 ip_hash 来解决。对 Big request header 的支持不是很好。&lt;/li&gt;
  &lt;li&gt;Nginx 还能做 Web 服务器即 Cache 功能。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;haproxy&quot;&gt;HAProxy&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;支持两种代理模式：TCP（四层）和 HTTP（七层），支持虚拟主机；&lt;/li&gt;
  &lt;li&gt;能够补充 Nginx 的一些缺点比如 Session 的保持，Cookie 的引导等工作&lt;/li&gt;
  &lt;li&gt;支持 url 检测后端的服务器出问题的检测会有很好的帮助。&lt;/li&gt;
  &lt;li&gt;更多的负载均衡策略比如：动态加权轮循 (Dynamic Round Robin)，加权源地址哈希 (Weighted Source Hash)，加权 URL 哈希和加权参数哈希 (Weighted Parameter Hash) 已经实现&lt;/li&gt;
  &lt;li&gt;单纯从效率上来讲 HAProxy 更会比 Nginx 有更出色的负载均衡速度。&lt;/li&gt;
  &lt;li&gt;HAProxy 可以对 Mysql 进行负载均衡，对后端的 DB 节点进行检测和负载均衡。&lt;/li&gt;
  &lt;li&gt;支持负载均衡算法：Round-robin（轮循）、Weight-round-robin（带权轮循）、source（原地址保持）、RI（请求 URL）、rdp-cookie（根据 cookie）&lt;/li&gt;
  &lt;li&gt;不能做 Web 服务器即 Cache。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;三大主流软件负载均衡器适用业务场景&quot;&gt;三大主流软件负载均衡器适用业务场景&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;网站建设初期，可以选用 Nginx、HAProxy 作为反向代理负载均衡 (流量不大时，可以不选用负载均衡)，因为其配置简单，性能也能满足一般业务场景。如果考虑到负载均衡器是有单点问题，可以采用 Nginx+Keepalived/HAproxy+Keepalived 避免负载均衡器自身的单点问题。&lt;/li&gt;
  &lt;li&gt;网站并发到达一定程度后，为了提高稳定性和转发效率，可以使用 lvs，毕竟 lvs 比 Nginx/HAProxy 要更稳定，转发效率也更高。
注：nginx 与 HAProxy 比较：nginx 只支持七层，用户量最大，稳定性比较可靠。Haproxy 支持四层和七层，支持更多的负载均衡算法，支持 session 等。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;衡量负载均衡器好坏的几个重要的因素&quot;&gt;衡量负载均衡器好坏的几个重要的因素：&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;会话率 ：单位时间内的处理的请求数&lt;/li&gt;
  &lt;li&gt;会话并发能力：并发处理能力&lt;/li&gt;
  &lt;li&gt;数据率：处理数据能力&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;负载均衡的策略&quot;&gt;负载均衡的策略&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;轮询策略&lt;/li&gt;
  &lt;li&gt;负载度策略&lt;/li&gt;
  &lt;li&gt;响应策略&lt;/li&gt;
  &lt;li&gt;哈希策略&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Lewin</name></author><category term="lvc" /><category term="nginx" /><category term="haproxy" /><summary type="html">负载均衡的三种实现方式 基于 DNS 负载均衡 直接通过 DNS 来实现负载均衡。优点是非常简单，缺点是调整后不知道啥时生效 (当然正常情况下几十分钟，长的也可能更长) 基于硬件负载均衡 购买硬件，也就是我们常常说的 F5（F5 Network Big-IP），不过 F5 就贵一般来说单台硬件也得几十万块，要是搞个双机，多机就更贵了 基于软件负载均衡 基于软件的方式也非常多，类似几个主流 LVS、Nginx、HAproxy (当然 IBM 也有个 HIS)，接下来就针对以下几种具体说明：</summary></entry><entry><title type="html">openstack 秒级创建虚机方案</title><link href="https://lewinz.org/2021/07/28/openstack-create-nova/" rel="alternate" type="text/html" title="openstack 秒级创建虚机方案" /><published>2021-07-28T00:00:00+08:00</published><updated>2021-07-28T00:00:00+08:00</updated><id>https://lewinz.org/2021/07/28/openstack-create-nova</id><content type="html" xml:base="https://lewinz.org/2021/07/28/openstack-create-nova/">&lt;p&gt;OpenStack 管理虚拟机生命周期的组件是 Nova，Nova 创建虚拟机从后端存储类型分为本地 LVM 存储和远程分布式存储（例如：Ceph/SheepDog/GlusterFS），从启动方式一般分为镜像启动和卷启动两大类，按启动方式和存储后端可以有 4 种组合&lt;/p&gt;

&lt;h2 id=&quot;本地-lvm--镜像启动&quot;&gt;本地 LVM + 镜像启动&lt;/h2&gt;

&lt;p&gt;此种方式，虚拟机镜像事先一般也会存放在远端的分布式存储上（Ceph 或 Swift）。当在计算节点首次创建虚拟机时，会从远端分布式存储下载镜像到计算节点做格式转换并缓存为 base-image，然后复制完整的镜像到 /var/lib/nova/instances/{instance-uuid} 目录下作为系统盘，耗时跟镜像大小和带宽有关，一般约数分数以上。&lt;/p&gt;

&lt;p&gt;如果在相同的计算节点上第二次以相同的镜像创建虚拟机，因为已经有了镜像缓存，不需要再到远端分布式存储下载镜像，直接从本地计算节点拷贝镜像到虚拟机启动目录作为系统盘，耗时跟镜像大小有关，一般也得数分钟以上。&lt;/p&gt;

&lt;h2 id=&quot;本地-lvm--卷启动&quot;&gt;本地 LVM + 卷启动&lt;/h2&gt;

&lt;p&gt;此种方式，虚拟机镜像事先一般也会存放在远端的分布式存储上（Ceph 或 Swift）。当在计算节点首次创建虚拟机时，会从远端分布式存储下载镜像到计算节点做格式转换并缓存为 base-image，然后调用 cinder 在控制节点以 base-image 创建可 bootable 的卷，最后以该卷启动虚拟机。耗时跟镜像大小和带宽有关，一般也得数分钟以上。&lt;/p&gt;

&lt;p&gt;如果在相同的计算节点上第二次以相同的镜像从卷启动创建虚拟机，因为已经有了镜像缓存，不需要再到远端分布式存储下载镜像，直接调用 cinder 在控制节点以 base-image 创建可 bootable 的卷，最后以该卷启动虚拟机。耗时跟镜像大小和带宽有关，一般也得数分钟以上。&lt;/p&gt;

&lt;h2 id=&quot;远程分布式存储-ceph--镜像启动采用默认配置&quot;&gt;远程分布式存储 Ceph + 镜像启动（采用默认配置）&lt;/h2&gt;

&lt;p&gt;此种方式，虚拟机镜像事先一般也会存放在远端的分布式存储 Ceph 上。当在计算节点首次创建虚拟机时，首先会从远程 Ceph 上下载镜像到该计算节点做格式转换并缓存为 base-image，然后上传 base-image 到远程 Ceph Rbd 的 pool 中作为系统盘，最后以 CephRbd pool 中的系统盘启动虚拟机。耗时跟镜像大小和带宽有关，一般也得数分钟以上。&lt;/p&gt;

&lt;p&gt;在相同的计算节点上第二次以相同的镜像创建虚拟机，因为已经有了镜像缓存，不需要再到远端 Ceph 下载镜像，直接上传 base-image 到远程 Ceph Rbd 的 pool 中作为系统盘，最后以 CephRbd pool 中的系统盘启动虚拟机。耗时跟镜像大小和带宽有关，一般也得数分钟以上。&lt;/p&gt;

&lt;h2 id=&quot;远程分布式存储-ceph--卷启动采用默认配置&quot;&gt;远程分布式存储 Ceph + 卷启动（采用默认配置）&lt;/h2&gt;

&lt;p&gt;此种方式，虚拟机镜像事先一般也会存放在远端的分布式存储 Ceph 上。当在计算节点首次创建虚拟机时，首先会从远程 Ceph 上下载镜像到该计算节点做格式转换并缓存为 base-image，然后调用 cinder 通过 base-image 在远程 Ceph Rbd 的 pool 中创建可 bootable 的启动卷，最后以 Ceph Rbd pool 中的卷启动虚拟机。耗时跟镜像大小和带宽有关，一般也得数分钟以上。&lt;/p&gt;

&lt;p&gt;在相同的计算节点上第二次以相同的镜像以卷启动创建虚拟机，因为已经有了镜像缓存，不需要再到远端 Ceph 下载镜像，直接调用 cinder 通过 base-image 在远程 Ceph Rbd 的 pool 中创建可 bootable 的启动卷，最后以 Ceph Rbd pool 中的卷启动虚拟机。耗时跟镜像大小和带宽有关，一般也得数分钟以上。&lt;/p&gt;

&lt;h2 id=&quot;秒级创建虚拟机优化方案&quot;&gt;秒级创建虚拟机优化方案&lt;/h2&gt;

&lt;p&gt;在优化之前，如果按照上述 4 种组合任一一种来创建虚拟机，如果批量创建几百台虚拟机，因为有镜像的下载、上传或者拷贝流程，整个创建流程会非常耗时，有些会因为接口超时导致失败。&lt;/p&gt;

&lt;p&gt;为了达到秒级创建虚拟机的性能，Glance、Cinder 和 Nova 的后端存储统一以 Ceph 作为共享存储。Glance 上传的虚拟机镜像会上传到 Ceph images pool 中，Cinder 创建的卷会保存在 Ceph volumes pool 中，Nova 系统盘保存在 Cephinstances pool 中。&lt;/p&gt;

&lt;p&gt;如果是以镜像启动创建虚拟机，在同一个计算节点选择相同的镜像不论是第一次还是第二次创建虚拟机，会直接基于 ceph images pool 的镜像先做 snapshot，然后基于该 snapshot 进行 clone（copy on write）到 Cephinstances pool，最后以该系统盘启动虚拟机。利用 ceph 写时复制特性，不存在镜像的上传、下载和完整拷贝，所以创建速度非常快，可以达到秒级。&lt;/p&gt;

&lt;p&gt;如果是以卷启动创建虚拟机，在同一个计算节点选择相同的镜像不论是第一次还是第二次创建虚拟机，会直接基于 ceph images pool 的镜像先做 snapshot，然后调用 cinder 基于该 snapshot 进行 clone（copy on write）到 Ceph volumes pool，最后以该卷启动虚拟机。利用 ceph 写时复制特性，不存在镜像的上传、下载和完整拷贝，所以创建速度非常快，可以达到秒级。&lt;/p&gt;

&lt;h2 id=&quot;秒级创建虚拟机的优化步骤&quot;&gt;秒级创建虚拟机的优化步骤&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;在 controller 控制节点上修改 /etc/glance/glance-api.conf 镜像配置文件，把 show_image_direct_url 参数设置为 True。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;vim /etc/glance/glance-api.conf&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/openstack_create_nova_1.png&quot; alt=&quot;openstack_create_nova_1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意：一定要在【DEFAULT】下添加。&lt;/p&gt;

&lt;p&gt;然后利用命令 serviceopenstack-glance-api restart 重启镜像管理服务。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;转换镜像格式，通过 glance 上传的镜像一定要是 raw 格式。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在上传之前需要命令转换好后上传，转换命令：&lt;/p&gt;

&lt;p&gt;qemu-img convert -O raw src-img.qcow2dst-img.raw&lt;/p&gt;

&lt;p&gt;用命令行转换成 raw 格式，主要是解决如下 no bootable device 问题。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/openstack_create_nova_2.png&quot; alt=&quot;openstack_create_nova_2&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在计算节点上进入 /var/lib/nova/instances/_base/ 目录，清空该目录下所有的缓存镜像。由于后台程序会先检测该目录下有没有缓存镜像，如果有，会把该缓存镜像上传到 ceph 中，如果没有，直接在 ceph 中 clone 镜像。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;步骤如下：&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@openstack _base]# &lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt;/var/lib/nova/instances/_base/

&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@openstack _base]# ll

&lt;span class=&quot;nt&quot;&gt;-rw-r--r--&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; 1 qemu qemu 41126400 Jul 24 01:01d7fca384a7c355afa3b70667b60f04dd08cd6f35

&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@openstack _base]# &lt;span class=&quot;nb&quot;&gt;rm&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-rfd7fca384a7c355afa3b70667b60f04dd08cd6f35&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@openstack _base]# ll

total 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;相关的流程源码如下：&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/openstack_create_nova_3.png&quot; alt=&quot;openstack_create_nova_3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/openstack_create_nova_4.png&quot; alt=&quot;openstack_create_nova_4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[root@openstack ~]# vim /usr/lib/python2.7/site-packages/nova/virt/libvirt/imagebackend.py&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/openstack_create_nova_5.png&quot; alt=&quot;openstack_create_nova_5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[root@openstack ~]# vim /usr/lib/python2.7/site-packages/nova/virt/libvirt/driver.py&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/openstack_create_nova_6.jpeg&quot; alt=&quot;openstack_create_nova_6&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[root@openstack ~]# vim/usr/lib/python2.7/site-packages/glance/api/v2/images.py&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/openstack_create_nova_7.jpeg&quot; alt=&quot;openstack_create_nova_7&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;上述介绍的不同种类的创建虚拟机的组合方式，从核心原理分析其实只有两类。一种是需要完整拷贝镜像，另一种是写时复制（copy on write）。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;完整拷贝镜像创建虚拟机&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;优点：是每个虚拟机独立，不会相互影响。&lt;/p&gt;

&lt;p&gt;缺点：存在镜像下载、上传或者拷贝，创建速度慢。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;写时复制（copyon write）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;优点：每次创建虚拟机都只有很小的增量文件，不存在全量镜像拷贝，创建速度很快。&lt;/p&gt;

&lt;p&gt;缺点：以相同的镜像创建的所有虚拟机依赖共同的 base-image，如果 base-image 意外损坏或删除，上层依赖的虚拟机都会受到影响。&lt;/p&gt;

&lt;p&gt;速度和安全性往往是一对矛盾体，两种方式需要做一定的权衡。可以在完整拷贝镜像创建虚拟机的方案中提升硬件性能，比如通过高配的磁盘和带宽来降低拷贝镜像的时间。也可以在写时复制（copy on write）的方案中，在虚拟机创建成功后的某个恰当时刻，通过后台执行 ceph 的 rbd flatten 命令断开 base-image 和增量 clone 虚拟磁盘的依赖链，达到每个虚拟机相互独立。&lt;/p&gt;</content><author><name>Lewin</name></author><category term="openstack" /><category term="nova" /><summary type="html">OpenStack 管理虚拟机生命周期的组件是 Nova，Nova 创建虚拟机从后端存储类型分为本地 LVM 存储和远程分布式存储（例如：Ceph/SheepDog/GlusterFS），从启动方式一般分为镜像启动和卷启动两大类，按启动方式和存储后端可以有 4 种组合</summary></entry><entry><title type="html">openstack nova 创建虚拟机步骤</title><link href="https://lewinz.org/2021/07/28/openstack-nova-step/" rel="alternate" type="text/html" title="openstack nova 创建虚拟机步骤" /><published>2021-07-28T00:00:00+08:00</published><updated>2021-07-28T00:00:00+08:00</updated><id>https://lewinz.org/2021/07/28/openstack-nova-step</id><content type="html" xml:base="https://lewinz.org/2021/07/28/openstack-nova-step/">&lt;h2 id=&quot;nova-创建虚机总流程&quot;&gt;nova 创建虚机总流程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/openstack_nova_step_1.png&quot; alt=&quot;openstack_nova_step&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;nova-创建虚机请求流&quot;&gt;nova 创建虚机请求流&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;Dashboard 或者 CLI 获取用户的登录信息，调用 Keystone 的 REST API 去做用户身份验证。&lt;/li&gt;
  &lt;li&gt;Keystone 对用户登录信息进行校验，然后产生验证 token 并发回。它会被用于后续 REST 调用请求。&lt;/li&gt;
  &lt;li&gt;Dashboard 或者 CLI 将创建虚机的 REST 请求中的‘launch instance’ 或‘nova-boot’ 部分进行转换，然后调用 nova-api 的 REST 接口。&lt;/li&gt;
  &lt;li&gt;nova-api 接到请求，向 keystone 发送 auth-token 校验和权限认证请求。&lt;/li&gt;
  &lt;li&gt;Keystone 校验 token，并将 auth headers 发回，它包括了 roles 和 permissions。&lt;/li&gt;
  &lt;li&gt;nova-api 和 nova-database 进行交互。&lt;/li&gt;
  &lt;li&gt;nova-database 为新实例创建一个数据库条目。&lt;/li&gt;
  &lt;li&gt;nova-api 向 nova-scheduler 发送  rpc.call 请求，期望它能通过附带的 host ID 获取到数据库条目。&lt;/li&gt;
  &lt;li&gt;nova-scheduler 从 queue 中获取到请求。&lt;/li&gt;
  &lt;li&gt;nova-scheduler 和 nova-database 交互，获取集群中计算节点的信息和状态。&lt;/li&gt;
  &lt;li&gt;nova-scheuler 通过过滤（filtering）和称重（weighting）找到一个合适的计算节点（host）。&lt;/li&gt;
  &lt;li&gt;nova-scheduler 向找到的那个 host 上的 nova-compute 发送 rpc.cast 请求去启动虚机。&lt;/li&gt;
  &lt;li&gt;目标 host 上的 nova-compute 从 queue 中获取到请求。&lt;/li&gt;
  &lt;li&gt;nova-compute 向 nova-condutor 发送 rpc.call 请求去获取待创建虚机的信息比如 host ID 和 flavor 等。&lt;/li&gt;
  &lt;li&gt;nova-conductor 从 queue 中获取到请求。&lt;/li&gt;
  &lt;li&gt;nova-conductor 和 nova-database 交互。&lt;/li&gt;
  &lt;li&gt;nova-database 向 nova-conductor 返回虚机的信息。&lt;/li&gt;
  &lt;li&gt;nova-conductor 向 nova-compute 发送 rpc.call，附带所请求的信息。图中应该是遗漏了一个步骤，就是 nova-compute 从 queue 中获取返回的数据。&lt;/li&gt;
  &lt;li&gt;nova-compute 调用 glance-api 的 REST API，传入 auth-token，去根据镜像 ID 获取镜像 URI，从镜像存储中下载（原文为 upload）镜像。&lt;/li&gt;
  &lt;li&gt;glance-api 向 keystone 校验 auth-token。&lt;/li&gt;
  &lt;li&gt;nova-compute 获取 image 的元数据。&lt;/li&gt;
  &lt;li&gt;nova-compute 调用 Neutron API ，传入 auth-token，去分配和配置网络，比如虚机的 IP 地址。&lt;/li&gt;
  &lt;li&gt;neutron-server 通过 keystone 校验 auth-token。&lt;/li&gt;
  &lt;li&gt;nova-compute 获得网络信息。&lt;/li&gt;
  &lt;li&gt;nova-compute 调用 Cinder API，传入 auth-token，去将 volume 挂接到实例。&lt;/li&gt;
  &lt;li&gt;cinder-api 通过 keystone 校验 auth-token。&lt;/li&gt;
  &lt;li&gt;nova-compute 获得块存储信息。&lt;/li&gt;
  &lt;li&gt;nova-compute 为 hypervisor driver 产生数据，并调用 Hypersior 执行请求（通过 libvirt 或者 api）。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;下表列出了每个步骤中实例的状态&quot;&gt;下表列出了每个步骤中实例的状态：&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Status&lt;/th&gt;
      &lt;th&gt;Task&lt;/th&gt;
      &lt;th&gt;Power state&lt;/th&gt;
      &lt;th&gt;Steps&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Build&lt;/td&gt;
      &lt;td&gt;scheduling&lt;/td&gt;
      &lt;td&gt;None&lt;/td&gt;
      &lt;td&gt;3-12&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Build&lt;/td&gt;
      &lt;td&gt;networking&lt;/td&gt;
      &lt;td&gt;None&lt;/td&gt;
      &lt;td&gt;22-24&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Build&lt;/td&gt;
      &lt;td&gt;block_device_mapping&lt;/td&gt;
      &lt;td&gt;None&lt;/td&gt;
      &lt;td&gt;25-27&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Build&lt;/td&gt;
      &lt;td&gt;spawing&lt;/td&gt;
      &lt;td&gt;None&lt;/td&gt;
      &lt;td&gt;28&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Active&lt;/td&gt;
      &lt;td&gt;none&lt;/td&gt;
      &lt;td&gt;Running&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;nova-compute-接到指令后开始创建虚机的代码分析-第-19-步之后&quot;&gt;nova compute 接到指令后开始创建虚机的代码分析 （第 19 步之后）&lt;/h2&gt;
&lt;p&gt;代码在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;https://github.com/openstack/nova/blob/master/nova/compute/manager.py&lt;/code&gt; 中的 def _build_and_run_instance 函数中：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;_build_resources&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;准备网络和磁盘&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Start&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;building&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;networks&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;asynchronously&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt;
    &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_build_networks_for_instance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;为&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;准备网络资源&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;，&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;实际上是创建一个&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;neutron&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;macs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;driver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;macs_for_instance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;分配mac地址&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;。&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;多绝大多数hypersivor&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;，&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;返回None&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;，&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;也就是不预先分配&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;network_info&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_allocate_network&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;开始异步网络分配&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;nwinfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;network_api&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;allocate_for_instance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Allocate&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;network&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resources&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;_validate_requested_port_ids&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;校验&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ids&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;_validate_requested_network_ids&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;校验&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;network&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ids&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;_clean_security_groups&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;删除&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;安全组&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;_process_security_groups&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Processes&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;validates&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requested&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;security&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;groups&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;allocation&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;_create_ports_for_instance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Create&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;network_requests&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;that&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;don&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'t have a port_id
                    _create_port_minimal //如果port 没有的话，则Attempts to create a port for the instance on the given network.
                        port_client.create_port //调用 port api 来创建 port，包括创建 port，分配MAC及IP地址，更新数据库
                            _generate_mac //生成MAC地址
                            _create_port_with_mac //创建 port
                                //DHCP 相关操作：port 创建完成后会通知 neutron-dhcp-agent去执行port_create_end函数，它会将port的ip和mac信息加载到dnsmasq所需的配置文件中
                            _allocate_ips_for_port //为 port 分配 IP，要么用户有指定，要么从subnets 中选择一个
                                _allocate_specific_ip //如果指定了IP
                                _generate_ip //如果没指定IP
                    return requests_and_created_ports
                _update_ports_for_instance //为特殊case 更新 port
                    _populate_neutron_extension_values
                    _populate_pci_mac_address //只用于处理 SRIOV_PF
                    _populate_mac_address
                    _update_port
                        port_client.update_port //将上述修改通过调用 port api 得以更新port
                    _update_port_dns_name
                        neutron.update_port(port_id, port_req_body) //将 port 的 dns_name 设置为 hostname
                nw_info = self.get_instance_nw_info
                    _build_network_info_model //Return list of ordered VIFs attached to instance
                        _gather_port_ids_and_networks //Return an instance'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;complete&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port_ids&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;networks&lt;/span&gt;
                            &lt;span class=&quot;n&quot;&gt;ifaces&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_network_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nw_info&lt;/span&gt;

    &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Start&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;building&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;block&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;device&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mappings&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt;
    &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_prep_block_device&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Set&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;up&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;block&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;device&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;an&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;logging&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;block_device_info&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;driver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_block_device_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bdms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Converts&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;block&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;device&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mappings&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;driver&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;format&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;mapping&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;driver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block_device_info_get_mapping&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block_device_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;block_device_mapping&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;driver_block_device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;attach_block_devices&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;virt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block_device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;py&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;_log_and_attach&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;首先找出instance&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;将从哪里启动&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;，&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;可能从&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;volume&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;，&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;snapshot&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;，&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;image&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;上启动&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;bdm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;attach&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;真正做&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;attach&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;操作&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_block_device_info_to_legacy&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;block_device_info&lt;/span&gt;

&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;driver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spawn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;调用&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;virt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libvirt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;driver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;py&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;中的&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spawn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;函数&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;，&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;首先创建&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;，&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;然后创建domain&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;disk_info&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blockinfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_disk_info&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;_create_configdrive&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;_create_image&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;创建镜像&lt;/span&gt;
           &lt;span class=&quot;n&quot;&gt;libvirt_utils&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fetch_raw_image&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;IMAGE_API&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;download&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;调用&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;glance&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;API&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;去下载镜像&lt;/span&gt;
           &lt;span class=&quot;n&quot;&gt;_create_and_inject_local_root&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;做文件注入&lt;/span&gt;
           &lt;span class=&quot;n&quot;&gt;_create_ephemeral&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;libvirt_utils&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;create_image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'raw'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'%dG'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ephemeral_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                   &lt;span class=&quot;n&quot;&gt;utils&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'qemu-img'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'create'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'-f'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;disk_format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
           &lt;span class=&quot;n&quot;&gt;_create_swap&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;libvirt_utils&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;create_image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'raw'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'%dM'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;swap_mb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;privsep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unprivileged_mkfs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'swap'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;xml&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_get_guest_xml&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;生成&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;domain&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xml&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;字符串&lt;/span&gt;
           &lt;span class=&quot;n&quot;&gt;conf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_get_guest_config&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;_get_guest_numa_config&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;_get_guest_memory_backing_config&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;_get_guest_config_meta&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;_update_guest_cputune&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;_cpu_config_to_vcpu_model&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;_configure_guest_by_virt_type&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;_set_features&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;_set_clock&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;_get_guest_storage_config&lt;/span&gt;
               &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vif_driver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_config&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;_create_consoles&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;_guest_add_spice_channel&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;_add_video_driver&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;_set_qemu_guest_agent&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;_guest_add_pci_devices&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;_guest_add_watchdog_action&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;_guest_add_memory_balloon&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;_guest_add_mdevs&lt;/span&gt;
               &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;guest&lt;/span&gt;
           &lt;span class=&quot;n&quot;&gt;xml&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;conf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to_xml&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
           &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xml&lt;/span&gt;

       &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_create_domain_and_network&lt;/span&gt;
           &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nova侧去等待neutron侧发送network&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vif&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pluggend事件&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;。&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;neutron&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;linuxbridge&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;agent服务检测tap设备&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;，&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;neutron&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;server发送event事件给nova&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;api&lt;/span&gt;
           &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;virtapi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wait_for_instance_event&lt;/span&gt;
           &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;plug_vifs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;network_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
           &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;firewall_driver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setup_basic_filtering&lt;/span&gt;
           &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;firewall_driver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prepare_instance_filter&lt;/span&gt;
           &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_create_domain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xml&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;libvirt_guest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Guest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xml&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_host&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                   &lt;span class=&quot;n&quot;&gt;write_instance_config&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;virt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libvirt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;host&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;py&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;中&lt;/span&gt;
                   &lt;span class=&quot;n&quot;&gt;domain&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_connection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;defineXML&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xml&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                   &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;libvirt_guest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Guest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;domain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
               &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;guest&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;_wait_for_boot&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;每隔&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;秒检查虚机是否启动&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;_update_instance_after_spawn&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;_update_scheduler_instance_info&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;scheduler_client&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;update_instance_info&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;_notify_about_instance_usage&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;补充&quot;&gt;补充：&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;port 创建成功后的 dhcp 相关操作（参考 &lt;a href=&quot;https://blog.csdn.net/gj19890923/article/details/51558598&quot;&gt;https://blog.csdn.net/gj19890923/article/details/51558598&lt;/a&gt;）：
    &lt;ul&gt;
      &lt;li&gt;创建 VM 时，nova-compute 与 neutron 的 plugin 交互，在 neutron 的数据库中创建 VM 所需的 port 信息。&lt;/li&gt;
      &lt;li&gt;neutron 数据库中的 port 信息创建完成后，通知 neutron-dhcp-agent 去执行 port_create_end 函数。该函数将数据库中的 port 中的 ip 和 mac 信息加载到 dnsmasq 所需的配置文件中 (包括 host 和 addn_hosts 文件)。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@nova 43c0e274-28e3-482e-a32b-d783980fc3ed]# &lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;addn_hosts

  1.1.1.1 host-1-1-1-1.openstacklocal host-1-1-1-1

  1.1.1.2 host-1-1-1-2.openstacklocal host-1-1-1-2

  1.1.1.10        host-1-1-1-10.openstacklocal host-1-1-1-10

&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@nova 43c0e274-28e3-482e-a32b-d783980fc3ed]# &lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;host

  fa:16:3e:d1:d7:72,host-1-1-1-1.openstacklocal,1.1.1.1

  fa:16:3e:da:42:50,host-1-1-1-2.openstacklocal,1.1.1.2

  fa:16:3e:3c:a3:3e,host-1-1-1-10.openstacklocal,1.1.1.10
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@nova 43c0e274-28e3-482e-a32b-d783980fc3ed]# &lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;leases

  1464599134 fa:16:3e:3c:a3:3e 1.1.1.10 host-1-1-1-10 01:fa:16:3e:3c:a3:3e

  1464598886 fa:16:3e:da:42:50 1.1.1.2 host-1-1-1-2 &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;

  1464598886 fa:16:3e:d1:d7:72 1.1.1.1 host-1-1-1-1 &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在 VM 启动时，广播 dhcp discover 请求，当 dnsmasq 进程的监听接口 ns-xxx 监听到这种请求时，dnsmasq 进程将根据配置文件 (host 和 leases 文件) 中的内容去判定是否有未分配的 ip 和 mac 为请求者进行提供。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最终 VM 便真实的获取到与保存在数据库中的 ip 和 mac 信息。neutron-dhcp-agent 只是将所创建 VM 的 ip 和 mac 信息从数据库中获取到自己的配置文件中，然后等到 VM 启动时，为它提供。因此 neutron-dhcp-agent 相当于在 VM 和数据库之间起了个中间桥梁的作用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;nova 在 domain 被创建后等待 neutron event 的过程（请参考 &lt;a href=&quot;http://www.aichengxu.com/linux/9307663.htm&quot;&gt;http://www.aichengxu.com/linux/9307663.htm&lt;/a&gt;）&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;创建VM时， nova-compute服务调用wait_for_instance_event函数等待neutron侧发送event事件。&lt;/li&gt;
      &lt;li&gt;neutron 的 neutron-linuxbridge-agent 定时检测 tap 设备的增加或删除，当创建 VM 时，将创建新的 tap 设备，此时将更新 neutron 数据库中的 ports 表，而 neutron-server 服务创建 core_plugin 时，将利用 sqlalchemy 自带的 event 对 neutron 数据库中的 ports 表进行监视，当 ports 表发生变化时，neutron-server 将通过 HTTP 请求的方式发送 event 事件给 nova。&lt;/li&gt;
      &lt;li&gt;nova侧收到neutron侧发送的event事件，便结束等待，继续创建VM下面的操作。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;虚机被创建后的-l2-网络操作&quot;&gt;虚机被创建后的 L2 网络操作&lt;/h2&gt;
&lt;p&gt;虚机被创建后，nova-compute 节点上的 neutron-linuxbridge-agent 会检测到新建的 tap 设备（通过轮询 /sys/class/net/ 里面的 tap 设备），找到后则执行一系列网络方面的操作，包括设置安全组，&lt;/p&gt;

&lt;p&gt;tap 设备示例：&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@test net]# &lt;span class=&quot;nb&quot;&gt;ls
&lt;/span&gt;brq8165bc3d-40 eth0 eth1 eth1.120 eth2 lo tap712a2c63-e6 tap83e7c095-f0 tap8f4fcfbb-2b
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;tap 设备信息：&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Port tap93121330-58 updated. Details: &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;u&lt;span class=&quot;s1&quot;&gt;'profile'&lt;/span&gt;: &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;, u&lt;span class=&quot;s1&quot;&gt;'allowed_address_pairs'&lt;/span&gt;: &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;, u&lt;span class=&quot;s1&quot;&gt;'admin_state_up'&lt;/span&gt;: True, u&lt;span class=&quot;s1&quot;&gt;'network_id'&lt;/span&gt;: u&lt;span class=&quot;s1&quot;&gt;'8165bc3d-400a-48a0-9186-bf59f7f94b05'&lt;/span&gt;, u&lt;span class=&quot;s1&quot;&gt;'segmentation_id'&lt;/span&gt;: 120,u&lt;span class=&quot;s1&quot;&gt;'device_owner'&lt;/span&gt;: u&lt;span class=&quot;s1&quot;&gt;'compute:nova'&lt;/span&gt;,
u&lt;span class=&quot;s1&quot;&gt;'physical_network'&lt;/span&gt;: u&lt;span class=&quot;s1&quot;&gt;'physnet1'&lt;/span&gt;, u&lt;span class=&quot;s1&quot;&gt;'mac_address'&lt;/span&gt;: u&lt;span class=&quot;s1&quot;&gt;'fa:16:3e:9f:6f:c5'&lt;/span&gt;, u&lt;span class=&quot;s1&quot;&gt;'device'&lt;/span&gt;: u&lt;span class=&quot;s1&quot;&gt;'tap93121330-58'&lt;/span&gt;, u&lt;span class=&quot;s1&quot;&gt;'port_security_enabled'&lt;/span&gt;: True, u&lt;span class=&quot;s1&quot;&gt;'port_id'&lt;/span&gt;: u&lt;span class=&quot;s1&quot;&gt;'93121330-58'&lt;/span&gt;, u&lt;span class=&quot;s1&quot;&gt;'fixed_ips'&lt;/span&gt;: &lt;span class=&quot;o&quot;&gt;[{&lt;/span&gt;u&lt;span class=&quot;s1&quot;&gt;'subnet_id'&lt;/span&gt;: u&lt;span class=&quot;s1&quot;&gt;'ec1028b2-7cb0-4feb-b974-6b8ea7e7f08f'&lt;/span&gt;, u&lt;span class=&quot;s1&quot;&gt;'ip_address'&lt;/span&gt;: u&lt;span class=&quot;s1&quot;&gt;'172.16.0.7'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}]&lt;/span&gt;,
u&lt;span class=&quot;s1&quot;&gt;'network_type'&lt;/span&gt;: u&lt;span class=&quot;s1&quot;&gt;'vlan'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Lewin</name></author><category term="openstack" /><category term="nova" /><summary type="html">nova 创建虚机总流程</summary></entry><entry><title type="html">golang 内存分配</title><link href="https://lewinz.org/2021/07/26/golang-memory-allocation/" rel="alternate" type="text/html" title="golang 内存分配" /><published>2021-07-26T00:00:00+08:00</published><updated>2021-07-26T00:00:00+08:00</updated><id>https://lewinz.org/2021/07/26/golang-memory-allocation</id><content type="html" xml:base="https://lewinz.org/2021/07/26/golang-memory-allocation/">&lt;p&gt;在内存从分配到回收的生命周期中，内存不再被使用的时候，标准库会自动执行 Go 的内存管理。虽然开发者不必操心这些细节，但是 Go 语言所做的底层管理经过了很好的优化，同时有很多有趣的概念。&lt;/p&gt;

&lt;h2 id=&quot;堆上的分配&quot;&gt;堆上的分配&lt;/h2&gt;
&lt;p&gt;内存管理被设计为可以在并发环境快速执行，同时与垃圾收集器集成在了一起。从一个简单的例子开始：&lt;/p&gt;
&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;smallStruct&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int64&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float64&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;smallAllocation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;//go:noinline&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;smallAllocation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;smallStruct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;smallStruct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;注释 //go:noinline 会禁用内联，以避免内联通过移除函数的方式优化这段代码，从而造成最终没有分配内存的情况出现。&lt;/p&gt;

&lt;p&gt;通过运行逃逸分析命令 go tool compile “-m” main.go 可以确认 Go 执行了的分配：
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main.go:14:9: &amp;amp;smallStruct literal escapes to heap&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;借助 go tool compile -S main.go 命令得到这段程序的汇编代码，可以同样明确地向我们展示具体的分配细节：&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0x001d 00029 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;main.go:14&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;   LEAQ   type.&lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;.smallStruct&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;SB&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, AX
0x0024 00036 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;main.go:14&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;  PCDATA &lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt;
0x0024 00036 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;main.go:14&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;  MOVQ   AX, &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;SP&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
0x0028 00040 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;main.go:14&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;  CALL   runtime.newobject&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;SB&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;函数 newobject 是用于新对象的分配以及代理 mallocgc 的内置函数，该函数在堆上管理这些内存。在 Go 语言中有两种策略，一种用于较小的内存空间的分配，而另一种则用于较大的内存空间的分配。&lt;/p&gt;

&lt;h2 id=&quot;较小内存空间的分配策略&quot;&gt;较小内存空间的分配策略&lt;/h2&gt;
&lt;p&gt;对于小于 32kb 的，较小的内存空间的分配策略，Go 会从被叫做 mcache 的本地缓存中尝试获取内存。 这个缓存持有一个被叫做 mspan 的内存块 (span ，32kb 大小的内存块) 列表，mspan 包含着可用于分配的内存：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/golang_memory_allocation_1.png&quot; alt=&quot;golang_memory_allocation_1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每个线程 M 被分配一个处理器 P，并且一次最多处理一个 goroutine。在分配内存时，当前的 goroutine 会使用它当前的 P 的本地缓存，在 span 链表中寻找第一个可用的空闲对象。使用这种本地缓存不需要锁操作，从而分配效率更高。&lt;/p&gt;

&lt;p&gt;span 链表被划分为 8 字节大小到 32k 字节大小的，约 70 个的大小等级，每个等级可以存储不同大小的对象。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/golang_memory_allocation_2.png&quot; alt=&quot;golang_memory_allocation_2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每个 span 链表会存在两份：一个链表用于不包含指针的对象而另一个用于包含指针的对象。这种区别使得垃圾收集器更加轻松，因为它不必扫描不包含任何指针的 span。&lt;/p&gt;

&lt;p&gt;在我们前面的例子中，结构体的大小是 32 字节，因此它会适合于 32 字节的 span ：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/golang_memory_allocation_3.png&quot; alt=&quot;golang_memory_allocation_3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现在，我们可能会好奇，如果在分配期间 span 没有空闲的插槽会发生什么。Go 维护着每个大小等级的 span 的中央链表，该中央链表被叫做 mcentral，其中维护着包含空闲对象的 span 和没有空闲对象的 span ：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/golang_memory_allocation_4.png&quot; alt=&quot;golang_memory_allocation_4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;mcentral 维护着 span 的双向链表；其中每个链表节点有着指向前一个 span 和后一个 span 的引用。非空链表中的 span 可能包含着一些正在使用的内存，“非空” 表示在链表中至少有一个空闲的插槽可供分配。当垃圾收集器清理内存时，可能会清理一部分 span，将这部分标记为不再使用，并将其放回非空链表。&lt;/p&gt;

&lt;p&gt;我们的程序现在可以在没有插槽的情况下向中央链表请求 span ：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/golang_memory_allocation_5.png&quot; alt=&quot;golang_memory_allocation_5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果空链表中没有可用的 span，Go 需要为中央链表获取新的 span 。新的 span 会从堆上分配，并链接到中央链表上：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/golang_memory_allocation_6.png&quot; alt=&quot;golang_memory_allocation_6&quot; /&gt;&lt;/p&gt;

&lt;p&gt;堆会在需要的时候从系统（ OS ）获取内存，如果需要更多的内存，堆会分配一个叫做 arena 的大块内存，在 64 位架构下为 64Mb，在其他架构下大多为 4Mb。arena 同样适用 span 映射内存。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/golang_memory_allocation_7.png&quot; alt=&quot;golang_memory_allocation_7&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;较大内存空间的分配策略&quot;&gt;较大内存空间的分配策略&lt;/h2&gt;
&lt;p&gt;Go 并不适用本地缓存来管理较大的内存空间分配。对于超过 32kb 的分配，会向上取整到页的大小，并直接从堆上分配。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/golang_memory_allocation_8.png&quot; alt=&quot;golang_memory_allocation_8&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;全景图&quot;&gt;全景图&lt;/h2&gt;
&lt;p&gt;现在我们对内存分配的时候发生了什么有了更好的认识。现在将所有的组成部分放在一起来得到完整的图画。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/golang_memory_allocation_9.png&quot; alt=&quot;golang_memory_allocation_9&quot; /&gt;&lt;/p&gt;</content><author><name>Lewin</name></author><category term="golang" /><category term="memory" /><category term="allocation" /><summary type="html">在内存从分配到回收的生命周期中，内存不再被使用的时候，标准库会自动执行 Go 的内存管理。虽然开发者不必操心这些细节，但是 Go 语言所做的底层管理经过了很好的优化，同时有很多有趣的概念。</summary></entry></feed>