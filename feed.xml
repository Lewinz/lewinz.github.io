<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="https://lewinz.org/feed.xml" rel="self" type="application/atom+xml" /><link href="https://lewinz.org/" rel="alternate" type="text/html" /><updated>2021-06-06T20:51:41+08:00</updated><id>https://lewinz.org/feed.xml</id><title type="html">阿嫂</title><subtitle>阿嫂个人博客</subtitle><author><name>Lewin</name></author><entry><title type="html">MAC 地址与 IP 地址的区别</title><link href="https://lewinz.org/2021/06/06/mac-ip-address/" rel="alternate" type="text/html" title="MAC 地址与 IP 地址的区别" /><published>2021-06-06T00:00:00+08:00</published><updated>2021-06-06T00:00:00+08:00</updated><id>https://lewinz.org/2021/06/06/mac-ip-address</id><content type="html" xml:base="https://lewinz.org/2021/06/06/mac-ip-address/">&lt;h2 id=&quot;基础知识&quot;&gt;基础知识&lt;/h2&gt;

&lt;p&gt;如今的网络是分层来实现的，就像是搭积木一样，先设计某个特定功能的模块，然后把模块拼起来组成整个网络。局域网也不例外，一般来说，在组网上我们使用的是IEEE802参考模型，从下至上分为：&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%89%A9%E7%90%86%E5%B1%82&quot;&gt;物理层&lt;/a&gt;、&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6&quot;&gt;媒体接入控制层（MAC）&lt;/a&gt;，&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82&quot;&gt;逻辑链路控制层（LLC）&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;标识网络中的一台计算机，一般至少有三种方法，最常用的是&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D&quot;&gt;域名地址&lt;/a&gt;、&lt;a href=&quot;https://zh.wikipedia.org/wiki/IP%E5%9C%B0%E5%9D%80&quot;&gt;IP地址&lt;/a&gt;和&lt;a href=&quot;https://zh.wikipedia.org/wiki/MAC%E5%9C%B0%E5%9D%80&quot;&gt;MAC地址&lt;/a&gt;，分别对应&lt;strong&gt;应用层&lt;/strong&gt;、&lt;strong&gt;网络层&lt;/strong&gt;、&lt;strong&gt;物理层&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;网络管理一般就是在网络层针对IP地址进行管理，但由于一台计算机的IP地址可以由用户自行设定，管理起来相对困难，MAC地址一般不可更改，所以把IP地址同MAC地址组合到一起管理就成为常见的管理方式。&lt;/p&gt;

&lt;h2 id=&quot;什么是mac地址&quot;&gt;什么是MAC地址&lt;/h2&gt;
&lt;p&gt;MAC地址就是在媒体接入层上使用的地址，也叫&lt;strong&gt;物理地址&lt;/strong&gt;、&lt;strong&gt;硬件地址&lt;/strong&gt;或&lt;strong&gt;链路地址&lt;/strong&gt;，由网络设备制造商生产时写在硬件内部。&lt;/p&gt;

&lt;p&gt;MAC地址与网络无关，也即无论将带有这个地址的硬件（如网卡、集线器、路由器等）接入到网络的何处，都有相同的MAC地址，它由厂商写在网卡的BIOS里。&lt;/p&gt;

&lt;p&gt;MAC地址可采用6字节（48比特）或2字节（16比特）这两种中的任意一种。但随着局域网规模越来越大，一般都采用6字节的MAC地址。&lt;/p&gt;

&lt;p&gt;这个48比特都有其规定的意义，前24位是由生产网卡的厂商向IEEE申请的厂商地址，目前的价格是1000美元买一个地址块，后24位由厂商自行分配，这样的分配使得世界上任意一个拥有48位MAC 地址的网卡都有唯一的标识。另外，2字节的MAC地址不用网卡厂商申请。&lt;/p&gt;

&lt;p&gt;MAC地址通常表示为12个16进制数，每2个16进制数之间用冒号隔开。&lt;/p&gt;

&lt;p&gt;如：08:00:20:0A:8C:6D就是一个MAC地址&lt;/p&gt;

&lt;p&gt;其中前6位16进制数08:00:20代表网络硬件制造商的编号，它由IEEE分配，而后6位16进制数0A:8C:6D代表该制造商所制造的某个网络产品（如网卡）的系列号。每个网络制造商必须确保它所制造的每个以太网设备都具有相同的前三字节以及不同的后三个字节。这样就可保证世界上每个以太网设备都具有唯一的MAC 地址。&lt;/p&gt;

&lt;p&gt;这两种地址各有好处，使用时也因条件而采取不同的地址。&lt;/p&gt;

&lt;h2 id=&quot;mac地址的分类&quot;&gt;MAC地址的分类&lt;/h2&gt;
&lt;h3 id=&quot;从结构角度划分&quot;&gt;从结构角度划分&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;单播地址： 第一字节最低位为0，例：0==0==-e0-fc-00-00-06，也即 0000 000==0==-…&lt;/li&gt;
  &lt;li&gt;多播地址： 第一字节最低位为1，例：0==1==-e0-fc-00-00-06，也即 0000 000==1==-…&lt;/li&gt;
  &lt;li&gt;广播地址： 48bit位全为1，例：ff-ff-ff-ff-ff-ff，也即 11111111-…&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;也即如果第二个十六进制数为偶数就为单播地址，为奇数就为多播地址（同时非广播地址）。&lt;/p&gt;

&lt;p&gt;注：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;交换机对多播、广播地址不会进行学习。&lt;/li&gt;
  &lt;li&gt;普通设备网卡或者路由设备路由接口的MAC地址一定得是单播的MAC地址才能保证与其他设备的互通性。&lt;/li&gt;
  &lt;li&gt;MAC地址是一个以太网设备在网络上运行的基础，也是链路层功能实现的立足点。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;从功能角度划分&quot;&gt;从功能角度划分&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;静态MAC地址（Static MAC）&lt;br /&gt;
由用户通过shell命令或者snmp代理配置的静态转发的MAC地址，静态MAC地址和动态MAC地址的功能不同 ，静态地址一旦被加入，该地址在删除之前将一直有效，不受最大老化时间的限制。&lt;/li&gt;
  &lt;li&gt;动态MAC地址（Dynamic MAC）&lt;br /&gt;
由交换机从接受到报文自动学习到的MAC地址，当端口收到一个报文时，会查找报文的源MAC地址是否存 在于MAC地址表中，如果不存在则会将相应的端口、VLAN和源MAC地址关联起来，并保存到MAC地址表中， 动态MAC地址在达到一定老化时间后会被老化删除，但如果该地址在老化时间内被正确使用过，则会重新 激活该条地址的老化时间，同时MAC地址和端口的对应关系会随着设备所连的交换机的端口的变化而变化。&lt;/li&gt;
  &lt;li&gt;过滤MAC地址、黑洞MAC地址&lt;br /&gt;
由用户通过shell命令或者snmp代理配置的静态过滤的MAC地址，当网关接收到的报文中，源或者目的MAC 地址为过滤MAC地址，则直接丢弃该报文。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注：静态MAC优先于动态MAC，同时当两者计算出的哈希值一样时，静态MAC就会覆盖动态MAC。&lt;/p&gt;

&lt;h3 id=&quot;从传输角度划分&quot;&gt;从传输角度划分&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;SMAC： Source Mac、源MAC地址，报文的最初来源MAC地址。&lt;/li&gt;
  &lt;li&gt;DMAC： Destination Mac、目的MAC地址，报文的最终应该发往的MAC地址。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ip地址与mac地址的区别&quot;&gt;IP地址与MAC地址的区别&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;IP地址基于逻辑，比较灵活，不受硬件限制，也容易记忆。&lt;/li&gt;
  &lt;li&gt;MAC地址在一定程度上与硬件一致，基于物理，能够标识具体。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注：SMAC、DMAC指的不是静态、动态地址！&lt;/p&gt;

&lt;h2 id=&quot;为什么要用到mac地址&quot;&gt;为什么要用到MAC地址&lt;/h2&gt;
&lt;p&gt;这是由组网方式决定的，如今比较流行的接入Internet的方式（也是未来发展的方向）是把主机通过局域网组织在一起，然后再通过交换机和 Internet相连接。这样一来就出现了如何区分&lt;strong&gt;具体用户&lt;/strong&gt;，&lt;strong&gt;防止盗用&lt;/strong&gt;的问题。由于IP只是逻辑上标识，任何人都随意修改，因此不能用来标识用户；而 MAC地址则不然，它是固化在网卡里面的。从理论上讲，除非盗来硬件（网卡），否则是没有办法冒名顶替的（注意：其实也可以盗用，后面将介绍）。&lt;/p&gt;

&lt;p&gt;基于MAC地址的这种特点，局域网采用了用MAC地址来标识具体用户的方法。注意：具体实现：在交换机内部通过“表”的方式把MAC地址和IP地址一一对应，也就是所说的IP、MAC绑定。&lt;/p&gt;

&lt;p&gt;具体的通信方式：&lt;br /&gt;
接收过程，当有发给本地局域网内一台主机的数据包时，交换机接收下来，然后把数据包中的IP地址按照“表”中的对应关系映射成MAC地址，转发到对应的MAC地址的主机上，这样一来，即使某台主机盗用了这个IP地址，但由于他没有这个MAC地址，因此也不会收到数据包。发送过程和接收过程类似，限于篇幅不叙述。 &lt;br /&gt;
综上可知，只有IP而没有对应的MAC地址在这种局域网内是不能上网的，于是解决了IP盗用问题。&lt;/p&gt;

&lt;h2 id=&quot;mac地址涉及到的安全问题&quot;&gt;MAC地址涉及到的安全问题&lt;/h2&gt;
&lt;p&gt;从上面的介绍可以知道，这种标识方式只是MAC地址基于的，如果有人能够更改MAC地址，就可以盗用IP免费上网了，目前网上针对小区宽带的盗用MAC地址免费上网方式就是基于此这种思路。如果想盗用别人的IP地址，除了IP地址还要知道对应的MAC地址。&lt;/p&gt;

&lt;p&gt;举个例子，获得局域网内某台主机的MAC地址，比如想得到局域网内名为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;target&lt;/code&gt; 主机的MAC地址，先用PING命令：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ping target&lt;/code&gt;，这样在我们主机上面的ARP表的缓存中就会留下目标地址和MAC映射的记录，然后通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;arp a&lt;/code&gt; 命令来查询ARP表，这样就得到了指定主机的MAC地址。最后用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;arp -s ip&lt;/code&gt;网卡MAC地址，命令把网关的IP地址和它的MAC地址映射起来就可以了。&lt;/p&gt;

&lt;p&gt;如果要得到其它网段内的MAC地址，那么可以用工具软件来实现，我觉得&lt;strong&gt;Windows优化大师&lt;/strong&gt;中自带的工具不错，点击“系统性能优化”→“系统安全优化”→“附加工具”→“集群Ping”，可以成批的扫出MAC地址并可以保存到文件。&lt;/p&gt;

&lt;h3 id=&quot;小知识&quot;&gt;小知识&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE&quot;&gt;ARP(Address Resolution Protocol)&lt;/a&gt;是地址解析协议，ARP是一种将IP地址转化成物理地址的协议。从IP地址到物理地址的映射有两种方式：表格方式和非表格方式。ARP 具体说来就是将网络层（IP层，也就是相当于OSI的第三层）地址解析为数据连接层（MAC层，也就是相当于OSI的第二层）的MAC地址。ARP协议是通过IP地址来获得MAC地址的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ARP原理&lt;/strong&gt;：要向主机B发送报文，会查询本地的ARP缓存表，找到B的IP地址对应的MAC地址后就会进行数据传输。如果未找到，则广播A一个 ARP请求报文（携带主机A的IP地址Ia——物理地址Pa），请求IP地址为Ib的主机B回答物理地址Pb。网上所有主机包括B都收到ARP请求，但只有主机B识别自己的IP地址，于是向A主机发回一个ARP响应报文。其中就包含有B的MAC地址，A接收到B的应答后，就会更新本地的ARP缓存。接着使用这个MAC地址发送数据（由网卡附加MAC地址）。因此，本地高速缓存的这个ARP表是本地网络流通的基础，而且这个缓存是动态的。ARP表：为了回忆通信的速度，最近常用的MAC地址与IP的转换不用依靠交换机来进行，而是在本机上建立一个用来记录常用主机IP－MAC映射表，即ARP表。&lt;/p&gt;

&lt;h2 id=&quot;如何修改自己的mac地址&quot;&gt;如何修改自己的MAC地址&lt;/h2&gt;
&lt;p&gt;MAC地址是固化在网卡中的，MAC地址具有唯一性，难道没有办法更改了么？不是的，我们完全不用修改EPROM的内容，而只通过修改存储单元的内容就能达到修改MAC地址的目的。例如在Windows中可以通过注册表来修改。&lt;/p&gt;

&lt;p&gt;在“开始”菜单的“运行”中输入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;regedit.exe&lt;/code&gt;，打开注册表编辑器，展开注册表到：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Class\{4D36E972-E325-11CE-BFC1-08002BE10318}&lt;/code&gt;子键，在子键下的0000，0001，0002等分支中查找DriverDesc（如果你有一块以上的网卡，就有0001，0002……在这里保存了有关你的网卡的信息，其中的DriverDesc的内容就是你的网卡的信息描述，比如我的网卡就是Intel 21041 based Ethernet Controller），在这里假设你的网卡在0000子键。&lt;/p&gt;

&lt;p&gt;在0000子键下添加一个字符串，命名为“NetworkAddress”，键值为修改后的MAC地址，要求为连续的12个16进制数。然后在 “0000”子键下的NDI\params中新建一项名为NetworkAddress的子键，在该子键下添加名为“default”的字符串，键值为修改后的MAC地址。&lt;/p&gt;

&lt;p&gt;在NetworkAddress的子键下继续建立名为“ParamDesc”的字符串，其作用为指定NetworkAddress的描述，其值可为 “MAC Address”。这样以后打开网络邻居的“属性”，双击相应的网卡就会发现有一个“高级”设置，其下存在MAC Address的选项，它就是你在注册表中加入的新项NetworkAddress，以后只要在此修改MAC地址就可以了。&lt;/p&gt;

&lt;p&gt;关闭注册表，重新启动，你的网卡地址已改。打开网络邻居的属性，双击相应网卡项会发现有一个MAC Address的高级设置项，用于直接修改MAC地址。&lt;/p&gt;

&lt;h2 id=&quot;如何解决mac地址带来的安全性问题&quot;&gt;如何解决MAC地址带来的安全性问题&lt;/h2&gt;
&lt;p&gt;我们可以将IP地址和MAC地址捆绑起来来解决这个问题。进入“MS-DOS方式”或“命令提示符”，在命令提示符下输入命令：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ARP -s 10.88.56.72 00-10-5C-AD-72-E3&lt;/code&gt;，即可把MAC地址和IP地址捆绑在一起。这样，就不会出现IP地址被盗用而不能正常使用网络的情况，可以有效保证小区网络的安全和用户的应用。&lt;/p&gt;

&lt;p&gt;注意：ARP命令仅对局域网的上网代理(网络信息的中转站突破自身IP访问限制)服务器(文件传输协议支持FTP协议的服务器就是FTP服务器)有用，而且是针对静态IP地址，如果采用Modem拨号上网或是动态IP地址就不起作用。&lt;/p&gt;

&lt;p&gt;不过，只是简单地绑定IP和MAC地址是不能完全的解决IP盗用问题的。作为一个网络供应商，他们有责任为用户解决好这些问题之的后，才交给用户使用，而不是把安全问题交给用户来解决。不应该让用户来承担一些不必要盗用的损失。&lt;/p&gt;</content><author><name>Lewin</name></author><category term="MAC" /><category term="IP" /><summary type="html">基础知识</summary></entry><entry><title type="html">静态IP/动态IP/浮动IP/虚拟IP 的区别</title><link href="https://lewinz.org/2021/06/06/static-dynamic-floating-virtual-ip/" rel="alternate" type="text/html" title="静态IP/动态IP/浮动IP/虚拟IP 的区别" /><published>2021-06-06T00:00:00+08:00</published><updated>2021-06-06T00:00:00+08:00</updated><id>https://lewinz.org/2021/06/06/static-dynamic-floating-virtual-ip</id><content type="html" xml:base="https://lewinz.org/2021/06/06/static-dynamic-floating-virtual-ip/">&lt;h2 id=&quot;名词对应&quot;&gt;名词对应&lt;/h2&gt;
&lt;p&gt;static ip ==&amp;gt; 静态IP&lt;br /&gt;
dynamic ip ==&amp;gt; 动态IP&lt;br /&gt;
floating ip ==&amp;gt; 浮动IP&lt;br /&gt;
virtual ip ==&amp;gt; 虚拟IP&lt;/p&gt;

&lt;h2 id=&quot;区别&quot;&gt;区别&lt;/h2&gt;
&lt;h3 id=&quot;静态ip与动态ip&quot;&gt;静态IP与动态IP&lt;/h3&gt;
&lt;p&gt;static ip 就是固定分配的 ip，需要手工管理，非常麻烦。为了减少麻烦，人们发明了 dhcp 协议，来自动为电脑分配 ip，这就是 dynamic ip。&lt;/p&gt;

&lt;h3 id=&quot;浮动ip&quot;&gt;浮动IP&lt;/h3&gt;
&lt;p&gt;floating ip 跟 dynamic ip 有点像，参考各公有云厂商的弹性 ip。&lt;/p&gt;

&lt;h3 id=&quot;虚拟ip&quot;&gt;虚拟IP&lt;/h3&gt;
&lt;p&gt;但不论 static ip、dynamic ip 还是 floating ip，一个 ip 只能分配给一台电脑。&lt;br /&gt;
在有些情况（比如高可用场景）下我们需要多台电脑共用一个 ip，也就是说一个 ip 「属于」多台电脑。那怎么实现呢？是给两台电脑设置同一个 ip 吗？显然不是，因为为产生 ip 冲突。这就需要 virtual ip。&lt;br /&gt;
比如我们有两台服务器AAA和BBB，它们的 IP 分别是10.0.0.1和10.0.0.2。它们功能相同，提供相同的服务。理论上大家可以直接能过 10.0.0.1 或者 10.0.0.2 来访问 AAA 或 BBB 的服务。但如果某一台机器宕机，就没法访问了。要解决这个问题就需要 virtual ip。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/VIP_1.png&quot; alt=&quot;VIP_1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;首先，我们从 AAA 和 BBB 中选一个作主，另一个作备。然后要求它们互相探测，确保对方都在线。然后给AAA和BBB同时「分配」一个 virtual ip 10.0.0.100。其他主机需要通过 10.0.0.100 来访问 AAA 或 BBB 提供的服务。&lt;/p&gt;

&lt;p&gt;一般来说，其他主机要访问 10.0.0.100 需要通过 ARP 获取对应的 MAC 地址。如果 AAA 和 BBB 同时应答 ARP 请求，就会产生冲突。因为 10.0.0.100 是 virtual ip，所以，只有主服务器AAA才能应答。BBB 收到 ARP 请求后发现 AAA 还活着，就自动闭嘴。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/VIP_2.png&quot; alt=&quot;VIP_2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;之后所有访问 10.0.0.100 这个 virtual ip 的请求都会发到 AAA。&lt;/p&gt;

&lt;p&gt;如果 AAA 出现故障呢？这个时候其他主机发现 10.0.0.100 不通了，于是发出新的 ARP 请求&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/VIP_3.png&quot; alt=&quot;VIP_3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;同时，BBB 也探测不到 AAA，它知道自己的高光时刻来到了，于是 BBB 大声响应 ARP 请求说「向我开炮」。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/VIP_4.png&quot; alt=&quot;VIP_4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;总结下来，virtual ip 就是多主机设置相同 ip，但只有一台主机可以在特定条件下响应 arp 请求。&lt;/p&gt;

&lt;h2 id=&quot;浮动ip补充&quot;&gt;浮动IP补充&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;What is a floating IP?&lt;/code&gt;&lt;br /&gt;
什么是浮动IP&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;The internet – plainly put – consists of many computers connected by cables, fiber optic cables, and wireless receivers. They exchange data based on a common ‘language'. This common standard is known as the Internet Protocol (IP). Data is arranged in such a way that computers, which understand the common protocol, can interpret it.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;因特网简单来说说是许多计算机由电缆、光纤、无线接收器连接组成的网络。网络中设备间数据交互是通过IP协议进行，数据以IP封装其他计算根据协议才能解析数据。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;An IP address, also referred to as an 'IP', makes digital devices detectable in a network. It is a crucial prerequisite so that electronic data packets can be delivered reliably. The devices communicate with one another, for example, over the internet. The IP address ensures that data from the sender reaches the correct recipient – for example, from a web browser to a web server or vice versa. An IP address can be assigned to both single and multiple devices at the same time. Likewise, a single device can have multiple IP addresses at the same time.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;IP地址简称IP，数字设备以此作为身份标识，才能被其他设备发现和识别。IP地址是设备间交互数据的先决条件。IP地址保证数据的发送者发出的数据能正确到相应的接收者，反之也是如此。一个IP地址可分配多个设备，一个设备也可拥有多个IP。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;However, in order to be able to understand exactly what a floating IP is, you first need to know the difference between dynamic and static IP addresses.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;为了更好的弄明白什么是浮动IP，首先需要搞明静态IP和动态IP之间的区别。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dynamic IP&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;动态IP&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;When a computer connects to the internet, in most cases the Internet Service Provider (ISP) assigns a dynamic IP address to it. Dynamic IP addresses are the most cost-effective standard for users and providers. They are characterized by the fact that they are only assigned temporarily and change after a certain time, which is either fixed (e.g. for 24 hours), or is irregular. The user then receives a new dynamic IP address for their computer from the respective internet service provider and the previous address will then be signed to a different user.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;当一个计算机接入到互联网，网络服务接入商会分配一个动态IP给这台计算机。动态IP对用户和接入商来说都是最经济的。动态IP是不固定的，过一段时间会变。过一段时间用户的电脑会收到一个新的IP地址，原来的IP地址有可以已经分配给了别的电脑。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Static IP&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;静态IP&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A static IP, on the other hand, is a fixed address and is permanently assigned to a device. Static IP addresses are found mainly in the web server or e-mail server area, or wherever offers or website content must be accessible via a fixed URL , so that users or processes can (re)find them without any problems. Computers in a network or peripheral devices (such as printers) have fixed IPs, so that the individual devices within the network can easily communicate with one another.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;从一个方面来说，静态IP是 一个固定的IP地址，被永久的分配给一个设备。静态IP多用于Web服务器或者电子邮件服务器或者一个网站。这些网站通过一个固定的URL进行访问，用户可以通过URL找到IP地址。在一个网络中的计算机或者外围设备都有固定的IP，这样设备间才能很容易的交互数据。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;So that users don’t have to remember complex numbers, it’s possible to assign a domain name to a static IP address e.g. www.example.org. The numerical IP, the 'connection number' of a device in the network, is therefore translated into a name that can easily be remembered. This is generally only reserved for static IPs. It doesn’t make much sense for dynamic IPs since the user changes so frequently.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;给一个静态IP分配域名后，用户就不需要记住复杂的IP地址。使用域名IP地址被转成了容易记忆的名字。域名一般只用于静态IP，因动态IP频繁变动使用域名意义不大。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Floating IP – definition&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;浮动IP&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A floating IP is usually a public, routable IP address that is not automatically assigned to an entity. Instead, a project owner assigns them to one or more entities temporarily. The respective entity has an automatically assigned, static IP for communication between instances in a private, non-routable network area, as well as via a manually assigned floating IP. This makes the entity’s services outside a cloud or network recognizable and therefore achievable.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;一个浮动IP通常是一个公开的、可以路由到的IP地址，并且不会自动分配给实体设备。项目管理者临时分配动态IP到一个或者多个实体设备。这个实体设备有自动分配的静态IP用于内部网间设备的通讯。这个内部网使用私有地址，这些私有地址不能被路由到。通过浮动IP内网实体的服务才能被外网识别和访问。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;In appropriately configured failover scenarios, an IP 'floats' to another active unit in the network so that it can take on the function of a dormant entity without a time delay, and can then answer incoming requests.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在一个配置好浮点IP的切换场景是，IP地址飘到网络中的另一台设备。新设备无延迟的接替当掉的设备，并对外提供服务。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;How is a floating IP generated?&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;浮点IP是如何产生的？&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Users obtain floating IPs for their projects from different pools that the system administrator configures and provides as server resources. As soon as a user receives a floating IP, they become the 'owner'. They can assign it to an entity, remove it, and then assign it to another at any time. Even if an entity is terminated, the user does not 'lose' the associated floating IP. It remains as a resource and can still be assigned to another entity when needed.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用户从系统管理员配置的资源池中为他们的项目获取IP地址。一旦用户获取一个浮动IP，就拥有了这个IP。他可以分配这个IP到一个计算实体，或者在任一时间移除分配给其他设备。就算设备关机，用户还拥有他属于他的浮动IP。浮动IP就像一种资源，当需要时可以分配给其他设备。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A major reason for using several parallel floating IP pools is that each pool can be operated by another internet service provider or can also be assigned by other external networks. This ensures that the connectivity or availability is maintainable even if an internet service provider should fail due to a malfunction.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;使用多个平行的浮动IP主要是为了防止当其中的一个不可能用时使用其他地址以保证服务的正常可用。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;When are floating IPs used?&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;什么时候会用浮动IP&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Maximum availability is one of the key factors in every production environment. In the communication network, however, a single error can cause applications to fail. Developers do sleep better knowing that their applications are designed to withstand any conceivable error scenarios. The goal is to provide a highly available piece of infrastructure with minimal downtime.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;最大的可用性是浮动IP在生产环境中使用的一个关键因素。在网络中，单个错误可能会导致应用的不可用。如果系统能成功应对任何可以想到的应用场景，开发人员就可以安枕无忧。浮动IP的目标就最小当机下提供高可用的基础设施。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A floating IP can serve as a flexible load balancing address, helping to balance peak loads by distributing incoming network traffic to different network nodes. Network nodes are devices which connect two (or more) transmission paths of a telecommunication network. As with a computer that distributes workflows across multiple processors, load balancing also handles large amounts of simultaneous requests or more complex calculations by splitting the load across multiple parallel systems.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;浮动IP可以用于灵活的负载均衡地址，用于高峰时的负载均衡，分流访问流量到不同的网络节点。网络节点是连接到两个或者多个通讯网络。就像一台电脑分配工作流到不同的处理器，负载均衡大量并发的请求或者复杂的计算分配到并行系统中。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Failover and switchover&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;故障恢复和地址切换&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;If a primary load balancer or a central application server in a cluster fails on one side, a floating IP can be immediately assigned a redundant application server or a secondary load balancer in a correspondingly configured system. The IP 'floats' to the active unit, which immediately carries out the desired processes. An unplanned change between network services is referred to as 'failover'. This kind of protection is especially recommended for critical applications.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果一个主要的负载均衡器或者集群中一个主要的业务服务器当掉，浮动IP立即被分配到冗余的应用器或者备用的负载均衡器，这些都需要提前配置好。当浮动IP飘到一个活动单元，活动单元立即承担相应的业务。故障恢复指的是非计划的网络服务切换。这种特别的保护推荐用于关键应用。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A planned change from a primary to a secondary system is referred to as a 'switchover'. The targeted transmission of services is not triggered by errors, but is usually controlled by a system administrator. A classic reason for a switchover is, for example, routine maintenance of the primary or secondary systems where a parallel instance temporarily takes over its function.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;一个有计划的从主切换到从，通常被称为切换。切换不是由故障或者错误引起，而是系统管理员操作完成。切换的典型应用场景时，当对一个系统时行例常的维护时，由另一服务接替他的功能。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;What advantages does a floating IP offer?&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;浮动IP优点&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;One of the main advantages of floating IPs is their flexibility – the free and needs-oriented assignability. Floating IPs are therefore suitable for use in both failover and switchover environments – for example, for performing upgrades of applications or entire sites with minimal downtime. While an upgrade is applied to one entity, another one takes on the traffic. Once the upgrade has been successfully completed, the traffic is redirected to the updated unit.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;浮动IP的主要优点是灵活，自由的根据需要分配。浮动IP即适用于故障恢复又适用于服务切换。比如对某个应用或者整个站点的升级，并能保证对业务有最小的影响。当对一个应用升级时，另一个应用分配输入流量。一旦升级完成，流量会被重新导入到升级节点。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Another advantage: even if several or even many different entities are concealed behind a service being offered, the floating IP appears on the surface to users (who make use of the service) rather than the server’s IP that offers the respective service.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;另一个优点是：浮动IP对外提供统一的IP，而不是实际对外提供服务的IP地址。&lt;/p&gt;</content><author><name>Lewin</name></author><category term="静态IP" /><category term="动态IP" /><category term="浮动IP" /><category term="虚拟IP" /><summary type="html">名词对应 static ip ==&amp;gt; 静态IP dynamic ip ==&amp;gt; 动态IP floating ip ==&amp;gt; 浮动IP virtual ip ==&amp;gt; 虚拟IP</summary></entry><entry><title type="html">MySQL聚集索引和非聚集索引</title><link href="https://lewinz.org/2021/05/30/mysql-clustered-index/" rel="alternate" type="text/html" title="MySQL聚集索引和非聚集索引" /><published>2021-05-30T00:00:00+08:00</published><updated>2021-05-30T00:00:00+08:00</updated><id>https://lewinz.org/2021/05/30/mysql-clustered-index</id><content type="html" xml:base="https://lewinz.org/2021/05/30/mysql-clustered-index/">&lt;h2 id=&quot;聚集索引&quot;&gt;聚集索引&lt;/h2&gt;
&lt;p&gt;聚集索引是指数据库表行中数据的物理顺序与键值的逻辑（索引）顺序相同。一个表只能有一个聚集索引，因为一个表的物理顺序只有一种情况，所以，对应的聚集索引只能有一个。如果某索引不是聚集索引，则表中的行物理顺序与索引顺序不匹配，与非聚集索引相比，聚集索引有着更快的检索速度。&lt;/p&gt;

&lt;h2 id=&quot;mysql-聚集索引和非聚集索引&quot;&gt;MySQL 聚集索引和非聚集索引&lt;/h2&gt;

&lt;p&gt;MySQL 的 Innodb 存储引擎的索引分为聚集索引和非聚集索引两大类，理解聚集索引和非聚集索引可通过对比汉语字典的索引。汉语字典提供了两类检索汉字的方式，第一类是拼音检索（前提是知道该汉字读音），比如拼音为cheng的汉字排在拼音chang的汉字后面，根据拼音找到对应汉字的页码（因为按拼音排序，二分查找很快就能定位），这就是我们通常所说的字典序；第二类是部首笔画检索，根据笔画找到对应汉字，查到汉字对应的页码。拼音检索就是聚集索引，因为存储的记录（数据库中是行数据、字典中是汉字的详情记录）是按照该索引排序的；笔画索引，虽然笔画相同的字在笔画索引中相邻，但是实际存储页码却不相邻。&lt;/p&gt;

&lt;p&gt;正文内容按照一个特定维度排序存储，这个特定的维度就是聚集索引；&lt;/p&gt;

&lt;p&gt;Innodb 存储引擎中行记录就是按照聚集索引维度顺序存储的，Innodb 的表也称为索引表；因为行记录只能按照一个维度进行排序，所以一张表只能有一个聚集索引。&lt;/p&gt;

&lt;p&gt;非聚集索引索引项顺序存储，但索引项对应的内容却是随机存储的；&lt;/p&gt;

&lt;p&gt;举个例子说明下：&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;student&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;`id`&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;INT&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;UNSIGNED&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AUTO_INCREMENT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;`name`&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;VARCHAR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;255&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;PRIMARY&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`id`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`name`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ENGINE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InnoDB&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CHARSET&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;utf8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;该表中主键id是该表的聚集索引、name为非聚集索引；表中的每行数据都是按照聚集索引id排序存储的；比如要查找name=’Arla’和name=’Arle’的两个同学，他们在name索引表中位置可能是相邻的，但是实际存储位置可能差的很远。&lt;strong&gt;name索引表节点按照name排序，检索的是每一行数据的主键。聚集索引表按照主键id排序，检索的是每一行数据的真实内容。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;也就是说查询 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name='Arle'&lt;/code&gt; 的记录时，首相通过 name 索引表查找到 Arle 的主键 id （可能有多个主键 id ，因为有重名的同学），再根据主键id的聚集索引找到相应的行记录；&lt;/p&gt;

&lt;p&gt;聚集索引一般是表中的主键索引，如果表中没有显示指定主键，则会选择表中的第一个不允许为 NULL 的唯一索引，如果还是没有的话，就采用 Innodb 存储引擎为每行数据内置的6字节 ROWID 作为聚集索引。&lt;/p&gt;

&lt;p&gt;每张表只有一个聚集索引，因为聚集索引在精确查找和范围查找方面良好的性能表现（相比于普通索引和全表扫描），聚集索引就显得弥足珍贵，聚集索引选择还是要慎重的（一般不会让没有语义的自增id充当聚集索引）。&lt;/p&gt;

&lt;p&gt;从宏观上分析下聚集索引和普通索引的性能差异，还是针对上述student表：&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;student&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5000&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;student&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Alie'&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'John'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;第一条SQL语句根据id进行范围查询，因为(5000, 20000)范围内的记录在磁盘上按顺序存储，顺序读取磁盘很快就能读到这批数据。&lt;/p&gt;

&lt;p&gt;第二条SQL语句查询（’Alie’, ‘John’）范围内的记录，主键id分布可能是离散的1，100，20001，5000…..；增加了随机读取数据页几率；所以普通索引的范围查询效率被聚集索引甩开几条街都不止；非聚集索引的精确查询效率还是可以的，比聚集索引查询只增加了一次IO开销。&lt;/p&gt;

&lt;h2 id=&quot;本文中提到的索引都是以b-tree组织的&quot;&gt;本文中提到的索引都是以B+ tree组织的&lt;/h2&gt;</content><author><name>Lewin</name></author><category term="MySQL" /><category term="索引" /><category term="聚集索引" /><category term="非聚集索引" /><summary type="html">聚集索引 聚集索引是指数据库表行中数据的物理顺序与键值的逻辑（索引）顺序相同。一个表只能有一个聚集索引，因为一个表的物理顺序只有一种情况，所以，对应的聚集索引只能有一个。如果某索引不是聚集索引，则表中的行物理顺序与索引顺序不匹配，与非聚集索引相比，聚集索引有着更快的检索速度。</summary></entry><entry><title type="html">开源协议</title><link href="https://lewinz.org/2021/05/30/open-source-licenses/" rel="alternate" type="text/html" title="开源协议" /><published>2021-05-30T00:00:00+08:00</published><updated>2021-05-30T00:00:00+08:00</updated><id>https://lewinz.org/2021/05/30/open-source-licenses</id><content type="html" xml:base="https://lewinz.org/2021/05/30/open-source-licenses/">&lt;h2 id=&quot;开源协议是什么&quot;&gt;开源协议是什么&lt;/h2&gt;
&lt;p&gt;开源软件在追求“自由”的同时，不能牺牲程序员的利益，否则将会影响程序员的创造激情，因此世界上现在有 60 多种被开源促进组织（Open Source Initiative）认可的开源许可协议来保证开源工作者的权益。&lt;/p&gt;

&lt;p&gt;开源协议规定了你在使用开源软件时的权利和责任，也就是规定了你可以做什么，不可以做什么。&lt;/p&gt;

&lt;p&gt;开源协议虽然不一定具备法律效力，但是当涉及软件版权纠纷时，开源协议也是非常重要的证据之一。&lt;/p&gt;

&lt;p&gt;对于准备编写一款开源软件的开发人员，也非常建议先了解一下当前最热门的开源许可协议，选择一个合适的开源许可协议来最大限度保护自己的软件权益。&lt;/p&gt;

&lt;h3 id=&quot;gnu-gpl&quot;&gt;GNU GPL&lt;/h3&gt;
&lt;p&gt;GNU GPL（GNU General Public License，GNU通用公共许可证）&lt;/p&gt;

&lt;p&gt;只要软件中包含了遵循 GPL 协议的产品或代码，该软件就必须也遵循 GPL 许可协议，也就是必须开源免费，不能闭源收费，因此这个协议并不适合商用软件。&lt;/p&gt;

&lt;p&gt;遵循 GPL 协议的开源软件数量极其庞大，包括 Linux 系统在内的大多数的开源软件都是基于这个协议的。&lt;/p&gt;

&lt;h4 id=&quot;特点&quot;&gt;特点&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;复制自由	允许把软件复制到任何人的电脑中，并且不限制复制的数量。&lt;/li&gt;
  &lt;li&gt;传播自由	允许软件以各种形式进行传播。&lt;/li&gt;
  &lt;li&gt;收费传播	允许在各种媒介上出售该软件，但必须提前让买家知道这个软件是可以免费获得的；因此，一般来讲，开源软件都是通过为用户提供有偿服务的形式来盈利的。&lt;/li&gt;
  &lt;li&gt;修改自由	允许开发人员增加或删除软件的功能，但软件修改后必须依然基于GPL许可协议授权。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;bsd&quot;&gt;BSD&lt;/h3&gt;
&lt;p&gt;BSD（Berkeley Software Distribution，伯克利软件发布版）协议&lt;/p&gt;

&lt;p&gt;BSD 协议基本上允许用户“为所欲为”，用户可以使用、修改和重新发布遵循该许可的软件，并且可以将软件作为商业软件发布和销售，前提是需要满足下面三个条件：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;如果再发布的软件中包含源代码，则源代码必须继续遵循 BSD 许可协议。&lt;/li&gt;
  &lt;li&gt;如果再发布的软件中只有二进制程序，则需要在相关文档或版权文件中声明原始代码遵循了 BSD 协议。&lt;/li&gt;
  &lt;li&gt;不允许用原始软件的名字、作者名字或机构名称进行市场推广。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;BSD 对商业比较友好，很多公司在选用开源产品的时候都首选 BSD 协议，因为可以完全控制这些第三方的代码，甚至在必要的时候可以修改或者二次开发。&lt;/p&gt;

&lt;h3 id=&quot;apache&quot;&gt;Apache&lt;/h3&gt;
&lt;p&gt;Apache 许可证版本（Apache License Version）协议&lt;/p&gt;

&lt;p&gt;Apache 和 BSD 类似，都适用于商业软件。Apache 协议在为开发人员提供版权及专利许可的同时，允许用户拥有修改代码及再发布的自由。&lt;/p&gt;

&lt;p&gt;现在热门的 &lt;strong&gt;Hadoop&lt;/strong&gt; 、&lt;strong&gt;Apache HTTP Server&lt;/strong&gt;、&lt;strong&gt;MongoDB&lt;/strong&gt; 等项目都是基于该许可协议研发的，程序开发人员在开发遵循该协议的软件时，要严格遵守下面的四个条件：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;该软件及其衍生品必须继续使用 Apache 许可协议。&lt;/li&gt;
  &lt;li&gt;如果修改了程序源代码，需要在文档中进行声明。&lt;/li&gt;
  &lt;li&gt;若软件是基于他人的源代码编写而成的，则需要保留原始代码的协议、商标、专利声明及其他原作者声明的内容信息。&lt;/li&gt;
  &lt;li&gt;如果再发布的软件中有声明文件，则需在此文件中标注 Apache 许可协议及其他许可协议。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;mit&quot;&gt;MIT&lt;/h3&gt;
&lt;p&gt;MIT（Massachusetts Institute of Technology）协议&lt;/p&gt;

&lt;p&gt;目前限制最少的开源许可协议之一（比 BSD 和 Apache 的限制都少），只要程序的开发者在修改后的源代码中保留原作者的许可信息即可，因此普遍被商业软件所使用。&lt;/p&gt;

&lt;p&gt;使用 MIT 协议的软件有 PuTTY、X Window System、Ruby on Rails、Lua 5.0 onwards、Mono 等。&lt;/p&gt;

&lt;h3 id=&quot;gun-lgpl&quot;&gt;GUN LGPL&lt;/h3&gt;
&lt;p&gt;GUN LGPL（GNU Lesser General Public License，GNU 宽通用公共许可证）&lt;/p&gt;

&lt;p&gt;LGPL 是 GPL 的一个衍生版本，也被称为 GPL V2，该协议主要是为类库设计的开源协议。&lt;/p&gt;

&lt;p&gt;LGPL 允许商业软件通过类库引用（link）的方式使用 LGPL 类库，而不需要开源商业软件的代码。这使得采用 LGPL 协议的开源代码可以被商业软件作为类库引用并发布和销售。&lt;/p&gt;

&lt;p&gt;但是如果修改 LGPL 协议的代码或者衍生品，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用 LGPL 协议。因此LGPL协议的开源代码很适合作为第三方类库被商业软件引用，但不适合希望以 LGPL 协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。&lt;/p&gt;

&lt;h2 id=&quot;如何选择开源协议&quot;&gt;如何选择开源协议&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/open_source_licenses.jpeg&quot; alt=&quot;open_source_licenses&quot; /&gt;&lt;/p&gt;</content><author><name>Lewin</name></author><category term="开源协议" /><summary type="html">开源协议是什么 开源软件在追求“自由”的同时，不能牺牲程序员的利益，否则将会影响程序员的创造激情，因此世界上现在有 60 多种被开源促进组织（Open Source Initiative）认可的开源许可协议来保证开源工作者的权益。</summary></entry><entry><title type="html">Prometheus 监控系统</title><link href="https://lewinz.org/2021/05/30/prometheus-info/" rel="alternate" type="text/html" title="Prometheus 监控系统" /><published>2021-05-30T00:00:00+08:00</published><updated>2021-05-30T00:00:00+08:00</updated><id>https://lewinz.org/2021/05/30/prometheus-info</id><content type="html" xml:base="https://lewinz.org/2021/05/30/prometheus-info/">&lt;h2 id=&quot;普罗米修斯prometheus&quot;&gt;普罗米修斯(Prometheus)&lt;/h2&gt;
&lt;p&gt;普罗米修斯(Prometheus)是一个SoundCloud公司开源的监控系统。当年，由于SoundCloud公司生产了太多的服务，传统的监控已经无法满足监控需求，于是他们在2012年决定着手开发新的监控系统，即普罗米修斯。&lt;/p&gt;

&lt;p&gt;普罗米修斯（下称普罗）的作者 Matt T.Proud 在2012年加入SoundCloud公司，他从google的监控系统Borgmon中获得灵感，与另一名工程师Julius Volz合作开发了开源的普罗，后来其他开发人员陆续加入到该项目，最终于2015年正式发布。&lt;/p&gt;

&lt;p&gt;普罗基于Go语言开发，其架构图如下：
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/prometheus.jpeg&quot; alt=&quot;image_prometheus&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Prometheus Server: 用数据的采集和存储，PromQL查询，报警配置。&lt;/li&gt;
  &lt;li&gt;Push gateway: 用于批量，短期的监控数据的汇报总节点。&lt;/li&gt;
  &lt;li&gt;Exporters: 各种汇报数据的exporter，例如汇报机器数据的node_exporter，汇报MondogDB信息的 MongoDB_exporter 等等。&lt;/li&gt;
  &lt;li&gt;Alertmanager: 用于高级通知管理。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;采集监控数据&quot;&gt;采集监控数据&lt;/h2&gt;
&lt;p&gt;要采集目标（主机或服务）的监控数据，首先就要在被采集目标上安装采集组件，这种采集组件被称为 &lt;strong&gt;Exporter&lt;/strong&gt; 。&lt;a href=&quot;http://prometheus.io&quot;&gt;普罗米修斯&lt;/a&gt; 官网上有很多这种 exporter ，比如：&lt;/p&gt;

&lt;p&gt;Consul exporter (official)&lt;br /&gt;
Memcached exporter (official)&lt;br /&gt;
MySQL server exporter (official)&lt;br /&gt;
Node/system metrics exporter (official)&lt;br /&gt;
HAProxy exporter (official)&lt;br /&gt;
RabbitMQ exporter&lt;br /&gt;
Grok exporter&lt;br /&gt;
InfluxDB exporter (official)&lt;/p&gt;

&lt;p&gt;这些exporter能为我们采集目标的监控数据，然后传输给普罗米修斯。这时候，exporter会暴露一个http接口，普罗米修斯通过HTTP协议使用Pull的方式周期性拉取相应的数据。&lt;/p&gt;

&lt;p&gt;不过，普罗也提供了Push模式来进行数据传输，通过增加Push Gateway这个中间商实现，你可以将数据推送到Push Gateway，普罗再通过Pull的方式从Push Gateway获取数据。&lt;/p&gt;

&lt;p&gt;这就是为什么你从架构图里能看到两个 Pull metrics 的原因，一个是采集器直接被Server拉取数据(pull)；另一个是采集器主动Push数据到Push Gateway，Server再对Push Gateway主动拉取数据(pull)。&lt;/p&gt;

&lt;h3 id=&quot;采集数据的主要流程&quot;&gt;采集数据的主要流程&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Prometheus server 定期从静态配置的主机或服务发现的 targets 拉取数据（zookeeper，consul，DNS SRV Lookup等方式）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当新拉取的数据大于配置内存缓存区的时候，Prometheus会将数据持久化到磁盘，也可以远程持久化到云端。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Prometheus通过PromQL、API、Console和其他可视化组件如Grafana、Promdash展示数据。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Prometheus 可以配置rules，然后定时查询数据，当条件触发的时候，会将告警推送到配置的Alertmanager。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Alertmanager收到告警的时候，会根据配置，聚合，去重，降噪，最后发出警告。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;采集的数据结构与指标类型&quot;&gt;采集的数据结构与指标类型&lt;/h3&gt;
&lt;h4 id=&quot;数据结构&quot;&gt;数据结构&lt;/h4&gt;
&lt;p&gt;了解普罗米修斯的数据结构对于了解整个普罗生态非常重要。普罗采用键值对作为其基本的数据结构：
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/prometheus_matadata.jpeg&quot; alt=&quot;image_prometheus_matadata&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Key是指标名字，Value是该指标的值，此外Metadata(元信息)也非常重要，也可称之为labels(标签信息)。这些标签信息指定了当前这个值属于哪个云区域下的哪台机器，如果没有labels，数据有可能会被丢失。&lt;/p&gt;

&lt;h4 id=&quot;指标类型&quot;&gt;指标类型&lt;/h4&gt;
&lt;p&gt;普罗米修斯的监控指标有4种基本类型：&lt;/p&gt;

&lt;h5 id=&quot;counter计数器&quot;&gt;Counter(计数器)&lt;/h5&gt;
&lt;p&gt;计数器是我们最简单的指标类型。比如你想统计某个网站的HTTP错误总数，这时候就用计数器。&lt;/p&gt;

&lt;p&gt;计数器的值只能增加或重置为0，因此特别适合计算某个时段上某个时间的发生次数，即指标随时间演变发生的变化。&lt;/p&gt;

&lt;h5 id=&quot;gauges&quot;&gt;Gauges&lt;/h5&gt;

&lt;p&gt;Gauges可以用于处理随时间增加或减少的指标，比如内存变化、温度变化。&lt;/p&gt;

&lt;p&gt;这可能是最常见的指标类型，不过它也有一定&lt;strong&gt;缺点&lt;/strong&gt;：如果系统每5秒发送一次指标，普罗服务每15秒抓取一次数据，那么这期间可能会丢失一些指标，如果你基于这些数据做汇总分析计算，则结果的准确性会有所下滑。&lt;/p&gt;

&lt;h5 id=&quot;histogram直方图&quot;&gt;Histogram(直方图)&lt;/h5&gt;

&lt;p&gt;直方图是一种更复杂的度量标准类型。它为我们的指标提供了额外信息，例如观察值的总和及其数量，常用于跟踪事件发生的规模。&lt;/p&gt;

&lt;p&gt;比如，为了监控性能指标，我们希望在有20%的服务器请求响应时间超过300毫秒时发送告警。对于涉及比例的指标就可以考虑使用直方图。&lt;/p&gt;

&lt;h5 id=&quot;summary摘要&quot;&gt;Summary(摘要)&lt;/h5&gt;

&lt;p&gt;摘要更高级一些，是对直方图的扩展。除了提供观察的总和和计数之外，它们还提供滑动窗口上的分位数度量。分位数是将概率密度划分为相等概率范围的方法。&lt;/p&gt;

&lt;p&gt;对比直方图：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;直方图随时间汇总值，给出总和和计数函数，使得易于查看给定指标的变化趋势。&lt;/li&gt;
  &lt;li&gt;而摘要则给出了滑动窗口上的分位数（即随时间不断变化）。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;实例概念&quot;&gt;实例概念&lt;/h3&gt;

&lt;p&gt;随着分布式架构的不断发展和云解决方案的普及，现在的架构已经变得越来越复杂了。&lt;/p&gt;

&lt;p&gt;分布式的服务器复制和分发成了日常架构的必备组件。我们举一个经典的Web架构，该架构由3个后端Web服务器组成。在该例子中，我们要监视Web服务器返回的HTTP错误的数量。&lt;/p&gt;

&lt;p&gt;使用普罗米修斯语言，单个Web服务器单元称为实例（主机实例）。该任务是计算所有实例的HTTP错误数量。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/prometheus_instance.jpeg&quot; alt=&quot;image_prometheus_instance&quot; /&gt;&lt;/p&gt;

&lt;p&gt;事实上，这甚至可以说是最简单的架构了，再复杂一点，实例不仅能是主机实例，还能是服务实例，因此你需要增加一个instance_type的标签标记主机或服务。&lt;/p&gt;

&lt;p&gt;再再复杂一点，同样的IP，可能存在于不同云区域下，这属于不同的机器，因此还需要一个cloud标签，最终该数据结构可能会变为：&lt;/p&gt;

&lt;p&gt;cpu_usage {job=”1”, instance=”128.0.0.1”, cloud=”0”, instance_type=”0”}&lt;/p&gt;

&lt;h3 id=&quot;数据可视化&quot;&gt;数据可视化&lt;/h3&gt;

&lt;p&gt;如果使用过基于InfluxDB的数据库，你可能会熟悉InfluxQL。普罗米修斯也内置了自己的SQL查询语言用于查询和检索数据，这个内置的语言就是PromQL。&lt;/p&gt;

&lt;p&gt;我们前面说过，普罗米修斯的数据是用键值对表示的。PromQL也用相同的语法查询和返回结果集。&lt;/p&gt;

&lt;p&gt;PromQL会处理两种向量：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;即时向量：表示当前时间，某个指标的数据向量。&lt;/li&gt;
  &lt;li&gt;时间范围向量：表示过去某时间范围内，某个指标的数据向量。&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Lewin</name></author><category term="Prometheus" /><category term="监控" /><summary type="html">普罗米修斯(Prometheus) 普罗米修斯(Prometheus)是一个SoundCloud公司开源的监控系统。当年，由于SoundCloud公司生产了太多的服务，传统的监控已经无法满足监控需求，于是他们在2012年决定着手开发新的监控系统，即普罗米修斯。</summary></entry><entry><title type="html">时间序列数据库（TSDB）</title><link href="https://lewinz.org/2021/05/30/time-series-database/" rel="alternate" type="text/html" title="时间序列数据库（TSDB）" /><published>2021-05-30T00:00:00+08:00</published><updated>2021-05-30T00:00:00+08:00</updated><id>https://lewinz.org/2021/05/30/time-series-database</id><content type="html" xml:base="https://lewinz.org/2021/05/30/time-series-database/">&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;2017年时序数据库忽然火了起来。开年2月Facebook开源了beringei时序数据库；到了4月基于PostgreSQL打造的时序数据库TimeScaleDB也开源了，而早在2016年7月，百度云在其天工物联网平台上发布了国内首个多租户的分布式时序数据库产品TSDB，成为支持其发展制造，交通，能源，智慧城市等产业领域的核心产品，同时也成为百度战略发展产业物联网的标志性事件。&lt;/p&gt;

&lt;h2 id=&quot;时间序列数据库-time-series-database-tsdb&quot;&gt;时间序列数据库 Time Series Database (TSDB)&lt;/h2&gt;
&lt;p&gt;随着分布式系统监控、物联网的发展，TSDB开始受到更多的关注。
维基百科上对于时间序列的定义是‘一系列数据点按照时间顺序排列’&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;时间序列数据就是历史烙印，具有不变性,、唯一性、时间排序性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;时间序列数据跟关系型数据库有太多不同，但是很多公司并不想放弃关系型数据库。 于是就产生了一些特殊的用法，比如用 &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//www.vividcortex.com/blog/2014/12/16/in-case-you-missed-it-building-a-time-series-database-in-mysql/&quot;&gt;MySQL 的 VividCortex&lt;/a&gt;, 用 &lt;a href=&quot;http://link.zhihu.com/?target=http%3A//www.timescale.com/&quot;&gt;Postgres 的 Timescale&lt;/a&gt;。 很多人觉得特殊的问题需要特殊的解决方法，于是很多时间序列数据库从头写起，不依赖任何现有的数据库, 比如 Graphite，InfluxDB。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;mysql 的引擎，除了常见的 innodb 和 myisam ，还有一个引擎叫 archive ，它的作用和 rrd 差不多，支持插入和查询操作。&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;时序数据是基于时间的一系列的数据。在有时间的坐标中将这些数据点连成线，往过去看可以做成多纬度报表，揭示其趋势性、规律性、异常性；往未来看可以做大数据分析，机器学习，实现预测和预警。&lt;/li&gt;
  &lt;li&gt;时序数据库就是存放时序数据的数据库，并且需要支持时序数据的快速写入、持久化、多纬度的聚合查询等基本功能。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;数据写入的特点&quot;&gt;数据写入的特点&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;写入平稳、持续、高并发高吞吐：时序数据的写入是比较平稳的，这点与应用数据不同，应用数据通常与应用的访问量成正比，而应用的访问量通常存在波峰波谷。时序数据的产生通常是以一个固定的时间频率产生，不会受其他因素的制约，其数据生成的速度是相对比较平稳的。&lt;/li&gt;
  &lt;li&gt;写多读少：时序数据上95%-99%的操作都是写操作，是典型的写多读少的数据。这与其数据特性相关，例如监控数据，你的监控项可能很多，但是你真正去读的可能比较少，通常只会关心几个特定的关键指标或者在特定的场景下才会去读数据。&lt;/li&gt;
  &lt;li&gt;实时写入最近生成的数据，无更新：时序数据的写入是实时的，且每次写入都是最近生成的数据，这与其数据生成的特点相关，因为其数据生成是随着时间推进的，而新生成的数据会实时的进行写入。数据写入无更新，在时间这个维度上，随着时间的推进，每次数据都是新数据，不会存在旧数据的更新，不过不排除人为的对数据做订正。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;数据查询和分析的特点&quot;&gt;数据查询和分析的特点&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;按时间范围读取：通常来说，你不会去关心某个特定点的数据，而是一段时间的数据。&lt;/li&gt;
  &lt;li&gt;最近的数据被读取的概率高&lt;/li&gt;
  &lt;li&gt;历史数据粗粒度查询的概率搞&lt;/li&gt;
  &lt;li&gt;多种精度查询&lt;/li&gt;
  &lt;li&gt;多维度分析&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;数据存储的特点&quot;&gt;数据存储的特点&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;数据量大：拿监控数据来举例，如果我们采集的监控数据的时间间隔是1s，那一个监控项每天会产生86400个数据点，若有10000个监控项，则一天就会产生864000000个数据点。在物联网场景下，这个数字会更大。整个数据的规模，是TB甚至是PB级的。&lt;/li&gt;
  &lt;li&gt;冷热分明：时序数据有非常典型的冷热特征，越是历史的数据，被查询和分析的概率越低。&lt;/li&gt;
  &lt;li&gt;具有时效性：时序数据具有时效性，数据通常会有一个保存周期，超过这个保存周期的数据可以认为是失效的，可以被回收。一方面是因为越是历史的数据，可利用的价值越低；另一方面是为了节省存储成本，低价值的数据可以被清理。&lt;/li&gt;
  &lt;li&gt;多精度数据存储：在查询的特点里提到时序数据出于存储成本和查询效率的考虑，会需要一个多精度的查询，同样也需要一个多精度数据的存储。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;开源时间序列数据库&quot;&gt;开源时间序列数据库&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;1999/07/16 &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/RRDtool&quot;&gt;RRDTool First release&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;2009/12/30 &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/graphite-project/graphite-web/releases/tag/0.9.5&quot;&gt;Graphite 0.9.5&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;2011/12/23 &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/OpenTSDB/opentsdb/releases/tag/v1.0.0&quot;&gt;OpenTSDB 1.0.0&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;2013/05/24 &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/kairosdb/kairosdb/releases/tag/v1.0.0-beta2a&quot;&gt;KairosDB 1.0.0-beta&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;2013/10/24 &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/influxdata/influxdb/releases/tag/v0.0.1&quot;&gt;InfluxDB 0.0.1&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;2014/08/25 &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/spotify/heroic/releases/tag/0.3.0&quot;&gt;Heroic 0.3.0&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;2017/03/27 &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/timescale/timescaledb/releases/tag/0.0.1-beta&quot;&gt;TimescaleDB 0.0.1-beta&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//oss.oetiker.ch/rrdtool/&quot;&gt;RRDTool&lt;/a&gt; 是最早的时间序列数据库，它自带画图功能，现在大部分时间序列数据库都使用 &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/grafana/grafana&quot;&gt;Grafana&lt;/a&gt; 来画图。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//graphiteapp.org/&quot;&gt;Graphite&lt;/a&gt; 是用 Python 写的 RRD 数据库，它的存储引擎 &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/graphite-project/whisper&quot;&gt;Whisper&lt;/a&gt; 也是 Python 写的， 它画图和聚合能力都强了很多，但是很难水平扩展。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//opentsdb.net/&quot;&gt;OpenTSDB&lt;/a&gt; 使用 HBase 解决了水平扩展的问题&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//kairosdb.github.io/&quot;&gt;KairosDB&lt;/a&gt; 最初是基于OpenTSDB修改的，但是作者认为兼容HBase导致他们不能使用很多 Cassandra 独有的特性， 于是就抛弃了HBase仅支持Cassandra。&lt;/p&gt;

&lt;p&gt;新发布的 &lt;a href=&quot;http://link.zhihu.com/?target=http%3A//opentsdb.net/docs/build/html/new.html&quot;&gt;OpenTSDB&lt;/a&gt; 中也加入了对 Cassandra 的支持。 故事还没完，Spotify 的人本来想使用 KairosDB，但是觉得项目发展方向不对以及性能太差，就自己撸了一个 Heroic。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/influxdata/influxdb&quot;&gt;InfluxDB&lt;/a&gt; 早期是完全开源的，后来为了维持公司运营，闭源了集群版本。 在 Percona Live 上他们做了一个开源数据库商业模型正面临危机的演讲，里面调侃红帽的段子很不错。 并且今年的 Percona Live 还有专门的时间序列数据库单元。&lt;/p&gt;

&lt;h3 id=&quot;数据模型&quot;&gt;数据模型&lt;/h3&gt;
&lt;p&gt;时间序列数据可以分成两部分&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;序列 ：就是标识符（维度），主要的目的是方便进行搜索和筛选&lt;/li&gt;
  &lt;li&gt;数据点：时间戳和数值构成的数组
    &lt;ul&gt;
      &lt;li&gt;行存：一个数组包含多个点，如 [{t: 2017-09-03-21:24:44, v: 0.1002}, {t: 2017-09-03-21:24:45, v: 0.1012}]&lt;/li&gt;
      &lt;li&gt;列存：两个数组，一个存时间戳，一个存数值，如[ 2017-09-03-21:24:44, 2017-09-03-21:24:45], [0.1002, 0.1012]&lt;br /&gt;
一般情况下：列存能有更好的压缩率和查询性能&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;基本概念&quot;&gt;基本概念&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;metric: 度量，相当于关系型数据库中的table。&lt;/li&gt;
  &lt;li&gt;data point: 数据点，相当于关系型数据库中的row。&lt;/li&gt;
  &lt;li&gt;timestamp：时间戳，代表数据点产生的时间。&lt;/li&gt;
  &lt;li&gt;field: 度量下的不同字段。比如位置这个度量具有经度和纬度两个field。一般情况下存放的是会随着时间戳的变化而变化的数据。&lt;/li&gt;
  &lt;li&gt;tag: 标签，或者附加信息。一般存放的是并不随着时间戳变化的属性信息。timestamp加上所有的tags可以认为是table的primary key。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如下图，度量为Wind，每一个数据点都具有一个timestamp，两个field：direction和speed，两个tag：sensor、city。它的第一行和第三行，存放的都是sensor号码为95D8-7913的设备，属性城市是上海。随着时间的变化，风向和风速都发生了改变，风向从23.4变成23.2；而风速从3.4变成了3.3。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/time_series_databse_1.jpeg&quot; alt=&quot;time_series_databse_1&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;应用场景&quot;&gt;应用场景&lt;/h3&gt;
&lt;p&gt;所有有时序数据产生，并且需要展现其历史趋势、周期规律、异常性的，进一步对未来做出预测分析的，都是时序数据库适合的场景。&lt;/p&gt;

&lt;p&gt;例：&lt;br /&gt;
在工业物联网环境监控方向，百度天工的客户就遇到了这么一个难题，由于工业上面的要求，需要将工况数据存储起来。客户每个厂区具有20000个监测点，500毫秒一个采集周期，一共20个厂区。这样算起来一年将产生惊人的26万亿个数据点。假设每个点50Byte，数据总量将达1P（如果每台服务器10T的硬盘，那么总共需要100多台服务器）。这些数据不只是要实时生成，写入存储；还要支持快速查询，做可视化的展示，帮助管理者分析决策；并且也能够用来做大数据分析，发现深层次的问题，帮助企业节能减排，增加效益。最终客户采用了百度天工的时序数据库方案，帮助他解决了难题。&lt;br /&gt;
（这个高逼格）&lt;/p&gt;

&lt;h3 id=&quot;时序数据库遇到的挑战&quot;&gt;时序数据库遇到的挑战&lt;/h3&gt;
&lt;p&gt;很多人可能认为在传统关系型数据库上加上时间戳一列就能作为时序数据库。数据量少的时候确实也没问题，但少量数据是展现的纬度有限，细节少，可置信低，更加不能用来做大数据分析。很明显时序数据库是为了解决海量数据场景而设计的。&lt;/p&gt;

&lt;p&gt;可以看到时序数据库需要解决以下几个问题&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;时序数据的写入：如何支持每秒钟上千万上亿数据点的写入。&lt;/li&gt;
  &lt;li&gt;时序数据的读取：又如何支持在秒级对上亿数据的分组聚合运算。&lt;/li&gt;
  &lt;li&gt;成本敏感：由海量数据存储带来的是成本问题。如何更低成本的存储这些数据，将成为时序数据库需要解决的重中之重。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些问题不是用一篇文章就能含盖的，同时每个问题都可以从多个角度去优化解决。在这里只从数据存储这个角度来尝试回答如何解决大数据量的写入和读取。&lt;/p&gt;

&lt;h3 id=&quot;rrd&quot;&gt;RRD&lt;/h3&gt;
&lt;p&gt;RRD （Round Robin Database）数据库是一个环形的数据库，数据库由一个固定大小的数据文件来存放数据，此数据库不会像传统数据库一样为随着数据的增多而文件的大小也在增加，RRD在创建好后其文件大小就固定，可以把它想像成一个圆，圆的众多直径把圆划分成一个个扇形，每个扇形就是可以存数据的槽位，每个槽位上被打上了一个时间戳，在圆心上有一个指针，随着时间的流逝，取回数据后，指针会负责把数据填充在相应的槽位上，当指针转了360度后，最开始的数据就会被覆盖，就这样RRD循环填充着数据。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;源数据搜集：采用一些数据搜集工具，如脚本、shell命令、SNMP等工具在一定时间间隔里把数据搜集填充到rrd数据库中，这些需要数据搜集的对象叫DS，一个DS里在一个时间里可以搜集的数据可以有多个，比如一个时间点上对网卡来说有进来的流量，也有流出的流量，所以这是2个数据成为一组数据。&lt;/li&gt;
  &lt;li&gt;临时存储：源数据获取到后是存放在一个数据库的一个临时区域，这些源数据叫做PDP&lt;/li&gt;
  &lt;li&gt;分组-聚合：RRDTool把这些PDP数据作为数据源通过分组、再利用聚合函数计算后把计算后的结果放在RRD数据库的时间槽(time slot)上，这些数据叫做CDP，CDP才是RRDTool绘图时真正打交道的数据，&lt;/li&gt;
  &lt;li&gt;在从源数据中取数据做聚合计算时会有一个挑选数据的基准，也就是说是以几个源数据为一组做聚合，根据现实需求的不同，对源数据可以很灵活的选择不同的时间段提取源数据，再聚合提取不同的聚合值，这样就产生不同组别的CDP数据，这些有以相同时间段挑选源数据及相同聚合函数计算的结果组成的数据就叫RRA，所以根据挑选源数据的标准及采用的聚合函数的不同，RRA可以有多组。&lt;/li&gt;
  &lt;li&gt;DS：Data Source 数据源，用于定义搜集数据的工具所搜集数据的一些特性&lt;/li&gt;
  &lt;li&gt;Time Solt：时间槽，用于存放通过聚合后的数据区域&lt;/li&gt;
  &lt;li&gt;PDP：Primary Data Point 主数据节点，每个时间点产生的数据，即是搜集的源数据，没有做聚合的数据&lt;/li&gt;
  &lt;li&gt;CDP（Consolidation Data Point 聚合数据节点）：通过对获取的源数据分组、聚合计算后得到的数据叫CDP，&lt;/li&gt;
  &lt;li&gt;RRA（Round Robin Archive 轮转归档）：以相同的分组、聚合函数计算后的CDP数据组就组成了RRA&lt;/li&gt;
  &lt;li&gt;Resolution（解析度）：这是一个时间跨度，表示在做聚合计算时是以几个连续的time slot里的数据做聚合，在默认时rrd是以300秒的间隔产生一个time slot。&lt;/li&gt;
  &lt;li&gt;CF：Consolidation Function，合并函数或聚合函数，以RRDTool中有AVERAGE、MAX、MIN、LAST4种&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以一个图来说明PDP、CDP、RRA之间的关系：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/time_series_pdp_cdp_rra.jpeg&quot; alt=&quot;time_series_pdp_cdp_rra&quot; /&gt;&lt;/p&gt;

&lt;p&gt;PDP是以规定的时间间隔（默认为300秒）搜集的源数据，第一个RRA以4个PDP（即4*300秒）为一组做CF后组成的数据，第二个RRA则是以10个PDP为一组做CF后组成的数据。&lt;/p&gt;

&lt;h3 id=&quot;influxdb&quot;&gt;InfluxDB&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/influxdata/influxdb&quot;&gt;InfluxDB&lt;/a&gt; 在存储引擎上纠结了很久， leveldb, rocksdb, boltdb 都玩了个遍，最后决定自己造个轮子叫 Time Structured Merge Tree。&lt;/p&gt;

&lt;p&gt;Time Structured Merge Tree (TSM) 和 Log Structured Merge Tree (LSM) 的名字都有点误导性，关键并不是树，也不是日志或者时间，而是 Merge。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;写入的时候，数据先写入到内存里，之后批量写入到硬盘。&lt;/li&gt;
  &lt;li&gt;读的时候，同时读内存和硬盘然后合并结果。&lt;/li&gt;
  &lt;li&gt;删除的时候，写入一个删除标记，被标记的数据在读取时不会被返回。&lt;/li&gt;
  &lt;li&gt;后台会把小的块合并成大的块，此时被标记删除的数据才真正被删除&lt;/li&gt;
  &lt;li&gt;相对于普通数据，有规律的时间序列数据在合并的过程中可以极大的提高压缩比。&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Lewin</name></author><category term="数据库" /><category term="时间序列" /><summary type="html">背景 2017年时序数据库忽然火了起来。开年2月Facebook开源了beringei时序数据库；到了4月基于PostgreSQL打造的时序数据库TimeScaleDB也开源了，而早在2016年7月，百度云在其天工物联网平台上发布了国内首个多租户的分布式时序数据库产品TSDB，成为支持其发展制造，交通，能源，智慧城市等产业领域的核心产品，同时也成为百度战略发展产业物联网的标志性事件。</summary></entry><entry><title type="html">块存储、文件存储、对象存储</title><link href="https://lewinz.org/2021/05/28/block-file-object-storage/" rel="alternate" type="text/html" title="块存储、文件存储、对象存储" /><published>2021-05-28T00:00:00+08:00</published><updated>2021-05-28T00:00:00+08:00</updated><id>https://lewinz.org/2021/05/28/block-file-object-storage</id><content type="html" xml:base="https://lewinz.org/2021/05/28/block-file-object-storage/">&lt;h2 id=&quot;块存储&quot;&gt;块存储&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;典型设备：磁盘阵列、硬盘&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;块存储主要是将裸磁盘空间整个映射给主机使用的。&lt;/p&gt;

&lt;p&gt;就是说例如：&lt;br /&gt;
磁盘阵列里面有5块硬盘，然后可以通过划逻辑盘、做Raid、或者LVM等方式逻辑划分出N个逻辑的硬盘。但是逻辑盘和物理盘是两个完全不同的概念。假设每个硬盘100G，共有5个硬盘，划分为逻辑盘也为5个，每个100G，但是这5个逻辑盘和原来的5个物理盘意义完全不同了。例如第一个逻辑盘第一个20G可能来自物理盘1，第二个20G来自物理盘2，所以逻辑盘是多个物理盘逻辑虚构出来的硬盘。&lt;/p&gt;

&lt;p&gt;接着块存储会采用映射的方式将这几个逻辑盘映射给主机，主机上面的操作系统会识别到有5块硬盘，但是操作系统是无法区分到底是物理盘还是逻辑盘，它一概就认为只是5块裸的物理硬盘而已，跟直接拿一块物理硬盘挂载到操作系统没区别，至少操作系统感知上没有区别的。&lt;/p&gt;

&lt;p&gt;在此方式下，操作系统还需要对挂载的裸硬盘进行分区、格式化后，才能使用，与平常主机内置的硬盘无差异。&lt;/p&gt;

&lt;h3 id=&quot;优点&quot;&gt;优点&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;这种方式的好处当然是因为通过了Raid与LVM等手段，对数据提供了保护；&lt;/li&gt;
  &lt;li&gt;可以将多块廉价的硬盘组合起来，称为一个大容量的逻辑盘对外提供服务，提高了容量；&lt;/li&gt;
  &lt;li&gt;写入数据时，由于是多块磁盘组合出来的逻辑盘，所以几块硬盘可以并行写入的，提升了读写效率；&lt;/li&gt;
  &lt;li&gt;很多时候块存储采用SAN架构组网，传输速度以及封装协议的原因，使得传输速度和读写效率得到提升&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;缺点&quot;&gt;缺点&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;采用SAN架构组网时，需要额外为主机购买光纤通道卡，还要购买光纤交换机，造价成本高；&lt;/li&gt;
  &lt;li&gt;主机之间数据无法共享，在服务器不做集群的情况下，块存储裸盘映射给主机，在格式化使用后，对于主机来说相当于本地盘，那么主机A的本地盘根本不能给主机B去使用，无法共享数据&lt;/li&gt;
  &lt;li&gt;不利于不同操作系统主机间的数据共享：因为操作系统使用不同的文件系统，格式化后，不同的文件系统间的数据是共享不了的。 例如一台win7，文件系统是FAT32/NTFS，而linux是EXT4，EXT4是无法识别NTFS的文件系统的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;文件存储&quot;&gt;文件存储&lt;/h2&gt;
&lt;p&gt;典型设备：&lt;a href=&quot;https://segmentfault.com/a/1190000019698532&quot;&gt;FTP服务器&lt;/a&gt;、&lt;a href=&quot;https://zhuanlan.zhihu.com/p/78114809&quot;&gt;NFS服务器&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;为了克服文件无法共享的问题，所以有了文件存储。&lt;/p&gt;

&lt;p&gt;文件存储也有软硬一体化的设备，但是其实一台普通的PC机，只要装上合适的操作系统和软件，就可以假设FTP与NFS服务了，架上该类服务之后的服务器，就是文件存储的一种了。&lt;/p&gt;

&lt;p&gt;主机A可以直接对文件存储进行文件的上传和下载，与块存储不同，主机A是不需要再对文件存储进行格式化的，因为文件管理功能已经由文件存储自己搞定了。&lt;/p&gt;

&lt;h3 id=&quot;优点-1&quot;&gt;优点&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;造价低：随便一台机器就可以，另外普通的以太网就可以，根本不需要专用的SAN网络，所以造价低&lt;/li&gt;
  &lt;li&gt;方便文件共享&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;缺点-1&quot;&gt;缺点&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;读写速率低，传输速率慢：以太网，上传下载速度较慢，另外所有读写都要1台服务器里面的硬盘来承受，相比起磁盘阵列动不动就十几上百块硬盘同时读写，速率慢了许多。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;对象存储&quot;&gt;对象存储&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;典型设备：内置大容量硬盘的分布式服务器&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对象存储最常用的方案，就是多台服务器内置大容量硬盘，再装上对象存储软件，然后再额外搞几台服务作为管理节点，安装上对象存储管理软件。管理节点可以管理其他服务器对外提供读写访问功能。&lt;br /&gt;
之所以出现对象存储这种东西，是为了克服块存储与文件存储各自的缺点，发扬各自的优点。简单来说块存储读写快，不利于共享，文件存储读写慢，利于共享。能否弄一个读写块，利于共享的存储出来呢？于是就有了对象存储。&lt;/p&gt;

&lt;p&gt;首先，一个文件包含了属性（术语：metadata，元数据，例如该文件的大小、修改时间、存储路径等）以及内容（数据）。&lt;br /&gt;
像FAT32这种文件系统，是直接将一份文件与metadata一起存储的，存储过程先将文件按照文件系统的最小块大小来打散（例如4M的文件，假设文件系统要求一个块4K，那么就将文件打散称为1000个小块），再写进硬盘里，过程中没有区分数据和metadata的。而每个块最后会告知你下一个要读取的块地址，然后一直这样顺序的按图索骥，最后完成整份文件的所有块的读取。
这种情况下读写速率很慢，因为就算你有100个机械臂在读写，但是由于你只有读取到第一个块，才能知道下一个块在哪里，其实相当于只能有1个机械臂在实际工作。&lt;/p&gt;

&lt;p&gt;而对象存储则将元数据独立出来了，控制节点叫元数据服务器（服务器+对象存储管理软件），里面主要负责存储对象的属性（主要是对象的数据被打散存放到了那几台分布式服务器中的信息）而其他负责存储数据的分布式服务器叫做OSD，主要负责存储文件的数据部分。当用户访问对象，会先访问元数据服务器，元数据服务器只负责反馈对象存储在哪里OSD，假设反馈文件A存储在B、C、D三台OSD，那么用户就会再次直接访问3台OSD服务器去读取数据。&lt;/p&gt;

&lt;p&gt;这时候由于是3台OSD同时对外传输数据，所以传输的速度就会加快了，当OSD服务器数量越多，这种读写速度的提升就越大，通过此种方式，实现了读写快的目的。&lt;/p&gt;

&lt;p&gt;另一方面，对象存储软件是有专门的文件系统的，所以OSD对外又相当于文件服务器，那么就不存在共享方面的困难了，也解决了文件共享方面的问题&lt;/p&gt;

&lt;p&gt;所以对象存储的出现，很好的结合了块存储和文件存储的优点&lt;/p&gt;

&lt;p&gt;为什么对象存储兼具块存储和文件存储的好处，还要使用块存储和文件存储呢？&lt;/p&gt;

&lt;p&gt;（1）有一类应用是需要存储直接裸盘映射的，例如数据库。因为数据需要存储楼盘映射给自己后，再根据自己的数据库文件系统来对裸盘进行格式化的，所以是不能够采用其他已经被格式化为某种文件系统的存储的。此类应用更合适使用块存储。&lt;/p&gt;

&lt;p&gt;（2）对象存储的成本比起普通的文件存储还要较高，需要购买专门的对象存储软件以及大容量硬盘。如果对数据量要求不是海量，只是为了做文件共享的时候，直接用文件存储的形式好了，性价比高。&lt;/p&gt;

&lt;h2 id=&quot;相关博客&quot;&gt;相关博客&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/78114809&quot;&gt;NFS文件共享服务器使用&lt;/a&gt;&lt;/p&gt;</content><author><name>Lewin</name></author><category term="block storage" /><category term="file storage" /><category term="object storage" /><category term="块存储" /><category term="文件存储" /><category term="对象存储" /><summary type="html">块存储</summary></entry><entry><title type="html">github review</title><link href="https://lewinz.org/2021/05/26/github-review/" rel="alternate" type="text/html" title="github review" /><published>2021-05-26T00:00:00+08:00</published><updated>2021-05-26T00:00:00+08:00</updated><id>https://lewinz.org/2021/05/26/github-review</id><content type="html" xml:base="https://lewinz.org/2021/05/26/github-review/">&lt;h3 id=&quot;code-review-缩写&quot;&gt;code review 缩写&lt;/h3&gt;
&lt;p&gt;程序员这个行业，不管你是大佬还是小弟，代码code review是必不可少的。那么在github上，大家日常交流的缩写语，往往一下就能看出你道行的深浅，至少是入行时间，哈哈，不要露怯，勇敢的跟大佬过招拆招。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;简写&lt;/th&gt;
      &lt;th&gt;全称（解释）&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;LGTM&lt;/td&gt;
      &lt;td&gt;Looks Good To Me「对我来说，还不错」表示认可这次PR，同意merge合并代码到远程仓库&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ASAP&lt;/td&gt;
      &lt;td&gt;As Soon As Possible「尽快」&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ACK&lt;/td&gt;
      &lt;td&gt;Acknowledgement「承认，确认，同意」i.e. agreed/accepted change&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;NACK/NAK&lt;/td&gt;
      &lt;td&gt;Negative acknowledgement「不同意」 i.e. disagree with change and/or concept&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;RFC&lt;/td&gt;
      &lt;td&gt;Request For Comments「请求进行讨论」 i.e. I think this is a good idea, lets discuss&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;WIP&lt;/td&gt;
      &lt;td&gt;Work In Progress 「进展中」常见词汇，这里作为 Best Practice 单独提出来，主要针对改动较多的 PR，可以先提交部分，标题或 Tag 加上 WIP，表示尚未完成，这样别人可以先 review 已提交的部分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;AFAIK/AFAICT&lt;/td&gt;
      &lt;td&gt;As Far As I Know / Can Tell 「据我所知；就我所知」&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;IIRC&lt;/td&gt;
      &lt;td&gt;If I Recall Correctly「如果我没有记错的话」&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;IANAL&lt;/td&gt;
      &lt;td&gt;I am not a lawyer , but I smell licensing issues「-」&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;IMO&lt;/td&gt;
      &lt;td&gt;In My Opinion 「在我看来」&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TL;DR&lt;/td&gt;
      &lt;td&gt;Too Long; Didn’t Read 「太长懒得看」README 文档常见。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;PR&lt;/td&gt;
      &lt;td&gt;Pull Request「合并请求」&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CR&lt;/td&gt;
      &lt;td&gt;Code Review 「代码审查」&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;PTAL&lt;/td&gt;
      &lt;td&gt;Please Take A Look.「你来瞅瞅？」用来提示别人来看一下&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TBR&lt;/td&gt;
      &lt;td&gt;To Be Reviewed「提示维护者进行 review」&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TBD&lt;/td&gt;
      &lt;td&gt;To Be Done(or Defined/Discussed/Decided/Determined). 「未完成，将被做」根据语境不同意义有所区别，但一般都是还没搞定的意思。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TBH&lt;/td&gt;
      &lt;td&gt;To Be Honest 「老实说」&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;atm&lt;/td&gt;
      &lt;td&gt;at the moment 「现阶段」&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name>Lewin</name></author><category term="github" /><category term="review" /><summary type="html">code review 缩写 程序员这个行业，不管你是大佬还是小弟，代码code review是必不可少的。那么在github上，大家日常交流的缩写语，往往一下就能看出你道行的深浅，至少是入行时间，哈哈，不要露怯，勇敢的跟大佬过招拆招。</summary></entry><entry><title type="html">golang test</title><link href="https://lewinz.org/2021/05/26/golang-test/" rel="alternate" type="text/html" title="golang test" /><published>2021-05-26T00:00:00+08:00</published><updated>2021-05-26T00:00:00+08:00</updated><id>https://lewinz.org/2021/05/26/golang-test</id><content type="html" xml:base="https://lewinz.org/2021/05/26/golang-test/">&lt;h3 id=&quot;testing---单元测试&quot;&gt;testing - 单元测试&lt;/h3&gt;
&lt;p&gt;testing 为 Go 语言 package 提供自动化测试的支持。通过 go test 命令，能够自动执行如下形式的任何函数：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;func TestXxx(*testing.T)&lt;/code&gt;
注意：Xxx 可以是任何字母数字字符串，但是第一个字母不能是小写字母。&lt;/p&gt;

&lt;p&gt;在这些函数中，使用 Error、Fail 或相关方法来发出失败信号。&lt;/p&gt;

&lt;p&gt;要编写一个新的测试套件，需要创建一个名称以 _test.go 结尾的文件，该文件包含 TestXxx 函数，如上所述。 将该文件放在与被测试文件相同的包中。该文件将被排除在正常的程序包之外，但在运行 go test 命令时将被包含。 有关详细信息，请运行 go help test 和 go help testflag 了解。&lt;/p&gt;

&lt;p&gt;如果有需要，可以调用 *T 和 *B 的 Skip 方法，跳过该测试或基准测试：&lt;/p&gt;
&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TestTimeConsuming&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;testing&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;testing&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Short&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Skip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;skipping test in short mode.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;第一个单元测试&quot;&gt;第一个单元测试&lt;/h4&gt;
&lt;p&gt;要测试的代码：&lt;/p&gt;
&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;测试代码：&lt;/p&gt;
&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TestFib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;testing&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt;       &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;7&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;13&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;actual&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;actual&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Errorf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Fib(%d) = %d; expected %d&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;actual&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;go test .&lt;/code&gt;，输出：&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;go &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
ok      chapter09/testing    0.007s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;表示测试通过。&lt;/p&gt;

&lt;p&gt;我们将 Sum 函数改为：&lt;/p&gt;
&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;再执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;go test .&lt;/code&gt;，输出：&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;go &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt; FAIL: TestSum &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0.00s&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    t_test.go:16: Fib&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;10&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 64&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; expected 13
FAIL
FAIL    chapter09/testing    0.009s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;table-driven-test&quot;&gt;Table-Driven Test&lt;/h4&gt;
&lt;p&gt;测试讲究 case 覆盖，按上面的方式，当我们要覆盖更多 case 时，显然通过修改代码的方式很笨拙。这时我们可以采用 Table-Driven 的方式写测试，标准库中有很多测试是使用这种方式写的。&lt;/p&gt;
&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TestFib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;testing&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fibTests&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt;       &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// input&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// expected result&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}{&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;13&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;range&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fibTests&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;actual&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;actual&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Errorf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Fib(%d) = %d; expected %d&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;actual&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;由于我们使用的是 t.Errorf，即使其中某个 case 失败，也不会终止测试执行。&lt;/p&gt;

&lt;h4 id=&quot;t-类型&quot;&gt;T 类型&lt;/h4&gt;
&lt;p&gt;单元测试中，传递给测试函数的参数是 *testing.T 类型。它用于管理测试状态并支持格式化测试日志。测试日志会在执行测试的过程中不断累积，并在测试完成时转储至标准输出。&lt;/p&gt;

&lt;p&gt;当测试函数返回时，或者当测试函数调用 FailNow、 Fatal、Fatalf、SkipNow、Skip、Skipf 中的任意一个时，则宣告该测试函数结束。跟 Parallel 方法一样，以上提到的这些方法只能在运行测试函数的 goroutine 中调用。&lt;/p&gt;

&lt;p&gt;至于其他报告方法，比如 Log 以及 Error 的变种， 则可以在多个 goroutine 中同时进行调用。&lt;/p&gt;

&lt;h5 id=&quot;报告方法&quot;&gt;报告方法&lt;/h5&gt;
&lt;p&gt;上面提到的系列包括方法，带 f 的是格式化的，格式化语法参考 fmt 包。&lt;/p&gt;

&lt;p&gt;T 类型内嵌了 common 类型，common 提供这一系列方法，我们经常会用到的（注意，这里说的测试中断，都是指当前测试函数）：&lt;/p&gt;

&lt;p&gt;1）当我们遇到一个断言错误的时候，标识这个测试失败，会使用到：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Fail : 测试失败，测试继续，也就是之后的代码依然会执行&lt;/li&gt;
  &lt;li&gt;FailNow : 测试失败，测试中断
在 FailNow 方法实现的内部，是通过调用 runtime.Goexit() 来中断测试的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2）当我们遇到一个断言错误，只希望跳过这个错误，但是不希望标识测试失败，会使用到：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;SkipNow : 跳过测试，测试中断
在 SkipNow 方法实现的内部，是通过调用 runtime.Goexit() 来中断测试的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3）当我们只希望打印信息，会用到 :&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Log : 输出信息&lt;/li&gt;
  &lt;li&gt;Logf : 输出格式化的信息
注意：默认情况下，单元测试成功时，它们打印的信息不会输出，可以通过加上 -v 选项，输出这些信息。但对于基准测试，它们总是会被输出。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;4）当我们希望跳过这个测试，并且打印出信息，会用到：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Skip : 相当于 Log + SkipNow&lt;/li&gt;
  &lt;li&gt;Skipf : 相当于 Logf + SkipNow&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;5）当我们希望断言失败的时候，标识测试失败，并打印出必要的信息，但是测试继续，会用到：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Error : 相当于 Log + Fail&lt;/li&gt;
  &lt;li&gt;Errorf : 相当于 Logf + Fail&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;6）当我们希望断言失败的时候，标识测试失败，打印出必要的信息，但中断测试，会用到：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Fatal : 相当于 Log + FailNow&lt;/li&gt;
  &lt;li&gt;Fatalf : 相当于 Logf + FailNow&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;parallel-测试&quot;&gt;Parallel 测试&lt;/h5&gt;
&lt;p&gt;包中的 Parallel 方法表示当前测试只会与其他带有 Parallel 方法的测试并行进行测试。&lt;/p&gt;

&lt;p&gt;下面例子将演示 Parallel 的使用方法：&lt;/p&gt;
&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;locker&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sync&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RWMutex&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WriteToMap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;locker&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;defer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;locker&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ReadFromMap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;locker&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RLock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;defer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;locker&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RUnlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;测试代码：&lt;/p&gt;
&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pairs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;polaris&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; 徐新华 &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;studygolang&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Go 语言中文网 &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;stdlib&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Go 语言标准库 &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;polaris1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; 徐新华 1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;studygolang1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Go 语言中文网 1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;stdlib1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Go 语言标准库 1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;polaris2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; 徐新华 2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;studygolang2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Go 语言中文网 2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;stdlib2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Go 语言标准库 2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;polaris3&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; 徐新华 3&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;studygolang3&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Go 语言中文网 3&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;stdlib3&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Go 语言标准库 3&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;polaris4&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; 徐新华 4&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;studygolang4&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Go 语言中文网 4&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;stdlib4&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Go 语言标准库 4&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// 注意 TestWriteToMap 需要在 TestReadFromMap 之前&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TestWriteToMap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;testing&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Parallel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;range&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pairs&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;WriteToMap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TestReadFromMap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;testing&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Parallel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;range&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pairs&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;actual&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ReadFromMap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;actual&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Errorf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;the value of key(%s) is %s, expected: %s&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;actual&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;试验步骤：&lt;/p&gt;

&lt;p&gt;注释掉 WriteToMap 和 ReadFromMap 中 locker 保护的代码，同时注释掉测试代码中的 t.Parallel，执行测试，测试通过，即使加上 -race，测试依然通过；&lt;br /&gt;
只注释掉 WriteToMap 和 ReadFromMap 中 locker 保护的代码，执行测试，测试失败（如果未失败，加上 -race 一定会失败）；&lt;br /&gt;
如果代码能够进行并行测试，在写测试时，尽量加上 Parallel，这样可以测试出一些可能的问题。&lt;/p&gt;

&lt;p&gt;关于 Parallel 的更多内容，会在 子测试 中介绍。&lt;/p&gt;

&lt;p&gt;当你写完一个函数，结构体，main 之后，你下一步需要的就是测试了。testing 包提供了很简单易用的测试包。&lt;/p&gt;

&lt;h3 id=&quot;写一个基本的测试用例&quot;&gt;写一个基本的测试用例&lt;/h3&gt;
&lt;p&gt;测试文件的文件名需要以_test.go 为结尾，测试用例需要以 TestXxxx 的形式存在。&lt;/p&gt;

&lt;p&gt;比如我要测试 utils 包的 sql.go 中的函数：&lt;/p&gt;

&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GetOne&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;db&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sql&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;query&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{})&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;就需要创建一个 sql_test.go&lt;/p&gt;

&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;utils&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;database/sql&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;github.com/go-sql-driver/mysql&quot;&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;strconv&quot;&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;testing&quot;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Test_GetOne&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;testing&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sql&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;mysql&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;root:123.abc@tcp(192.168.33.10:3306)/test&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;defer&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}()&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Fatal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;c&quot;&gt;// 测试 empty&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;car_brand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GetOne&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;select * from user where id = 999999&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;car_brand&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Fatal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;emtpy 测试错误 &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;testing-的测试用例形式&quot;&gt;testing 的测试用例形式&lt;/h3&gt;
&lt;p&gt;测试用例有四种形式：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;TestXxxx(t *testing.T)    // 基本测试用例&lt;/li&gt;
  &lt;li&gt;BenchmarkXxxx(b *testing.B) // 压力测试的测试用例&lt;/li&gt;
  &lt;li&gt;Example_Xxx()  // 测试控制台输出的例子&lt;/li&gt;
  &lt;li&gt;TestMain(m *testing.M) // 测试 Main 函数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;给个 Example 的例子 :（Example 需要在最后用注释的方式确认控制台输出和预期是不是一致的）&lt;/p&gt;

&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Example_GetScore&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;score&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getScore&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2.1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;score&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;// Output:&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;// 31.1&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;testing-的变量&quot;&gt;testing 的变量&lt;/h3&gt;
&lt;p&gt;gotest 的变量有这些：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;test.short : 一个快速测试的标记，在测试用例中可以使用 testing.Short() 来绕开一些测试&lt;/li&gt;
  &lt;li&gt;test.outputdir : 输出目录&lt;/li&gt;
  &lt;li&gt;test.coverprofile : 测试覆盖率参数，指定输出文件&lt;/li&gt;
  &lt;li&gt;test.run : 指定正则来运行某个 / 某些测试用例&lt;/li&gt;
  &lt;li&gt;test.memprofile : 内存分析参数，指定输出文件&lt;/li&gt;
  &lt;li&gt;test.memprofilerate : 内存分析参数，内存分析的抽样率&lt;/li&gt;
  &lt;li&gt;test.cpuprofile : cpu 分析输出参数，为空则不做 cpu 分析&lt;/li&gt;
  &lt;li&gt;test.blockprofile : 阻塞事件的分析参数，指定输出文件&lt;/li&gt;
  &lt;li&gt;test.blockprofilerate : 阻塞事件的分析参数，指定抽样频率&lt;/li&gt;
  &lt;li&gt;test.timeout : 超时时间&lt;/li&gt;
  &lt;li&gt;test.cpu : 指定 cpu 数量&lt;/li&gt;
  &lt;li&gt;test.parallel : 指定运行测试用例的并行数&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;testing-的结构体&quot;&gt;testing 的结构体&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;B : 压力测试&lt;/li&gt;
  &lt;li&gt;BenchmarkResult : 压力测试结果&lt;/li&gt;
  &lt;li&gt;Cover : 代码覆盖率相关结构体&lt;/li&gt;
  &lt;li&gt;CoverBlock : 代码覆盖率相关结构体&lt;/li&gt;
  &lt;li&gt;InternalBenchmark : 内部使用的结构体&lt;/li&gt;
  &lt;li&gt;InternalExample : 内部使用的结构体&lt;/li&gt;
  &lt;li&gt;InternalTest : 内部使用的结构体&lt;/li&gt;
  &lt;li&gt;M : main 测试使用的结构体&lt;/li&gt;
  &lt;li&gt;PB : Parallel benchmarks 并行测试使用的结构体&lt;/li&gt;
  &lt;li&gt;T : 普通测试用例&lt;/li&gt;
  &lt;li&gt;TB : 测试用例的接口&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;testing-的通用方法&quot;&gt;testing 的通用方法&lt;/h3&gt;
&lt;p&gt;T 结构内部是继承自 common 结构，common 结构提供集中方法，是我们经常会用到的：&lt;/p&gt;

&lt;p&gt;1）当我们遇到一个断言错误的时候，我们就会判断这个测试用例失败，就会使用到：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Fail : case 失败，测试用例继续&lt;/li&gt;
  &lt;li&gt;FailedNow : case 失败，测试用例中断&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2）当我们遇到一个断言错误，只希望跳过这个错误，但是不希望标示测试用例失败，会使用到：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;SkipNow : case 跳过，测试用例不继续&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3）当我们只希望在一个地方打印出信息，我们会用到 :&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Log : 输出信息&lt;/li&gt;
  &lt;li&gt;Logf : 输出有 format 的信息&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;4）当我们希望跳过这个用例，并且打印出信息 :&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Skip : Log + SkipNow&lt;/li&gt;
  &lt;li&gt;Skipf : Logf + SkipNow&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;5）当我们希望断言失败的时候，测试用例失败，打印出必要的信息，但是测试用例继续：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Error : Log + Fail&lt;/li&gt;
  &lt;li&gt;Errorf : Logf + Fail&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;6）当我们希望断言失败的时候，测试用例失败，打印出必要的信息，测试用例中断：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Fatal : Log + FailNow&lt;/li&gt;
  &lt;li&gt;Fatalf : Logf + FailNow&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Lewin</name></author><category term="golang" /><category term="test" /><summary type="html">testing - 单元测试 testing 为 Go 语言 package 提供自动化测试的支持。通过 go test 命令，能够自动执行如下形式的任何函数：</summary></entry><entry><title type="html">mtr 命令</title><link href="https://lewinz.org/2021/05/26/mtr-instruct/" rel="alternate" type="text/html" title="mtr 命令" /><published>2021-05-26T00:00:00+08:00</published><updated>2021-05-26T00:00:00+08:00</updated><id>https://lewinz.org/2021/05/26/mtr-instruct</id><content type="html" xml:base="https://lewinz.org/2021/05/26/mtr-instruct/">&lt;h3 id=&quot;mtr&quot;&gt;MTR&lt;/h3&gt;
&lt;p&gt;mtr 命令是 ping 和 tracert 命令的结合，同时具有 测试丢包率（ping） 和 跟踪路由（tracert） 的功能&lt;/p&gt;

&lt;h3 id=&quot;安装&quot;&gt;安装&lt;/h3&gt;
&lt;h4 id=&quot;mac&quot;&gt;mac&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;命令安装 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;brew install mtr&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;MTR 安装之后并未把程序文件复制到 /usr/local/bin 目录下，需要手动复制
    &lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; /usr/local/Cellar/mtr/0.92/sbin
&lt;span class=&quot;nb&quot;&gt;cp &lt;/span&gt;mtr /usr/local/bin/
&lt;span class=&quot;nb&quot;&gt;cp &lt;/span&gt;mtr-packet /usr/local/bin/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;MTR 命令的使用，需要管理员权限，所以在运行时必须加上 sudo&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo mtr www.baidu.com&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;命令详解&quot;&gt;命令详解&lt;/h3&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mtr &lt;span class=&quot;nt&quot;&gt;-h&lt;/span&gt; 提供帮助命令  

mtr &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; 显示mtr的版本信息  

mtr &lt;span class=&quot;nt&quot;&gt;-r&lt;/span&gt; 已报告模式显示  

mtr &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; 设置每秒发送数据包的数量  

mtr &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; 用来指定ping数据包的大小  

mtr &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; no-dns不对IP地址做域名解析  

mtr &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt; 来设置发送数据包的IP地址 这个对一个主机由多个IP地址是有用的  

mtr &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; 使用这个参数来设置ICMP返回之间的要求默认是1秒  

mtr &lt;span class=&quot;nt&quot;&gt;-4&lt;/span&gt; IPv4  

mtr &lt;span class=&quot;nt&quot;&gt;-6&lt;/span&gt; IPv6  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;数据含义：&lt;br /&gt;
​Host 列是途经的IP或本机域名&lt;/p&gt;

&lt;p&gt;Loss% 列就是对应IP行的丢包率了，值得一提的是，只有最后的目标丢包才算是真正的丢包&lt;/p&gt;

&lt;p&gt;Last 列则是最后一次返回的延迟，按毫秒计算的&lt;/p&gt;

&lt;p&gt;Avg 列是所有返回时延的一个平均值&lt;/p&gt;

&lt;p&gt;Best 列是最快的一次返回时延&lt;/p&gt;

&lt;p&gt;Wrst 列是最长的一次返回时延&lt;/p&gt;

&lt;p&gt;StDev 列是标准偏差&lt;/p&gt;</content><author><name>Lewin</name></author><category term="mtr" /><category term="路由" /><summary type="html">MTR mtr 命令是 ping 和 tracert 命令的结合，同时具有 测试丢包率（ping） 和 跟踪路由（tracert） 的功能</summary></entry></feed>