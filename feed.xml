<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="https://lewinz.org/feed.xml" rel="self" type="application/atom+xml" /><link href="https://lewinz.org/" rel="alternate" type="text/html" /><updated>2021-08-03T23:08:20+08:00</updated><id>https://lewinz.org/feed.xml</id><title type="html">阿嫂</title><subtitle>阿嫂个人博客</subtitle><author><name>Lewin</name></author><entry><title type="html">Linux ssh 相关问题</title><link href="https://lewinz.org/2021/08/03/linux-ssh-setting/" rel="alternate" type="text/html" title="Linux ssh 相关问题" /><published>2021-08-03T00:00:00+08:00</published><updated>2021-08-03T00:00:00+08:00</updated><id>https://lewinz.org/2021/08/03/linux-ssh-setting</id><content type="html" xml:base="https://lewinz.org/2021/08/03/linux-ssh-setting/">&lt;h2 id=&quot;ssh-client-设置轮询导致-ssh-禁用&quot;&gt;ssh client 设置轮询导致 ssh 禁用&lt;/h2&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# vi /etc/hosts.allow&lt;/span&gt;
sshd:all
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;ssh-请求连接时间长&quot;&gt;ssh 请求连接时间长&lt;/h2&gt;
&lt;h3 id=&quot;使用了-dns-反查导致耗时&quot;&gt;使用了 DNS 反查导致耗时&lt;/h3&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# vi /etc/ssh/sshd_config&lt;/span&gt;

UseDNS no
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;默认情况下会有一行被注释的配置 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;# UseDNS yes&lt;/code&gt;, 但是 ssh 缺省情况下默认是 yes ，所以需要显式配置为 no&lt;/p&gt;

&lt;p&gt;这个配置会导致 ssh 在 dns 解析的时候，如果 dns 中没有域名解析记录，会等待 dns 服务器超时返回。&lt;/p&gt;

&lt;h3 id=&quot;kerberos-方式验证导致耗时&quot;&gt;Kerberos 方式验证导致耗时&lt;/h3&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# vi /etc/ssh/sshd_config&lt;/span&gt;

GSSAPIAuthentication no
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;一般 ssh 依次进行的认证方式是 publickey, gssapi-keyex, gssapi-with-mic, password，一般我们常用的是 publickey、password，但是 gssapi（基于 Kerberos） 每次验证还是会尝试，非常耗时，修改 GSSAPIAuthentication 配置可关闭 gssapi 验证过程。&lt;/p&gt;

&lt;h2 id=&quot;重启&quot;&gt;重启&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;service sshd restart&lt;/code&gt;&lt;/p&gt;</content><author><name>Lewin</name></author><category term="linux" /><category term="ssh" /><summary type="html">ssh client 设置轮询导致 ssh 禁用 # vi /etc/hosts.allow sshd:all</summary></entry><entry><title type="html">Golang 基于 viper 的配置热加载或动态变更方法介绍</title><link href="https://lewinz.org/2021/08/01/golang-viper/" rel="alternate" type="text/html" title="Golang 基于 viper 的配置热加载或动态变更方法介绍" /><published>2021-08-01T00:00:00+08:00</published><updated>2021-08-01T00:00:00+08:00</updated><id>https://lewinz.org/2021/08/01/golang-viper</id><content type="html" xml:base="https://lewinz.org/2021/08/01/golang-viper/">&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;
&lt;p&gt;在写 web server 时，往往需要引入各种各样的配置信息，如依赖的其他中间件（redis、elasticsearch）等，一旦这些服务发生变更，我们需要重新启动 web server，以使配置生效。在 Golang 中，基于 viper 的动态配置就可以省去这些繁琐的步骤了。接下来用一个示例来说明如何使用 viper 的配置热加载：&lt;/p&gt;

&lt;h2 id=&quot;项目结构&quot;&gt;项目结构&lt;/h2&gt;
&lt;p&gt;整个项目的目录结构:&lt;/p&gt;
&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DynamicConfigDemo&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 项目地址&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;conf&lt;/span&gt;   &lt;span class=&quot;c&quot;&gt;// 配置文件目录&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;yaml&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;// 采用 yaml 格式文件，viper 同样支持 toml、json 等格式的配置文件&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;src&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 代码文件夹&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dynamic_config&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 动态配置文件夹&lt;/span&gt;
			&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dynamic_config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 配置加载脚本&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;go&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mod&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// go package 管理依赖的包文件&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;go&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// go package 管理打包产生的文件&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// web server 的入口，主函数&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;代码细节&quot;&gt;代码细节&lt;/h2&gt;
&lt;p&gt;各文件的主体内容：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# conf/base.yaml
service:
  redis:
    host: 127.0.0.1
    port: 6379
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;conf/base.yaml 文件定义了配置项，包含 redis 的 host 及 port 信息。&lt;/p&gt;
&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dynamic_config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dynamic_config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dynamic_config&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;github.com/fsnotify/fsnotify&quot;&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;github.com/spf13/viper&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GlobalConfig&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;viper&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Viper&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Loading configuration logics...&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;GlobalConfig&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;initConfig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dynamicConfig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;initConfig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;viper&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Viper&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;GlobalConfig&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;viper&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;New&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;GlobalConfig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SetConfigName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;base&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;GlobalConfig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AddConfigPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;conf/&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;GlobalConfig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SetConfigType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;yaml&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GlobalConfig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReadInConfig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Failed to get the configuration.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GlobalConfig&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dynamicConfig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;GlobalConfig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WatchConfig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;GlobalConfig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OnConfigChange&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fsnotify&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Detect config change: %s &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;src/dynamic_config/dynamic_config.go 定义了全局配置信息的加载及动态监控方法，init 函数为初始化执行的脚本，initConfig 为初始化当前配置，dynamicConfig 为冬天监听，通过 viper 的内部方法 WatchConfig 实现。&lt;/p&gt;
&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;DynamicConfigDemo/src/dynamic_config&quot;&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;github.com/gin-gonic/gin&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;gin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SetMode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReleaseMode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Default&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GET&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/ping&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Current redis host is: &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dynamic_config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GlobalConfig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;service.redis.host&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;JSON&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
			&lt;span class=&quot;m&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;H&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
				&lt;span class=&quot;s&quot;&gt;&quot;message&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;You are welcome!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;:9292&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;main.go 为主函数，调用 gin 包定义 web server 服务，实现了一个简单的 http server 服务器，每次请求发送时会打印配置的 redis host 信息。&lt;/p&gt;

&lt;h2 id=&quot;调用示例&quot;&gt;调用示例&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;第一次调用，打印出当前 redis host 为 127.0.0.1&lt;/li&gt;
  &lt;li&gt;随后我们将 redis host 修改为 127.0.0.2&lt;/li&gt;
  &lt;li&gt;src/dynamic_config/dynamic_config.go 文件中的如下代码 GlobalConfig.OnConfigChange(func(event fsnotify.Event) { fmt.Printf(“Detect config change: %s \n”, event.String()) }) 监控到配置文件变更时会输出变更通知，如图中红框所示；&lt;/li&gt;
  &lt;li&gt;第二次调用时，则打印出最新配置的 redis host 信息&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/golang_viper_file_reload.png&quot; alt=&quot;golang_viper_file_reload&quot; /&gt;&lt;/p&gt;</content><author><name>Lewin</name></author><category term="golang" /><category term="viper" /><category term="file" /><category term="reload" /><summary type="html">概述 在写 web server 时，往往需要引入各种各样的配置信息，如依赖的其他中间件（redis、elasticsearch）等，一旦这些服务发生变更，我们需要重新启动 web server，以使配置生效。在 Golang 中，基于 viper 的动态配置就可以省去这些繁琐的步骤了。接下来用一个示例来说明如何使用 viper 的配置热加载：</summary></entry><entry><title type="html">gRPC</title><link href="https://lewinz.org/2021/08/01/google-grpc/" rel="alternate" type="text/html" title="gRPC" /><published>2021-08-01T00:00:00+08:00</published><updated>2021-08-01T00:00:00+08:00</updated><id>https://lewinz.org/2021/08/01/google-grpc</id><content type="html" xml:base="https://lewinz.org/2021/08/01/google-grpc/">&lt;p&gt;gRPC 是一个高性能、通用的开源 RPC 框架，其由 Google 主要面向移动应用开发并基于 HTTP/2 协议标准而设计，基于 ProtoBuf (Protocol Buffers) 序列化协议开发，且支持众多开发语言。&lt;/p&gt;

&lt;p&gt;gRPC 是基于 HTTP/2 协议的，要深刻理解 gRPC，理解下 HTTP/2 是必要的，这里先简单介绍一下 HTTP/2 相关的知识，然后再介绍下 gRPC 是如何基于 HTTP/2 构建的。&lt;/p&gt;

&lt;h2 id=&quot;http1x&quot;&gt;HTTP/1.x&lt;/h2&gt;
&lt;p&gt;HTTP 协议可以算是现阶段 Web 上面最通用的协议了，在之前很长一段时间，很多应用都是基于 HTTP/1.x 协议，HTTP/1.x 协议是一个文本协议，可读性非常好，但其实并不高效，笔者主要碰到过几个问题：&lt;/p&gt;
&lt;h3 id=&quot;parser&quot;&gt;Parser&lt;/h3&gt;
&lt;p&gt;如果要解析一个完整的 HTTP 请求，首先我们需要能正确的读出 HTTP header。HTTP header 各个 fields 使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\r\n&lt;/code&gt; 分隔，然后跟 body 之间使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\r\n\r\n&lt;/code&gt; 分隔。&lt;/p&gt;

&lt;p&gt;解析完 header 之后，我们才能从 header 里面的 content-length 拿到 body 的 size，从而读取 body。&lt;/p&gt;

&lt;p&gt;这套流程其实并不高效，因为我们需要读取多次，才能将一个完整的 HTTP 请求给解析出来，虽然在代码实现上面，有很多优化方式，譬如：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;一次将一大块数据读取到 buffer 里面避免多次 IO read
读取的时候直接匹配 \r\n 的方式流式解析&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;但上面的方式对于高性能服务来说，终归还是会有开销。其实最主要的问题在于，HTTP/1.x 的协议是文本协议，&lt;strong&gt;是给人看的&lt;/strong&gt;，对机器不友好，如果要对机器友好，二进制协议才是更好的选择。&lt;/p&gt;

&lt;p&gt;如果大家对解析 HTTP/1.x 很感兴趣，可以研究下 http-parser，一个非常高效小巧的 C library，见过不少框架都是集成了这个库来处理 HTTP/1.x 的。&lt;/p&gt;

&lt;h3 id=&quot;requestresponse&quot;&gt;Request/Response&lt;/h3&gt;
&lt;p&gt;HTTP/1.x 另一个问题就在于它的交互模式，&lt;strong&gt;一个连接每次只能一问一答&lt;/strong&gt;，也就是 client 发送了 request 之后，必须等到 response，才能继续发送下一次请求。&lt;/p&gt;

&lt;p&gt;这套机制是非常简单，但会造成网络连接利用率不高。如果需要同时进行大量的交互，client 需要跟 server 建立多条连接，但连接的建立也是有开销的，所以为了性能，通常这些连接都是长连接一直保活的，虽然对于 server 来说同时处理百万连接也没啥太大的挑战，但终归效率不高。&lt;/p&gt;

&lt;h3 id=&quot;push&quot;&gt;Push&lt;/h3&gt;
&lt;p&gt;用 HTTP/1.x 做过推送的同学，大概就知道有多么的痛苦，因为 HTTP/1.x 并没有推送机制。所以通常两种做法：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Long polling 方式,也就是直接给 server 挂一个连接，等待一段时间（譬如 1 分钟），如果 server 有返回或者超时，则再次重新 poll。&lt;/li&gt;
  &lt;li&gt;Web-socket，通过 upgrade 机制显式的将这条 HTTP 连接变成裸的 TCP，进行双向交互。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;相比 Long polling，笔者还是更喜欢 web-socket 一点，毕竟更加高效，只是 web-socket 后面的交互并不是传统意义上面的 HTTP 了。&lt;/p&gt;

&lt;h2 id=&quot;http2&quot;&gt;HTTP/2&lt;/h2&gt;
&lt;p&gt;虽然 HTTP/1.x 协议可能仍然是当今互联网运用最广泛的协议，但随着 Web 服务规模的不断扩大，HTTP/1.x 越发显得捉紧见拙，我们急需另一套更好的协议来构建我们的服务，于是就有了 HTTP/2。&lt;/p&gt;

&lt;p&gt;HTTP/2 是一个二进制协议，这也就意味着它的可读性几乎为 0，但幸运的是，我们还是有很多工具，譬如 Wireshark， 能够将其解析出来。&lt;/p&gt;

&lt;p&gt;在了解 HTTP/2 之前，需要知道一些通用术语：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Stream： 一个双向流，一条连接可以有多个 streams。&lt;/li&gt;
  &lt;li&gt;Message： 也就是逻辑上面的 request，response。&lt;/li&gt;
  &lt;li&gt;Frame:：数据传输的最小单位。每个 Frame 都属于一个特定的 stream 或者整个连接。一个 message 可能有多个 frame 组成。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;frame-format&quot;&gt;Frame Format&lt;/h3&gt;
&lt;p&gt;Frame 是 HTTP/2 里面最小的数据传输单位，一个 Frame 定义如下（直接从官网 copy 的）：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Flag 和 R：保留位，可以先不管。
Stream Identifier：标识所属的 stream，如果为 0，则表示这个 frame 属于整条连接。
Frame Payload：根据不同 Type 有不同的格式。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;可以看到，Frame 的格式定义还是非常的简单，按照官方协议，可以非常方便的写一个出来。&lt;/p&gt;

&lt;h3 id=&quot;multiplexing&quot;&gt;Multiplexing&lt;/h3&gt;
&lt;p&gt;HTTP/2 通过 stream 支持了连接的多路复用，提高了连接的利用率。Stream 有很多重要特性：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;一条连接可以包含多个 streams，多个 streams 发送的数据互相不影响。&lt;/li&gt;
  &lt;li&gt;Stream 可以被 client 和 server 单方面或者共享使用。&lt;/li&gt;
  &lt;li&gt;Stream 可以被任意一段关闭。&lt;/li&gt;
  &lt;li&gt;Stream 会确定好发送 frame 的顺序，另一端会按照接受到的顺序来处理。&lt;/li&gt;
  &lt;li&gt;Stream 用一个唯一 ID 来标识。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这里再说一下 Stream ID，如果是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;client&lt;/code&gt; 创建的 stream，ID 就是&lt;strong&gt;奇数&lt;/strong&gt;，如果是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;server&lt;/code&gt; 创建的，ID 就是&lt;strong&gt;偶数&lt;/strong&gt;。ID 0x00 和 0x01 都有特定的使用场景。&lt;/p&gt;

&lt;p&gt;Stream ID 不可能被重复使用，如果一条连接上面 ID 分配完了，client 会新建一条连接。而 server 则会给 client 发送一个 GOAWAY frame 强制让 client 新建一条连接。&lt;/p&gt;

&lt;p&gt;为了更大的提高一条连接上面的 stream 并发，可以考虑调大 SETTINGS_MAX_CONCURRENT_STREAMS，在 TiKV 里面，我们就遇到过这个值比较小，整体吞吐上不去的问题。&lt;/p&gt;

&lt;p&gt;这里还需要注意，虽然一条连接上面能够处理更多的请求了，但一条连接远远是不够的。一条连接通常只有一个线程来处理，所以并不能充分利用服务器多核的优势。同时，每个请求编解码还是有开销的，所以用一条连接还是会出现瓶颈。&lt;/p&gt;

&lt;p&gt;在 TiKV 有一个版本中，我们就过分相信一条连接跑多 streams 这种方式没有问题，就让 client 只用一条连接跟 TiKV 交互，结果发现性能完全没法用，不光处理连接的线程 CPU 跑满，整体的性能也上不去，后来我们换成了多条连接，情况才好转。&lt;/p&gt;

&lt;h3 id=&quot;priority&quot;&gt;Priority&lt;/h3&gt;
&lt;p&gt;因为一条连接允许多个 streams 在上面发送 frame，那么在一些场景下面，我们还是希望 stream 有优先级，方便对端为不同的请求分配不同的资源。譬如对于一个 Web 站点来说，优先加载重要的资源，而对于一些不那么重要的图片啥的，则使用低的优先级。&lt;/p&gt;

&lt;p&gt;我们还可以设置 Stream Dependencies，形成一棵 streams priority tree。假设 Stream A 是 parent，Stream B 和 C 都是它的孩子，B 的 weight 是 4，C 的 weight 是 12，假设现在 A 能分配到所有的资源，那么后面 B 能分配到的资源只有 C 的 1/3。&lt;/p&gt;

&lt;h3 id=&quot;flow-control&quot;&gt;Flow Control&lt;/h3&gt;
&lt;p&gt;HTTP/2 也支持流控，如果 sender 端发送数据太快，receiver 端可能因为太忙，或者压力太大，或者只想给特定的 stream 分配资源，receiver 端就可能不想处理这些数据。譬如，如果 client 给 server 请求了一个视频，但这时候用户暂停观看了，client 就可能告诉 server 别再发送数据了。&lt;/p&gt;

&lt;p&gt;虽然 TCP 也有 flow control，但它仅仅只对一个连接有效果。HTTP/2 在一条连接上面会有多个 streams，有时候，我们仅仅只想对一些 stream 进行控制，所以 HTTP/2 单独提供了流控机制。Flow control 有如下特性：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Flow control 是单向的。Receiver 可以选择给 stream 或者整个连接设置 window size。&lt;/li&gt;
  &lt;li&gt;Flow control 是基于信任的。Receiver 只是会给 sender 建议它的初始连接和 stream 的 flow control window size。&lt;/li&gt;
  &lt;li&gt;Flow control 不可能被禁止掉。当 HTTP/2 连接建立起来之后，client 和 server 会交换 SETTINGS frames，用来设置 flow control window size。&lt;/li&gt;
  &lt;li&gt;Flow control 是 hop-by-hop，并不是 end-to-end 的，也就是我们可以用一个中间人来进行 flow control。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这里需要注意，HTTP/2 默认的 window size 是 64 KB，实际这个值太小了，在 TiKV 里面我们直接设置成 1 GB。&lt;/p&gt;

&lt;h3 id=&quot;hpack&quot;&gt;HPACK&lt;/h3&gt;
&lt;p&gt;在一个 HTTP 请求里面，我们通常在 header 上面携带很多该请求的元信息，用来描述要传输的资源以及它的相关属性。在 HTTP/1.x 时代，我们采用纯文本协议，并且使用 \r\n 来分隔，如果我们要传输的元数据很多，就会导致 header 非常的庞大。&lt;/p&gt;

&lt;p&gt;另外，多数时候，在一条连接上面的多数请求，其实 header 差不了多少，譬如我们第一个请求可能 GET /a.txt，后面紧接着是 GET /b.txt，两个请求唯一的区别就是 URL path 不一样，但我们仍然要将其他所有的 fields 完全发一遍。&lt;/p&gt;

&lt;p&gt;HTTP/2 为了结果这个问题，使用了 HPACK。虽然 HPACK 的 RFC 文档 看起来比较恐怖，但其实原理非常的简单易懂。&lt;/p&gt;

&lt;p&gt;HPACK 提供了一个静态和动态的 table，静态 table 定义了通用的 HTTP header fields，譬如 method，path 等。发送请求的时候，只要指定 field 在静态 table 里面的索引，双方就知道要发送的 field 是什么了。&lt;/p&gt;

&lt;p&gt;对于动态 table，初始化为空，如果两边交互之后，发现有新的 field，就添加到动态 table 上面，这样后面的请求就可以跟静态 table 一样，只需要带上相关的 index 就可以了。&lt;/p&gt;

&lt;p&gt;同时，为了减少数据传输的大小，使用 Huffman 进行编码。这里就不再详细说明 HPACK 和 Huffman 如何编码了。&lt;/p&gt;

&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;上面只是大概列举了一些 HTTP/2 的特性，还有一些，譬如 push，以及不同的 frame 定义等都没有提及，大家感兴趣，可以自行参考 HTTP/2 RFC 文档。&lt;/p&gt;

&lt;h2 id=&quot;grpc&quot;&gt;gRPC&lt;/h2&gt;
&lt;p&gt;gRPC 是 Google 基于 HTTP/2 以及 protobuf 的，要了解 gRPC 协议，只需要知道 gRPC 是如何在 HTTP/2 上面传输就可以了。&lt;/p&gt;

&lt;p&gt;gRPC 通常有四种模式，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unary&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;client streaming&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;server streaming&lt;/code&gt; 以及 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bidirectional streaming&lt;/code&gt;，对于底层 HTTP/2 来说，它们都是 stream，并且仍然是一套 request + response 模型。&lt;/p&gt;

&lt;h3 id=&quot;request&quot;&gt;Request&lt;/h3&gt;
&lt;p&gt;gRPC 的 request 通常包含 Request-Headers, 0 或者多个 Length-Prefixed-Message 以及 EOS。&lt;/p&gt;

&lt;p&gt;Request-Headers 直接使用的 HTTP/2 headers，在 HEADERS 和 CONTINUATION frame 里面派发。定义的 header 主要有 Call-Definition 以及 Custom-Metadata。Call-Definition 里面包括 Method（其实就是用的 HTTP/2 的 POST），Content-Type 等。而 Custom-Metadata 则是应用层自定义的任意 key-value，key 不建议使用 grpc- 开头，因为这是为 gRPC 后续自己保留的。&lt;/p&gt;

&lt;p&gt;Length-Prefixed-Message 主要在 DATA frame 里面派发，它有一个 Compressed flag 用来表示该 message 是否压缩，如果为 1，表示该 message 采用了压缩，而压缩算啊定义在 header 里面的 Message-Encoding 里面。然后后面跟着四字节的 message length 以及实际的 message。&lt;/p&gt;

&lt;p&gt;EOS（end-of-stream） 会在最后的 DATA frame 里面带上了 END_STREAM 这个 flag。用来表示 stream 不会再发送任何数据，可以关闭了。&lt;/p&gt;

&lt;h3 id=&quot;response&quot;&gt;Response&lt;/h3&gt;
&lt;p&gt;Response 主要包含 Response-Headers，0 或者多个 Length-Prefixed-Message 以及 Trailers。如果遇到了错误，也可以直接返回 Trailers-Only。&lt;/p&gt;

&lt;p&gt;Response-Headers 主要包括 HTTP-Status，Content-Type 以及 Custom-Metadata 等。Trailers-Only 也有 HTTP-Status ，Content-Type 和 Trailers。Trailers 包括了 Status 以及 0 或者多个 Custom-Metadata。&lt;/p&gt;

&lt;p&gt;HTTP-Status 就是我们通常的 HTTP 200，301，400 这些，很通用就不再解释。Status 也就是 gRPC 的 status， 而 Status-Message 则是 gRPC 的 message。Status-Message 采用了 Percent-Encoded 的编码方式，具体参考这里。&lt;/p&gt;

&lt;p&gt;如果在最后收到的 HEADERS frame 里面，带上了 Trailers，并且有 END_STREAM 这个 flag，那么就意味着 response 的 EOS。&lt;/p&gt;

&lt;h3 id=&quot;protobuf&quot;&gt;Protobuf&lt;/h3&gt;
&lt;p&gt;gRPC 的 service 接口是基于 protobuf 定义的，我们可以非常方便的将 service 与 HTTP/2 关联起来。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Path : /Service-Name/{method name}&lt;/li&gt;
  &lt;li&gt;Service-Name : ?( {proto package name} “.” ) {service name}&lt;/li&gt;
  &lt;li&gt;Message-Type : {fully qualified proto message name}&lt;/li&gt;
  &lt;li&gt;Content-Type : “application/grpc+proto”&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Lewin</name></author><category term="gRPC" /><summary type="html">gRPC 是一个高性能、通用的开源 RPC 框架，其由 Google 主要面向移动应用开发并基于 HTTP/2 协议标准而设计，基于 ProtoBuf (Protocol Buffers) 序列化协议开发，且支持众多开发语言。</summary></entry><entry><title type="html">nova 虚拟机镜像从创建到文件系统 resize 完整流程</title><link href="https://lewinz.org/2021/08/01/openstack-nova-image-resize/" rel="alternate" type="text/html" title="nova 虚拟机镜像从创建到文件系统 resize 完整流程" /><published>2021-08-01T00:00:00+08:00</published><updated>2021-08-01T00:00:00+08:00</updated><id>https://lewinz.org/2021/08/01/openstack-nova-image-resize</id><content type="html" xml:base="https://lewinz.org/2021/08/01/openstack-nova-image-resize/">&lt;h2 id=&quot;虚拟机镜像的创建和-resize-流程&quot;&gt;虚拟机镜像的创建和 resize 流程&lt;/h2&gt;
&lt;p&gt;nova 创建虚拟机涉及的组件比较多，调用比较复杂，这里只列出跟虚拟机镜像创建相关的流程，方便理清虚拟机状态变化的整个流程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;nova-api&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;api&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;openstack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;servers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ServersController&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 接受创建请求，解析出 image_uuid
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;api&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;API&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;api&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;API&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_create_instance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 调用 glance api 获取 image 对象
&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;conductor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;api&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LocalComputeTaskAPI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;build_instances&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;conductor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;manager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConductorManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;build_instances&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 此处虽然接收 block_device_mapping 参数，但是是为了兼容旧版，没有使用。实际通过 nova.objects.BlockDeviceMappingList.get_by_instance_uuid() 获取
&lt;/span&gt;          &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rpcapi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ComputeAPI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;build_and_run_instance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 使用 cast 方法调用 nova-compute 的 build_and_run_instance 方法。
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;nova-compute&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;manager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ComputeManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;build_and_run_instance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;manager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ComputeManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_do_build_and_run_instance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;manager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ComputeManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_build_and_run_instance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

      &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;manager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ComputeManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_build_resources&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;manager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ComputeManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_prep_block_device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;virt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block_device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;attach_block_devices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;virt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block_device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DriverImageBlockDevice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;attach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;volume&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cinder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;API&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

      &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;virt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libvirt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;driver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LibvirtDriver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spwan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;virt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libvirt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;driver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LibvirtDriver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_create_image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 此处会判断如果不是从 volume 启动，则调用 imagebackend 去创建虚拟机镜像
&lt;/span&gt;          &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;virt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libvirt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;driver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LibvirtDriver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_try_fetch_image_cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;virt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libvirt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;imagebackend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

              &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;virt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libvirt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;imagebackend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Rbd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;create_image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;virt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libvirt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;imagebackend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Rbd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;clone&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
                  &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;virt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libvirt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;storage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rbd_utils&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RBDDriver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;clone&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 创建虚拟机镜像，此处如果所使用的 image 后端不支持 clone，或者镜像不可 clone（比如 rbd 中不是 raw 格式的镜像），会触发异常，create_image 调用下面的 fetch_image 函数
&lt;/span&gt;                
                &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;virt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libvirt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;utils&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fetch_image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
                  &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;virt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;images&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fetch_to_raw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;virt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;images&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
                      &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;API&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;download&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;virt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;images&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;convert_image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
                      &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;virt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;images&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_convert_image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 将镜像拷贝到本地的/var/lib/instances/_base/目录下，文件名为 md5(image).part，然后用 qemu-img convert 转换为 raw 格式，名为 md5(image).converted，最后重命名为 md5(image)
&lt;/span&gt;                &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;virt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libvirt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;storage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rbd_utils&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RBDDriver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;import_image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 这一步是在 clone 失败，执行 fetch_image 的情况下，判断虚拟机镜像不存在，执行 import_image 将 fetch 的镜像导入到 RBD 后端作为虚拟机镜像。
&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;virt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libvirt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;storage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rbd_utils&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RBDDriver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 调整虚拟机镜像大小
&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;nova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;virt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libvirt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;imagebackend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Rbd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resize_image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 调整虚拟机镜像大小，RBD 后端实际上在 create_image 时已经 resize 了，不会执行这一步，这里应该是为了确保其他后端能够正确设置虚拟机镜像的大小
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;为了便于分析，用 graphviz 画了在 nova-compute 的调用关系图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/openstack_nova_image_resize.png&quot; alt=&quot;openstack_nova_image_resize&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注：存储后端用的是 Ceph，所以调用的后端代码是 nova.virt.libvirt.imagebackend.Rbd，如果 nova 使用了不同的后端，比如本地的 qcow2 镜像、raw 镜像、lvm 等，只需要对照 nova.virt.libvirt.imagebackend 中提供的对应实现，出入不会太大，因为它们都继承 nova.virt.libvirt.imagebackend.Image，有相同的接口。&lt;/p&gt;

&lt;p&gt;至此，虚拟机的镜像已经创建完毕，并且 resize 为 flavor 所设置的大小。后面是虚拟机启动后，resize 分区和文件系统的过程。&lt;/p&gt;

&lt;p&gt;一般虚拟机镜像中会安装 cloud-init 或者配置启动脚本来对虚拟机做初始化配置。在 cloud-init 或启动脚本中调用 growpart 和 resizefs 来完成分区和文件系统的扩容。&lt;/p&gt;

&lt;h2 id=&quot;分区的-resize&quot;&gt;分区的 resize&lt;/h2&gt;
&lt;p&gt;cloud-init 支持使用 growpart 和 gpart 对分区进行扩容，时配置的 mode 而定，默认会按顺序检测系统中是否安装了这两个工具，使用第一个找到的。&lt;/p&gt;

&lt;p&gt;growpart 是 AWS 的扩展分区工具，它分别使用 sfdisk 和 sgdisk 对 MBR 和 GPT 分区表操作，先将分区表导出，然后改写分区的其实扇区位置，最后将改写后的分区表导入，完成分区的扩容。&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# growpart [diskdev] [partnum]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;gpart 是 FreeBSD 推出的磁盘管理工具，GPT 分区表将 metadata 的主本保存在硬盘的开始，将副本保存在硬盘的末尾，所以当虚拟机镜像被扩容，相当于硬盘的容量变大，在 GPT 看来末尾的 metadata 副本丢失了，需要先执行 recover 命令恢复，然后再进行扩容。&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# gpart recover [diskdev]&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# gpart resize -i [partnum] [diskdev]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;文件系统的-resize&quot;&gt;文件系统的 resize&lt;/h2&gt;
&lt;p&gt;cloud-init 通过依次尝试解析 /proc/$$/mountinfo、/etc/mtab 和 mount 命令的输出，来获取根目录所挂载的分区和文件系统格式。&lt;/p&gt;

&lt;p&gt;针对不通的文件系统，使用不同的命令扩容：&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# resize2fs [devpth]    # ext 文件系统&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# xfs_growfs [devpth]    # xfs 文件系统&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# growfs [devpth]        # ufs 文件系统&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# btrfs filesystem resize max [mount_point]    # btrfs 文件系统&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Lewin</name></author><category term="openstack" /><category term="nova" /><category term="image" /><category term="resize" /><summary type="html">虚拟机镜像的创建和 resize 流程 nova 创建虚拟机涉及的组件比较多，调用比较复杂，这里只列出跟虚拟机镜像创建相关的流程，方便理清虚拟机状态变化的整个流程。</summary></entry><entry><title type="html">SLB 压力测试</title><link href="https://lewinz.org/2021/08/01/slb-pressure-test/" rel="alternate" type="text/html" title="SLB 压力测试" /><published>2021-08-01T00:00:00+08:00</published><updated>2021-08-01T00:00:00+08:00</updated><id>https://lewinz.org/2021/08/01/slb-pressure-test</id><content type="html" xml:base="https://lewinz.org/2021/08/01/slb-pressure-test/">&lt;h2 id=&quot;如何进行压力测试-concept_lqx_1fd_xdb-concept&quot;&gt;如何进行压力测试 {#concept_lqx_1fd_xdb .concept}&lt;/h2&gt;
&lt;h3 id=&quot;压力测试性能概述-section_rnj_cfd_xdb-section&quot;&gt;压力测试性能概述 {#section_rnj_cfd_xdb .section}&lt;/h3&gt;
&lt;p&gt;四层负载均衡采用开源软件 LVS（Linux Virtual Server）+ Keepalived 的方式实现负载均衡，七层负载均衡由 Tengine 实现。其中四层监听经过 LVS 后直接到达后端服务器，而七层监听经过 LVS 后，还需要再经过 Tengine，最后达到后端服务器。七层比四层多了一个处理环节，因此，七层性能没有四层性能好。&lt;/p&gt;

&lt;p&gt;如果您使用七层监听进行压来测试，发现根本跑不上去，挂了两台 ECS 的七层负载均衡监听性能还不如一台 ECS 的性能，除了七层本身的性能比四层低外，以下情况也可能会造成七层测压性能低：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;客户端端口不足&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;尤其容易发生在压测的时候，客户端端口不足会导致建立连接失败，负载均衡默认会抹除 TCP 连接的 timestamp 属性，Linux 协议栈的 tw_reuse(time_wait 状态连接复用) 无法生效，time_wait 状态连接堆积导致客户端端口不足。&lt;/p&gt;

&lt;p&gt;解决方法：客户端端使用长连接代替短连接。使用 RST 报文断开连接（socket 设置 SO_LINGER 属性），而不是发 FIN 包这种方式断开。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;后端服务器 accept 队列满&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;后端服务器 accept 队列满，导致后端服务器不回复 syn_ack 报文，客户端超时&lt;/p&gt;

&lt;p&gt;解决方法：默认的 net.core.somaxconn 的值为 128，执行 sysctl -w net.core.somaxconn=1024 更改它的值，并重启后端服务器上的应用。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;后端服务器连接过多&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由于架构设计的原因，使用七层负载均衡时，用户长连接经过 Tengine 后变成短连接，可能造成后端服务器连接过多，从而表现为压测性能上不去。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;后端服务器依赖的应用成为瓶颈&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;请求经过负载均衡达到后端服务器后，后端服务器本身负载都正常，但由于所有的后端服务器上的应用又依赖其它应用，比如数据库，数据库成为瓶颈，也会引起性能低。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;后端服务器的健康检查状态异常&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;尤其在压测的时候容易忽略后端服务器的健康检查状态，如果有后端服务器健康检查失败或者健康检查状态经常跳跃（好到坏，又从坏到好，反复变化）也会导致性能跑不上去。&lt;/p&gt;

&lt;h3 id=&quot;压力测试建议-section_unj_cfd_xdb-section&quot;&gt;压力测试建议 {#section_unj_cfd_xdb .section}&lt;/h3&gt;
&lt;p&gt;在进行压力测试，注意如下配置：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;压测负载均衡转发能力建议使用短链接&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一般来说压测除了验证会话保持，均衡性等功能外，主要想验证的是负载均衡的转发能力，因此使用短链接比较合适，用于测试负载均衡和后端服务器处理能力。但使用短连接测试时注意上述的客户端端口不足问题。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;压测负载均衡吞吐量建议使用长连接，用于测试带宽上限或特殊业务&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;压测工具的超时时间建议设置为一个较小值（5 秒）。超时时间太大的话，测试结果会体现在平均 RT 加长，不利于判断压测水位是否已到达。超时时间调小，测试结果会体现在成功率上，便于快速判断压测水位。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;后端服务器提供一个静态网页用于压测，以避免应用逻辑带来的损耗&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;压测时，监听配置建议如下：&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;不开启会话保持功能，否则压力会集中在个别的后端服务器。&lt;/li&gt;
      &lt;li&gt;监听关闭健康检查功能，减少健康检查请求对后端服务器的访问请求。&lt;/li&gt;
      &lt;li&gt;用多个客户端进行进行压测最好多于 5 个，源 IP 分散，能够更好的模拟线上实际情况。
        &lt;h3 id=&quot;压力测试工具建议-section_xnj_cfd_xdb-section&quot;&gt;压力测试工具建议 {#section_xnj_cfd_xdb .section}&lt;/h3&gt;
        &lt;p&gt;不建议您使用 Apache ab 作为压力测试工具。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Apache ab 在大量并发场景下存在 3s，6s，9s 阶梯式停顿的现象。Apache ab 会通过判断 content length 来确定请求是否成功，而负载均衡挂载多台后端服务器时，返回的 content length 会不一致，导致测试结果有误。&lt;/p&gt;

&lt;p&gt;可以选择多个客户端作为压力测试源，测试结果清晰，并且可以通过配置监控，获取压力测试时后端服务器的性能数据。&lt;/p&gt;

&lt;h3 id=&quot;使用-pts-简单压测示例-section_ynj_cfd_xdb-section&quot;&gt;使用 PTS 简单压测示例 {#section_ynj_cfd_xdb .section}&lt;/h3&gt;
&lt;p&gt;创建一个负载均实例，添加两台 ECS 实例作为后端服务器，分别创建一个 TCP 监听和 HTTP 监听，后端端口设置为 80。ECS 服务器的配置为 CPU 1 核，内存 512M 使用 CentOS 6.3 64 位的操作系统。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;安装 Apache Web Server 提供 Web 服务。&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yum install -y httpd&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;初始化默认首页 index.html。&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;echo &quot;testvm&quot; &amp;gt; /var/www/html/index.html&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;启动 HTTP 服务。&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;service httpd start&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;访问本地的 80 端口，确认 Web 服务可用。&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;curl localhost&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 PTS 中创建测试脚本，开始压力测试。&lt;br /&gt;
注意关闭长连接和设置超时时间：&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;设置超时时间为 5 秒： PTS.HttpUtilities.setTimeout(5000)&lt;/li&gt;
      &lt;li&gt;关闭长连接： PTS.HttpUtilities.setKeepAlive(False)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>Lewin</name></author><category term="slb" /><category term="pressure" /><category term="test" /><summary type="html">如何进行压力测试 {#concept_lqx_1fd_xdb .concept} 压力测试性能概述 {#section_rnj_cfd_xdb .section} 四层负载均衡采用开源软件 LVS（Linux Virtual Server）+ Keepalived 的方式实现负载均衡，七层负载均衡由 Tengine 实现。其中四层监听经过 LVS 后直接到达后端服务器，而七层监听经过 LVS 后，还需要再经过 Tengine，最后达到后端服务器。七层比四层多了一个处理环节，因此，七层性能没有四层性能好。</summary></entry><entry><title type="html">ssl 证书生成</title><link href="https://lewinz.org/2021/08/01/ssl-cert/" rel="alternate" type="text/html" title="ssl 证书生成" /><published>2021-08-01T00:00:00+08:00</published><updated>2021-08-01T00:00:00+08:00</updated><id>https://lewinz.org/2021/08/01/ssl-cert</id><content type="html" xml:base="https://lewinz.org/2021/08/01/ssl-cert/">&lt;h2 id=&quot;用-openssl-生成-nginxkey&quot;&gt;用 openssl 生成 nginx.key&lt;/h2&gt;

&lt;p&gt;1.key 的生成
openssl genrsa -des3 -out server.key 2048
这样是生成 rsa 私钥，des3 算法，openssl 格式，2048 位强度。server.key 是密钥文件名。为了生成这样的密钥，需要一个至少四位的密码。
可以通过以下方法生成没有密码的 key:
openssl rsa -in server.key -out server.key
server.key 就是没有密码的版本了。&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;生成 CA 的 crt
openssl req -new -x509 -key server.key -out ca.crt -days 3650
生成的 ca.crt 文件是用来签署下面的 server.csr 文件。&lt;/li&gt;
  &lt;li&gt;csr 的生成方法
openssl req -new -key server.key -out server.csr
需要依次输入国家，地区，组织，email。最重要的是有一个 common name，可以写你的名字或者域名。如果为了 https 申请，这个必须和域名吻合，否则会引发浏览器警报。生成的 csr 文件交给 CA 签名后形成服务端自己的证书。&lt;/li&gt;
  &lt;li&gt;crt 生成方法
CSR 文件必须有 CA 的签名才可形成证书，可将此文件发送到 verisign 等地方由它验证，要交一大笔钱，何不自己做 CA 呢。
openssl x509 -req -days 3650 -in server.csr -CA ca.crt -CAkey server.key -CAcreateserial -out server.crt
输入 key 的密钥后，完成证书生成。-CA 选项指明用于被签名的 csr 证书，-CAkey 选项指明用于签名的密钥，-CAserial 指明序列号文件，而 - CAcreateserial 指明文件不存在时自动生成。
最后生成了私用密钥：server.key 和自己认证的 SSL 证书：server.crt
证书合并：
cat server.key server.crt &amp;gt; server.pem
     其中第一步生成的无密码 key 就是我们想要的 nginx.key
使用 StartSSL 免费 SSL 证书：
     登录网站：https://www.startssl.com
     找到 StartSSL Free，点击 Start Now
     这里提示需要登录，通过邮箱进行注册并登录
     然后在 Validations Wizard 这里选择要进行网站认证还是邮箱认证
     按照网站提示一步一步进行
提交 nginx.key 生成 nginx.crt 证书：
     在 StartSSL 审核通过后，会提示输入本地 key
     我们的需求是要配置 nginx 的 SSL 验证，将前面用 openssl 生成 nginx.key 添加到网站指定的输入框中，提交审核，等待网站审核通过
     网站审核通过后，会提示可以在 Tool Box 中下载以生成的证书
     下载后，得到一个以认证域名命名的压缩包
     解压缩后，包内有 ApacheServer.zip, IISServer.zip, NginxServer.zip, OtherServer.zip
     我们需要的文件在 NginxServer.zip 中，解压后得到 1_gjtest.parteam.cn_bundle.crt 文件
得到 crt 证书后，服务器上的设置：
     在服务器 /etc/nginx/ssl/ 文件夹下创建 gjtest.parteam.cn.crt 文件，用命令行 cat 命令查看        1_gjtest.parteam.cn_bundle.crt 文件，并将内容拷贝到 gjtest.parteam.cn.crt 中。
     在服务器 /etc/nginx/ssl/ 文件夹下创建 gjtest.parteam.cn.key 文件，将开始生成的 nginx.key 内容拷贝进去。
在 nginx 配置文件 /etc/nginx/conf.d/**.conf 的 443 端口监听 server 中，设置 SSL 安全监测：
ssl_certificate      ssl/gjtest_parteam_cn.crt;
ssl_certificate_key  ssl/gjtest_parteam_cn.key;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;ssl_ciphers          ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128    -GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES    256-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:    AES128-GCM-SHA256:AES256-GCM-SHA384:DES-CBC3-SHA;&lt;/p&gt;

&lt;p&gt;ssl_prefer_server_ciphers  on;&lt;/p&gt;

&lt;p&gt;ssl_protocols        TLSv1 TLSv1.1 TLSv1.2;
重新启动 nginx 服务，使得新的修改生效。
可能会出现以下错误信息：
error：nginx[15608]: nginx: [emerg] SSL_CTX_use_PrivateKey_file(“/etc/nginx/ssl/gjtest_parteam_cn.ke
       PS：检查 ssl 文件夹中的 key 和 crt 文件是否对照成对&lt;/p&gt;

&lt;p&gt;● nginx.service - A high performance web server and a reverse proxy server
Loaded: loaded (/lib/systemd/system/nginx.service; enabled; vendor preset: enabled)
Active: failed (Result: exit-code) since Thu 2016-11-10 15:13:17 CST; 5s ago
Process: 15430 ExecStop=/sbin/start-stop-daemon –quiet –stop –retry QUIT/5 –pidfile /run/nginx.pid (code=exited, status=0/SUCCE
Process: 929 ExecStart=/usr/sbin/nginx -g daemon on; master_process on; (code=exited, status=0/SUCCESS)
Process: 15532 ExecStartPre=/usr/sbin/nginx -t -q -g daemon on; master_process on; (code=exited, status=1/FAILURE)
Main PID: 951 (code=exited, status=0/SUCCESS)
Nov 10 15:13:17 iZ2zeipvbenilb2wia99kqZ systemd[1]: Stopped A high performance web server and a reverse proxy server.
Nov 10 15:13:17 iZ2zeipvbenilb2wia99kqZ systemd[1]: Starting A high performance web server and a reverse proxy server…
Nov 10 15:13:17 iZ2zeipvbenilb2wia99kqZ nginx[15532]: Enter PEM pass phrase:
Nov 10 15:13:17 iZ2zeipvbenilb2wia99kqZ nginx[15532]: nginx: [emerg] SSL_CTX_use_PrivateKey_file(“/etc/nginx/ssl/gjtest_parteam_cn.ke
Nov 10 15:13:17 iZ2zeipvbenilb2wia99kqZ nginx[15532]: nginx: configuration file /etc/nginx/nginx.conf test failed
Nov 10 15:13:17 iZ2zeipvbenilb2wia99kqZ systemd[1]: nginx.service: Control process exited, code=exited status=1
Nov 10 15:13:17 iZ2zeipvbenilb2wia99kqZ systemd[1]: Failed to start A high performance web server and a reverse proxy server.
Nov 10 15:13:17 iZ2zeipvbenilb2wia99kqZ systemd[1]: nginx.service: Unit entered failed state.
Nov 10 15:13:17 iZ2zeipvbenilb2wia99kqZ systemd[1]: nginx.service: Failed with result ‘exit-code’.
root@iZ2zeipvbenilb2wia99kqZ:/etc/nginx/ssl# service nginx restart
Job for nginx.service failed because the control process exited with error code. See “systemctl status nginx.service” and “journalctl -xe” for details.
PS：出现这样的错误时，
       1、openssl rsa -in server.key -out unserver.key
      输入一次私钥的密码：&lt;strong&gt;**&lt;/strong&gt;
      把 unserver.key 文件修改为 server.key
      重启 nginx 问题解决。
      2、openssl req -new -x509 -nodes -out server.crt -keyout server.key，重新生成 key（此处的 server 就是 nginx）&lt;/p&gt;

&lt;p&gt;阿里云开发文档
https://help.aliyun.com/document_detail/85969.html?spm=a2c4g.11186623.6.764.216b5cf9U3AU6K&lt;/p&gt;</content><author><name>Lewin</name></author><category term="ssl" /><category term="cert" /><category term="create" /><summary type="html">用 openssl 生成 nginx.key</summary></entry><entry><title type="html">Github 装逼指南 Travis CI 和 Codecov</title><link href="https://lewinz.org/2021/07/29/travis-ci-codecov/" rel="alternate" type="text/html" title="Github 装逼指南 Travis CI 和 Codecov" /><published>2021-07-29T00:00:00+08:00</published><updated>2021-07-29T00:00:00+08:00</updated><id>https://lewinz.org/2021/07/29/travis-ci-codecov</id><content type="html" xml:base="https://lewinz.org/2021/07/29/travis-ci-codecov/">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/travis_ci_codecov_1.png&quot; alt=&quot;travis_ci_codecov_1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;觉得挺酷的。打算在自己的开源组件中也整一套。
经过 Google 决定使用 TravisCI 来进行持续集成，Codecov 来统计单测覆盖率。&lt;/p&gt;

&lt;h2 id=&quot;travis-ci&quot;&gt;Travis CI&lt;/h2&gt;
&lt;p&gt;Travis CI 是国外的开源持续集成构建项目，支持 Github 项目。使用十分方便。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用 Github 账号登录 Travis CI；&lt;/li&gt;
  &lt;li&gt;登录之后会自动同步 Github 项目，选择需要使用 Travis CI 的项目&lt;/li&gt;
  &lt;li&gt;在项目的根目录新增.travis.yml 文件，内容如下：
``` sh
#指定运行环境
language: node_js
#指定 nodejs 版本，可以指定多个
node_js:
    &lt;ul&gt;
      &lt;li&gt;0.12.5&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;#运行的脚本命令
script:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;npm run ci&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;#指定分支，只有指定的分支提交时才会运行脚本
branches:
  only:
    - master&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
更多语法请看[这里](https://link.segmentfault.com/?url=https%3A%2F%2Fdocs.travis-ci.com%2F)。使用起来非常方便，这样当你每次向 github push 代码的时候，Travis CI 就会自动运行.travis.yml 里面的 script。自动进行编译以及运行单测。

由于 Travis CI 每次 build 之前都会运行 npm install 安装项目依赖的 npm 包，所以在提交代码的时候要保证把所有依赖的包都已经在 package.json 中声明了，否则 build 就会失败。

## Codecov
Codecov 是一个开源的测试结果展示平台，将测试结果可视化。Github 上许多开源项目都使用了 Codecov 来展示单测结果。

Codecov 跟 Travis CI 一样都支持 Github 账号登录，同样会同步 Github 中的项目。在 nodejs 环境下使用 Codecov 需要安装对于的 npm 包，运行下面这个命令进行安装：

`npm install codecov --save-dev`

这个包的作用是将我们运行单测产生的结果文件上传到 Codecov 上进行可视化展示。同时 codecov 支持的结果文件类型为 cobertura。所以需要保证单测执行的结果文件的类型为 cobertura。
前端项目进行单元测试推进 karma + 'jasmine' 的组合。这两个具体是什么东西大家 Google 一下就知道。使用 karma 可以通过简单的配置来运行单测。下面是我一个项目中的配置文件，供大家参考：
``` js
// Karma configuration
// Generated on Mon Feb 01 2016 21:34:22 GMT+0800 (中国标准时间)

module.exports = function(config) {
  config.set({

    // base path that will be used to resolve all patterns (eg. files, exclude)
    basePath: '',


    // frameworks to use
    // available frameworks: https://npmjs.org/browse/keyword/karma-adapter
    // 使用的测试框架 jasmine, requirejs 支持模块化加载
    frameworks: ['jasmine', 'requirejs'],


    // list of files / patterns to load in the browser
    files: [
        // karma 中用到进行 requirejs 配置的文件
        'test/test-main.js',
        // 测试中需要用到的文件，includeed 设为 false 表示在页面加载的时候不会加载相应的 js 文件，也就是可以通过 requirejs 进行异步加载
        {pattern: 'node_modules/jquery/dist/jquery.min.js', included: false},
        {pattern: 'node_modules/angular/angular.min.js', included: false},
        {pattern: 'node_modules/angular-mocks/angular-mocks.js', included: false},
        {pattern: 'src/bg-single-selector.js', included: false},
        {pattern: 'test/selector.spec.js', included: false}
    ],


    // list of files to exclude
    exclude: [
    ],


    // preprocess matching files before serving them to the browser
    // available preprocessors: https://npmjs.org/browse/keyword/karma-preprocessor
    // 针对 bg-single-selector.js 生成单测覆盖率结果
    preprocessors: {
        'src/bg-single-selector.js': 'coverage'
    },


    // test results reporter to use
    // possible values: 'dots', 'progress'
    // available reporters: https://npmjs.org/browse/keyword/karma-reporter
    // 测试结果的几种输出方式
    reporters: ['progress', 'coverage', 'verbose'],
    // 测试结果报告的类型
    coverageReporter:{
        reporters: [{
            type:'text-summary'
        }, {
            type: 'html',
            dir: 'test/coverage'
        }, {
            // 这就是 Codecov 支持的文件类型
            type: 'cobertura',
            subdir: '.',
            dir: 'test/coverage'
        }]
    },

    // web server port
    port: 9876,


    // enable / disable colors in the output (reporters and logs)
    colors: true,


    // level of logging
    // possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG
    logLevel: config.LOG_INFO,


    // enable / disable watching file and executing tests whenever any file changes
    autoWatch: true,

    // start these browsers
    // available browser launchers: https://npmjs.org/browse/keyword/karma-launcher
    browsers: ['PhantomJS'],
    // 运行测试依赖的插件
    plugins: [
        'karma-jasmine',
        'karma-coverage',
        'karma-verbose-reporter',
        'karma-phantomjs-launcher',
        'karma-requirejs'
    ],

    // Continuous Integration mode
    // if true, Karma captures browsers, runs the tests and exits
    singleRun: true
  })
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;通过 karma 进行单元测试，将命令写到.travis.yml 中就可以在每次 build 的时候运行单测，同时运行 codecov [cobertura-coverage.xml 路径] 就会把单测结果上传到 Codecov。在本地运行 codecov 会失败，需要将这个过程加入到 Travis CI 的 build 脚本中，才能成功上传。因为在本地运行就会被作为私有项目，对于私有项目在上传结果时需要加上 Codecov 提供的 token。&lt;/p&gt;

&lt;h2 id=&quot;在-github-中加入图标&quot;&gt;在 github 中加入图标&lt;/h2&gt;
&lt;p&gt;到了最后一步，Travis CI 和 Codecov 都提供图标链接来展示结果。我们只需要将图标链接加入到项目的 README 中就可以看到结果了。&lt;br /&gt;
对于 Travis CI 来说，点击下图中的图标：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/travis_ci_codecov_2.png&quot; alt=&quot;travis_ci_codecov_2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;就会弹出图标的地址。&lt;br /&gt;
对于 Codecov 来说，打开项目的设置列表就会看到，如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/travis_ci_codecov_3.png&quot; alt=&quot;travis_ci_codecov_3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后只需要将对应的链接加到 README 文件中就可以了。下面是最后的效果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/travis_ci_codecov_4.png&quot; alt=&quot;travis_ci_codecov_4&quot; /&gt;&lt;/p&gt;</content><author><name>Lewin</name></author><category term="github" /><category term="travis" /><category term="codecov" /><summary type="html"></summary></entry><entry><title type="html">http 网络状态码大全</title><link href="https://lewinz.org/2021/07/28/http-status-code/" rel="alternate" type="text/html" title="http 网络状态码大全" /><published>2021-07-28T00:00:00+08:00</published><updated>2021-07-28T00:00:00+08:00</updated><id>https://lewinz.org/2021/07/28/http-status-code</id><content type="html" xml:base="https://lewinz.org/2021/07/28/http-status-code/">&lt;h2 id=&quot;1xx临时响应&quot;&gt;1xx（临时响应）&lt;/h2&gt;
&lt;p&gt;表示临时响应并需要请求者继续执行操作的状态代码。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;代码&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
      &lt;th&gt;详细&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;100&lt;/td&gt;
      &lt;td&gt;继续&lt;/td&gt;
      &lt;td&gt;请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;101&lt;/td&gt;
      &lt;td&gt;切换协议&lt;/td&gt;
      &lt;td&gt;请求者已要求服务器切换协议，服务器已确认并准备切换&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;2xx-成功&quot;&gt;2xx （成功）&lt;/h2&gt;
&lt;p&gt;表示成功处理了请求的状态代码。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;代码&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
      &lt;th&gt;详细&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;200&lt;/td&gt;
      &lt;td&gt;成功&lt;/td&gt;
      &lt;td&gt;服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;201&lt;/td&gt;
      &lt;td&gt;已创建&lt;/td&gt;
      &lt;td&gt;请求成功并且服务器创建了新的资源&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;202&lt;/td&gt;
      &lt;td&gt;已接受&lt;/td&gt;
      &lt;td&gt;服务器已接受请求，但尚未处理&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;203&lt;/td&gt;
      &lt;td&gt;非授权信息&lt;/td&gt;
      &lt;td&gt;服务器已成功处理了请求，但返回的信息可能来自另一来源&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;204&lt;/td&gt;
      &lt;td&gt;无内容&lt;/td&gt;
      &lt;td&gt;服务器成功处理了请求，但没有返回任何内容&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;205&lt;/td&gt;
      &lt;td&gt;重置内容&lt;/td&gt;
      &lt;td&gt;服务器成功处理了请求，但没有返回任何内容&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;206&lt;/td&gt;
      &lt;td&gt;部分内容&lt;/td&gt;
      &lt;td&gt;服务器成功处理了部分 GET 请求&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;3xx-重定向&quot;&gt;3xx （重定向）&lt;/h2&gt;
&lt;p&gt;表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;代码&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
      &lt;th&gt;详细&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;300&lt;/td&gt;
      &lt;td&gt;多种选择&lt;/td&gt;
      &lt;td&gt;针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;301&lt;/td&gt;
      &lt;td&gt;永久移动&lt;/td&gt;
      &lt;td&gt;请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;302&lt;/td&gt;
      &lt;td&gt;临时移动&lt;/td&gt;
      &lt;td&gt;服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;303&lt;/td&gt;
      &lt;td&gt;查看其他位置&lt;/td&gt;
      &lt;td&gt;请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;304&lt;/td&gt;
      &lt;td&gt;未修改&lt;/td&gt;
      &lt;td&gt;自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;305&lt;/td&gt;
      &lt;td&gt;使用代理&lt;/td&gt;
      &lt;td&gt;请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;307&lt;/td&gt;
      &lt;td&gt;临时重定向&lt;/td&gt;
      &lt;td&gt;服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;4xx请求错误&quot;&gt;4xx（请求错误）&lt;/h2&gt;
&lt;p&gt;这些状态代码表示请求可能出错，妨碍了服务器的处理。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;代码&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
      &lt;th&gt;详细&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;400&lt;/td&gt;
      &lt;td&gt;错误请求&lt;/td&gt;
      &lt;td&gt;服务器不理解请求的语法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;401&lt;/td&gt;
      &lt;td&gt;未授权&lt;/td&gt;
      &lt;td&gt;请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;403&lt;/td&gt;
      &lt;td&gt;禁止&lt;/td&gt;
      &lt;td&gt;对资源的访问权限不足&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;404&lt;/td&gt;
      &lt;td&gt;未找到&lt;/td&gt;
      &lt;td&gt;服务器找不到请求的网页&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;405&lt;/td&gt;
      &lt;td&gt;方法禁用&lt;/td&gt;
      &lt;td&gt;禁用请求中指定的方法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;406&lt;/td&gt;
      &lt;td&gt;不接受&lt;/td&gt;
      &lt;td&gt;无法使用请求的内容特性响应请求的网页&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;407&lt;/td&gt;
      &lt;td&gt;需要代理授权&lt;/td&gt;
      &lt;td&gt;此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;408&lt;/td&gt;
      &lt;td&gt;请求超时&lt;/td&gt;
      &lt;td&gt;服务器等候请求时发生超时&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;409&lt;/td&gt;
      &lt;td&gt;冲突&lt;/td&gt;
      &lt;td&gt;服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;410&lt;/td&gt;
      &lt;td&gt;已删除&lt;/td&gt;
      &lt;td&gt;如果请求的资源已永久删除，服务器就会返回此响应&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;411&lt;/td&gt;
      &lt;td&gt;需要有效长度&lt;/td&gt;
      &lt;td&gt;服务器不接受不含有效内容长度标头字段的请求&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;412&lt;/td&gt;
      &lt;td&gt;未满足前提条件&lt;/td&gt;
      &lt;td&gt;服务器未满足请求者在请求中设置的其中一个前提条件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;413&lt;/td&gt;
      &lt;td&gt;请求实体过大&lt;/td&gt;
      &lt;td&gt;服务器无法处理请求，因为请求实体过大，超出服务器的处理能力&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;414&lt;/td&gt;
      &lt;td&gt;请求的 URI 过长&lt;/td&gt;
      &lt;td&gt;请求的 URI（通常为网址）过长，服务器无法处理&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;415&lt;/td&gt;
      &lt;td&gt;不支持的媒体类型&lt;/td&gt;
      &lt;td&gt;请求的格式不受请求页面的支持&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;416&lt;/td&gt;
      &lt;td&gt;请求范围不符合要求&lt;/td&gt;
      &lt;td&gt;如果页面无法提供请求的范围，则服务器会返回此状态代码&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;417&lt;/td&gt;
      &lt;td&gt;未满足期望值&lt;/td&gt;
      &lt;td&gt;服务器未满足” 期望” 请求标头字段的要求&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;5xx服务器错误&quot;&gt;5xx（服务器错误）&lt;/h2&gt;
&lt;p&gt;这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;代码&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
      &lt;th&gt;详细&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;500&lt;/td&gt;
      &lt;td&gt;服务器内部错误&lt;/td&gt;
      &lt;td&gt;服务器遇到错误，无法完成请求。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;501&lt;/td&gt;
      &lt;td&gt;尚未实施&lt;/td&gt;
      &lt;td&gt;服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;502&lt;/td&gt;
      &lt;td&gt;错误网关&lt;/td&gt;
      &lt;td&gt;服务器作为网关或代理，从上游服务器收到无效响应。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;503&lt;/td&gt;
      &lt;td&gt;服务不可用&lt;/td&gt;
      &lt;td&gt;服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;504&lt;/td&gt;
      &lt;td&gt;网关超时&lt;/td&gt;
      &lt;td&gt;服务器作为网关或代理，但是没有及时从上游服务器收到请求。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;505&lt;/td&gt;
      &lt;td&gt;HTTP 版本不受支持&lt;/td&gt;
      &lt;td&gt;服务器不支持请求中所用的 HTTP 协议版本。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;扩展&quot;&gt;扩展&lt;/h2&gt;
&lt;p&gt;RFC 6585 最近刚刚发布，该文档描述了 4 个新的 HTTP 状态码。&lt;/p&gt;

&lt;p&gt;HTTP 协议还在变化？是的，HTTP 协议一直在演变，新的状态码对于开发 REST 服务或者说是基于 HTTP 的服务非常有用，下面我们为你详细介绍这四个新的状态码以及是否应该使用。&lt;/p&gt;

&lt;h3 id=&quot;428-precondition-required-要求先决条件&quot;&gt;428 Precondition Required (要求先决条件)&lt;/h3&gt;
&lt;p&gt;先决条件是客户端发送 HTTP 请求时，如果想要请求能成功必须满足一些预设的条件。&lt;/p&gt;

&lt;p&gt;一个好的例子就是 If-None-Match 头，经常在 GET 请求中使用，如果指定了 If-None-Match ，那么客户端只在响应中的 ETag 改变后才会重新接收回应。&lt;/p&gt;

&lt;p&gt;先决条件的另外一个例子就是 If-Match 头，这个一般用在 PUT 请求上用于指示只更新没被改变的资源，这在多个客户端使用 HTTP 服务时用来防止彼此间不会覆盖相同内容。&lt;/p&gt;

&lt;p&gt;当服务器端使用 428 Precondition Required 状态码时，表示客户端必须发送上述的请求头才能执行请求，这个方法为服务器提供一种有效的方法来阻止 ‘lost update’ 问题。&lt;/p&gt;

&lt;h3 id=&quot;429-too-many-requests-太多请求&quot;&gt;429 Too Many Requests (太多请求)&lt;/h3&gt;
&lt;p&gt;当你需要限制客户端请求某个服务数量时，该状态码就很有用，也就是请求速度限制。&lt;/p&gt;

&lt;p&gt;在此之前，有一些类似的状态码，例如 ‘509 Bandwidth Limit Exceeded’. Twitter 使用 420 （这不是 HTTP 定义的状态码）&lt;/p&gt;

&lt;p&gt;如果你希望限制客户端对服务的请求数，可使用 429 状态码，同时包含一个 Retry-After 响应头用于告诉客户端多长时间后可以再次请求服务。&lt;/p&gt;

&lt;h3 id=&quot;431-request-header-fields-too-large-请求头字段太大&quot;&gt;431 Request Header Fields Too Large (请求头字段太大)&lt;/h3&gt;
&lt;p&gt;某些情况下，客户端发送 HTTP 请求头会变得很大，那么服务器可发送 431 Request Header Fields Too Large 来指明该问题。&lt;/p&gt;

&lt;p&gt;我不太清楚为什么没有 430 状态码，而是直接从 429 跳到 431，我尝试搜索但没有结果。唯一的猜测是 430 Forbidden 跟 403 Forbidden 太像了，为了避免混淆才这么做的，天知道！&lt;/p&gt;

&lt;h3 id=&quot;511-network-authentication-required-要求网络认证&quot;&gt;511 Network Authentication Required (要求网络认证)&lt;/h3&gt;
&lt;p&gt;对我来说这个状态码很有趣，如果你在开发一个 HTTP 服务器，你不一定需要处理该状态码，但如果你在编写 HTTP 客户端，那这个状态码就非常重要。&lt;/p&gt;

&lt;p&gt;如果你频繁使用笔记本和智能手机，你可能会注意到大量的公用 WIFI 服务要求你必须接受一些协议或者必须登录后才能使用。&lt;/p&gt;

&lt;p&gt;这是通过拦截 HTTP 流量，当用户试图访问网络返回一个重定向和登录，这很讨厌，但是实际情况就是这样的。&lt;/p&gt;

&lt;p&gt;使用这些 “拦截” 客户端，会有一些讨厌的副作用。在 RFC 中有提到这两个的例子：&lt;/p&gt;

&lt;p&gt;如果你在登录 WIFI 前访问某个网站，网络设备将会拦截首个请求，这些设备往往也有自己的网站图标 ‘favicon.ico’。登录后您会发现，有一段时间内你访问的网站图标一直是 WIFI 登录网站的图标。&lt;/p&gt;

&lt;p&gt;如果客户端使用 HTTP 请求来查找文档（可能是 JSON），网络将会响应一个登录页，这样你的客户端就会解析错误并导致客户端运行异常，在现实中这种问题非常常见。&lt;/p&gt;

&lt;p&gt;因此 511 状态码的提出就是为了解决这个问题。&lt;/p&gt;

&lt;p&gt;如果你正在编写 HTTP 的客户端，你最好还是检查 511 状态码以确认是否需要认证后才能访问。&lt;/p&gt;</content><author><name>Lewin</name></author><category term="http" /><category term="status" /><summary type="html">1xx（临时响应） 表示临时响应并需要请求者继续执行操作的状态代码。</summary></entry><entry><title type="html">主流软件负载均衡器对比 (LVS、Nginx、HAproxy)</title><link href="https://lewinz.org/2021/07/28/lvs-nginx-haproxy/" rel="alternate" type="text/html" title="主流软件负载均衡器对比 (LVS、Nginx、HAproxy)" /><published>2021-07-28T00:00:00+08:00</published><updated>2021-07-28T00:00:00+08:00</updated><id>https://lewinz.org/2021/07/28/lvs-nginx-haproxy</id><content type="html" xml:base="https://lewinz.org/2021/07/28/lvs-nginx-haproxy/">&lt;h2 id=&quot;负载均衡的三种实现方式&quot;&gt;负载均衡的三种实现方式&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;基于 DNS 负载均衡
    &lt;ul&gt;
      &lt;li&gt;直接通过 DNS 来实现负载均衡。优点是非常简单，缺点是调整后不知道啥时生效 (当然正常情况下几十分钟，长的也可能更长)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;基于硬件负载均衡
    &lt;ul&gt;
      &lt;li&gt;购买硬件，也就是我们常常说的 F5（F5 Network Big-IP），不过 F5 就贵一般来说单台硬件也得几十万块，要是搞个双机，多机就更贵了&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;基于软件负载均衡
    &lt;ul&gt;
      &lt;li&gt;基于软件的方式也非常多，类似几个主流 LVS、Nginx、HAproxy (当然 IBM 也有个 HIS)，接下来就针对以下几种具体说明：&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;三大主流软件负载均衡器对比-lvsnginxhaproxy&quot;&gt;三大主流软件负载均衡器对比 (LVS、Nginx、HAproxy)&lt;/h2&gt;
&lt;h3 id=&quot;lvs&quot;&gt;LVS&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;抗负载能力强，性能高，能达到 F5 的 60%，对内存和 CPU 资源消耗比较低&lt;/li&gt;
  &lt;li&gt;工作在网络 4 层，通过 VRRP 协议 (仅作代理之用)，具体的流量是由 linux 内核来处理，因此没有流量的产生。&lt;/li&gt;
  &lt;li&gt;稳定，可靠性高，自身有完美的热备方案 (Keepalived+lvs)&lt;/li&gt;
  &lt;li&gt;不支持正则处理，不能做动静分离。&lt;/li&gt;
  &lt;li&gt;支持多种负载均衡算法：rr (轮询)，wrr (带权轮询)、lc (最小连接)、wlc (带权最小连接)&lt;/li&gt;
  &lt;li&gt;配置相对复杂，对网络依赖比较大，稳定性很高。&lt;/li&gt;
  &lt;li&gt;LVS 工作模式有 4 种：
    &lt;ul&gt;
      &lt;li&gt;nat 地址转换&lt;/li&gt;
      &lt;li&gt;dr 直接路由&lt;/li&gt;
      &lt;li&gt;tun 隧道&lt;/li&gt;
      &lt;li&gt;full-nat&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;工作在网络 4 层，相对性能上较高 (网络的七层模式：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;nginx&quot;&gt;Nginx&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;工作在网络 7 层，可以针对 http 应用做一些分流的策略，比如针对域名，目录结构&lt;/li&gt;
  &lt;li&gt;Nginx 对网络的依赖较小，理论上能 ping 通就能进行负载功能&lt;/li&gt;
  &lt;li&gt;Nginx 安装配置比较简单，测试起来很方便&lt;/li&gt;
  &lt;li&gt;也可以承担较高的负载压力且稳定，nginx 是为解决 c10k 问题而诞生的&lt;/li&gt;
  &lt;li&gt;对后端服务器的健康检查，只支持通过端口来检测，不支持通过 url 来检测&lt;/li&gt;
  &lt;li&gt;Nginx 对请求的异步处理可以帮助节点服务器减轻负载压力&lt;/li&gt;
  &lt;li&gt;Nginx 仅能支持 http、https 和 Email 协议，这样就在适用范围较小。&lt;/li&gt;
  &lt;li&gt;不支持 Session 的直接保持，但能通过 ip_hash 来解决。对 Big request header 的支持不是很好。&lt;/li&gt;
  &lt;li&gt;Nginx 还能做 Web 服务器即 Cache 功能。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;haproxy&quot;&gt;HAProxy&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;支持两种代理模式：TCP（四层）和 HTTP（七层），支持虚拟主机；&lt;/li&gt;
  &lt;li&gt;能够补充 Nginx 的一些缺点比如 Session 的保持，Cookie 的引导等工作&lt;/li&gt;
  &lt;li&gt;支持 url 检测后端的服务器出问题的检测会有很好的帮助。&lt;/li&gt;
  &lt;li&gt;更多的负载均衡策略比如：动态加权轮循 (Dynamic Round Robin)，加权源地址哈希 (Weighted Source Hash)，加权 URL 哈希和加权参数哈希 (Weighted Parameter Hash) 已经实现&lt;/li&gt;
  &lt;li&gt;单纯从效率上来讲 HAProxy 更会比 Nginx 有更出色的负载均衡速度。&lt;/li&gt;
  &lt;li&gt;HAProxy 可以对 Mysql 进行负载均衡，对后端的 DB 节点进行检测和负载均衡。&lt;/li&gt;
  &lt;li&gt;支持负载均衡算法：Round-robin（轮循）、Weight-round-robin（带权轮循）、source（原地址保持）、RI（请求 URL）、rdp-cookie（根据 cookie）&lt;/li&gt;
  &lt;li&gt;不能做 Web 服务器即 Cache。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;三大主流软件负载均衡器适用业务场景&quot;&gt;三大主流软件负载均衡器适用业务场景&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;网站建设初期，可以选用 Nginx、HAProxy 作为反向代理负载均衡 (流量不大时，可以不选用负载均衡)，因为其配置简单，性能也能满足一般业务场景。如果考虑到负载均衡器是有单点问题，可以采用 Nginx+Keepalived/HAproxy+Keepalived 避免负载均衡器自身的单点问题。&lt;/li&gt;
  &lt;li&gt;网站并发到达一定程度后，为了提高稳定性和转发效率，可以使用 lvs，毕竟 lvs 比 Nginx/HAProxy 要更稳定，转发效率也更高。
注：nginx 与 HAProxy 比较：nginx 只支持七层，用户量最大，稳定性比较可靠。Haproxy 支持四层和七层，支持更多的负载均衡算法，支持 session 等。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;衡量负载均衡器好坏的几个重要的因素&quot;&gt;衡量负载均衡器好坏的几个重要的因素：&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;会话率 ：单位时间内的处理的请求数&lt;/li&gt;
  &lt;li&gt;会话并发能力：并发处理能力&lt;/li&gt;
  &lt;li&gt;数据率：处理数据能力&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;负载均衡的策略&quot;&gt;负载均衡的策略&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;轮询策略&lt;/li&gt;
  &lt;li&gt;负载度策略&lt;/li&gt;
  &lt;li&gt;响应策略&lt;/li&gt;
  &lt;li&gt;哈希策略&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Lewin</name></author><category term="lvc" /><category term="nginx" /><category term="haproxy" /><summary type="html">负载均衡的三种实现方式 基于 DNS 负载均衡 直接通过 DNS 来实现负载均衡。优点是非常简单，缺点是调整后不知道啥时生效 (当然正常情况下几十分钟，长的也可能更长) 基于硬件负载均衡 购买硬件，也就是我们常常说的 F5（F5 Network Big-IP），不过 F5 就贵一般来说单台硬件也得几十万块，要是搞个双机，多机就更贵了 基于软件负载均衡 基于软件的方式也非常多，类似几个主流 LVS、Nginx、HAproxy (当然 IBM 也有个 HIS)，接下来就针对以下几种具体说明：</summary></entry><entry><title type="html">openstack 秒级创建虚机方案</title><link href="https://lewinz.org/2021/07/28/openstack-create-nova/" rel="alternate" type="text/html" title="openstack 秒级创建虚机方案" /><published>2021-07-28T00:00:00+08:00</published><updated>2021-07-28T00:00:00+08:00</updated><id>https://lewinz.org/2021/07/28/openstack-create-nova</id><content type="html" xml:base="https://lewinz.org/2021/07/28/openstack-create-nova/">&lt;p&gt;OpenStack 管理虚拟机生命周期的组件是 Nova，Nova 创建虚拟机从后端存储类型分为本地 LVM 存储和远程分布式存储（例如：Ceph/SheepDog/GlusterFS），从启动方式一般分为镜像启动和卷启动两大类，按启动方式和存储后端可以有 4 种组合&lt;/p&gt;

&lt;h2 id=&quot;本地-lvm--镜像启动&quot;&gt;本地 LVM + 镜像启动&lt;/h2&gt;

&lt;p&gt;此种方式，虚拟机镜像事先一般也会存放在远端的分布式存储上（Ceph 或 Swift）。当在计算节点首次创建虚拟机时，会从远端分布式存储下载镜像到计算节点做格式转换并缓存为 base-image，然后复制完整的镜像到 /var/lib/nova/instances/{instance-uuid} 目录下作为系统盘，耗时跟镜像大小和带宽有关，一般约数分数以上。&lt;/p&gt;

&lt;p&gt;如果在相同的计算节点上第二次以相同的镜像创建虚拟机，因为已经有了镜像缓存，不需要再到远端分布式存储下载镜像，直接从本地计算节点拷贝镜像到虚拟机启动目录作为系统盘，耗时跟镜像大小有关，一般也得数分钟以上。&lt;/p&gt;

&lt;h2 id=&quot;本地-lvm--卷启动&quot;&gt;本地 LVM + 卷启动&lt;/h2&gt;

&lt;p&gt;此种方式，虚拟机镜像事先一般也会存放在远端的分布式存储上（Ceph 或 Swift）。当在计算节点首次创建虚拟机时，会从远端分布式存储下载镜像到计算节点做格式转换并缓存为 base-image，然后调用 cinder 在控制节点以 base-image 创建可 bootable 的卷，最后以该卷启动虚拟机。耗时跟镜像大小和带宽有关，一般也得数分钟以上。&lt;/p&gt;

&lt;p&gt;如果在相同的计算节点上第二次以相同的镜像从卷启动创建虚拟机，因为已经有了镜像缓存，不需要再到远端分布式存储下载镜像，直接调用 cinder 在控制节点以 base-image 创建可 bootable 的卷，最后以该卷启动虚拟机。耗时跟镜像大小和带宽有关，一般也得数分钟以上。&lt;/p&gt;

&lt;h2 id=&quot;远程分布式存储-ceph--镜像启动采用默认配置&quot;&gt;远程分布式存储 Ceph + 镜像启动（采用默认配置）&lt;/h2&gt;

&lt;p&gt;此种方式，虚拟机镜像事先一般也会存放在远端的分布式存储 Ceph 上。当在计算节点首次创建虚拟机时，首先会从远程 Ceph 上下载镜像到该计算节点做格式转换并缓存为 base-image，然后上传 base-image 到远程 Ceph Rbd 的 pool 中作为系统盘，最后以 CephRbd pool 中的系统盘启动虚拟机。耗时跟镜像大小和带宽有关，一般也得数分钟以上。&lt;/p&gt;

&lt;p&gt;在相同的计算节点上第二次以相同的镜像创建虚拟机，因为已经有了镜像缓存，不需要再到远端 Ceph 下载镜像，直接上传 base-image 到远程 Ceph Rbd 的 pool 中作为系统盘，最后以 CephRbd pool 中的系统盘启动虚拟机。耗时跟镜像大小和带宽有关，一般也得数分钟以上。&lt;/p&gt;

&lt;h2 id=&quot;远程分布式存储-ceph--卷启动采用默认配置&quot;&gt;远程分布式存储 Ceph + 卷启动（采用默认配置）&lt;/h2&gt;

&lt;p&gt;此种方式，虚拟机镜像事先一般也会存放在远端的分布式存储 Ceph 上。当在计算节点首次创建虚拟机时，首先会从远程 Ceph 上下载镜像到该计算节点做格式转换并缓存为 base-image，然后调用 cinder 通过 base-image 在远程 Ceph Rbd 的 pool 中创建可 bootable 的启动卷，最后以 Ceph Rbd pool 中的卷启动虚拟机。耗时跟镜像大小和带宽有关，一般也得数分钟以上。&lt;/p&gt;

&lt;p&gt;在相同的计算节点上第二次以相同的镜像以卷启动创建虚拟机，因为已经有了镜像缓存，不需要再到远端 Ceph 下载镜像，直接调用 cinder 通过 base-image 在远程 Ceph Rbd 的 pool 中创建可 bootable 的启动卷，最后以 Ceph Rbd pool 中的卷启动虚拟机。耗时跟镜像大小和带宽有关，一般也得数分钟以上。&lt;/p&gt;

&lt;h2 id=&quot;秒级创建虚拟机优化方案&quot;&gt;秒级创建虚拟机优化方案&lt;/h2&gt;

&lt;p&gt;在优化之前，如果按照上述 4 种组合任一一种来创建虚拟机，如果批量创建几百台虚拟机，因为有镜像的下载、上传或者拷贝流程，整个创建流程会非常耗时，有些会因为接口超时导致失败。&lt;/p&gt;

&lt;p&gt;为了达到秒级创建虚拟机的性能，Glance、Cinder 和 Nova 的后端存储统一以 Ceph 作为共享存储。Glance 上传的虚拟机镜像会上传到 Ceph images pool 中，Cinder 创建的卷会保存在 Ceph volumes pool 中，Nova 系统盘保存在 Cephinstances pool 中。&lt;/p&gt;

&lt;p&gt;如果是以镜像启动创建虚拟机，在同一个计算节点选择相同的镜像不论是第一次还是第二次创建虚拟机，会直接基于 ceph images pool 的镜像先做 snapshot，然后基于该 snapshot 进行 clone（copy on write）到 Cephinstances pool，最后以该系统盘启动虚拟机。利用 ceph 写时复制特性，不存在镜像的上传、下载和完整拷贝，所以创建速度非常快，可以达到秒级。&lt;/p&gt;

&lt;p&gt;如果是以卷启动创建虚拟机，在同一个计算节点选择相同的镜像不论是第一次还是第二次创建虚拟机，会直接基于 ceph images pool 的镜像先做 snapshot，然后调用 cinder 基于该 snapshot 进行 clone（copy on write）到 Ceph volumes pool，最后以该卷启动虚拟机。利用 ceph 写时复制特性，不存在镜像的上传、下载和完整拷贝，所以创建速度非常快，可以达到秒级。&lt;/p&gt;

&lt;h2 id=&quot;秒级创建虚拟机的优化步骤&quot;&gt;秒级创建虚拟机的优化步骤&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;在 controller 控制节点上修改 /etc/glance/glance-api.conf 镜像配置文件，把 show_image_direct_url 参数设置为 True。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;vim /etc/glance/glance-api.conf&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/openstack_create_nova_1.png&quot; alt=&quot;openstack_create_nova_1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意：一定要在【DEFAULT】下添加。&lt;/p&gt;

&lt;p&gt;然后利用命令 serviceopenstack-glance-api restart 重启镜像管理服务。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;转换镜像格式，通过 glance 上传的镜像一定要是 raw 格式。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在上传之前需要命令转换好后上传，转换命令：&lt;/p&gt;

&lt;p&gt;qemu-img convert -O raw src-img.qcow2dst-img.raw&lt;/p&gt;

&lt;p&gt;用命令行转换成 raw 格式，主要是解决如下 no bootable device 问题。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/openstack_create_nova_2.png&quot; alt=&quot;openstack_create_nova_2&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在计算节点上进入 /var/lib/nova/instances/_base/ 目录，清空该目录下所有的缓存镜像。由于后台程序会先检测该目录下有没有缓存镜像，如果有，会把该缓存镜像上传到 ceph 中，如果没有，直接在 ceph 中 clone 镜像。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;步骤如下：&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@openstack _base]# &lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt;/var/lib/nova/instances/_base/

&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@openstack _base]# ll

&lt;span class=&quot;nt&quot;&gt;-rw-r--r--&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; 1 qemu qemu 41126400 Jul 24 01:01d7fca384a7c355afa3b70667b60f04dd08cd6f35

&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@openstack _base]# &lt;span class=&quot;nb&quot;&gt;rm&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-rfd7fca384a7c355afa3b70667b60f04dd08cd6f35&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@openstack _base]# ll

total 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;相关的流程源码如下：&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/openstack_create_nova_3.png&quot; alt=&quot;openstack_create_nova_3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/openstack_create_nova_4.png&quot; alt=&quot;openstack_create_nova_4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[root@openstack ~]# vim /usr/lib/python2.7/site-packages/nova/virt/libvirt/imagebackend.py&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/openstack_create_nova_5.png&quot; alt=&quot;openstack_create_nova_5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[root@openstack ~]# vim /usr/lib/python2.7/site-packages/nova/virt/libvirt/driver.py&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/openstack_create_nova_6.jpeg&quot; alt=&quot;openstack_create_nova_6&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[root@openstack ~]# vim/usr/lib/python2.7/site-packages/glance/api/v2/images.py&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/openstack_create_nova_7.jpeg&quot; alt=&quot;openstack_create_nova_7&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;上述介绍的不同种类的创建虚拟机的组合方式，从核心原理分析其实只有两类。一种是需要完整拷贝镜像，另一种是写时复制（copy on write）。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;完整拷贝镜像创建虚拟机&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;优点：是每个虚拟机独立，不会相互影响。&lt;/p&gt;

&lt;p&gt;缺点：存在镜像下载、上传或者拷贝，创建速度慢。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;写时复制（copyon write）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;优点：每次创建虚拟机都只有很小的增量文件，不存在全量镜像拷贝，创建速度很快。&lt;/p&gt;

&lt;p&gt;缺点：以相同的镜像创建的所有虚拟机依赖共同的 base-image，如果 base-image 意外损坏或删除，上层依赖的虚拟机都会受到影响。&lt;/p&gt;

&lt;p&gt;速度和安全性往往是一对矛盾体，两种方式需要做一定的权衡。可以在完整拷贝镜像创建虚拟机的方案中提升硬件性能，比如通过高配的磁盘和带宽来降低拷贝镜像的时间。也可以在写时复制（copy on write）的方案中，在虚拟机创建成功后的某个恰当时刻，通过后台执行 ceph 的 rbd flatten 命令断开 base-image 和增量 clone 虚拟磁盘的依赖链，达到每个虚拟机相互独立。&lt;/p&gt;</content><author><name>Lewin</name></author><category term="openstack" /><category term="nova" /><summary type="html">OpenStack 管理虚拟机生命周期的组件是 Nova，Nova 创建虚拟机从后端存储类型分为本地 LVM 存储和远程分布式存储（例如：Ceph/SheepDog/GlusterFS），从启动方式一般分为镜像启动和卷启动两大类，按启动方式和存储后端可以有 4 种组合</summary></entry></feed>