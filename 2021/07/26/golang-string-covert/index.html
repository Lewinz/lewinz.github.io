<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>golang 黑魔法 (string 与 []byte 转换) &mdash; 阿嫂</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/rouge-themes@master/dist/github.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/vendor/share.js/dist/css/share.min.css"><link rel="canonical" href="https://lewinz.org/2021/07/26/golang-string-covert/"><link rel="alternate" type="application/atom+xml" title="阿嫂" href="https://lewinz.org/feed.xml"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/favicon.ico"><meta property="og:title" content="golang 黑魔法 (string 与 []byte 转换)"><meta name="keywords" content="golang, string, byte, coverted"><meta name="og:keywords" content="golang, string, byte, coverted"><meta name="description" content="string 类型和 [] byte 类型是我们编程时最常使用到的数据结构。本文将探讨两者之间的转换方式，通过分析它们之间的内在联系来拨开迷雾。"><meta name="og:description" content="string 类型和 [] byte 类型是我们编程时最常使用到的数据结构。本文将探讨两者之间的转换方式，通过分析它们之间的内在联系来拨开迷雾。"><meta property="og:url" content="https://lewinz.org/2021/07/26/golang-string-covert/"><meta property="og:site_name" content="阿嫂"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2021-07-26"> <script src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/js/main.js"></script> <script data-ad-client="ca-pub-7093222719567591" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://lewinz.org/" title="阿嫂"><span class="octicon octicon-mark-github"></span> 阿嫂</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://lewinz.org/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="https://lewinz.org/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="https://lewinz.org/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="https://lewinz.org/links/" class=" site-header-nav-item" target="" title="链接">链接</a> <a href="https://lewinz.org/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="golang 黑魔法 (str"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">golang 黑魔法 (string 与 []byte 转换)</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2021/07/26 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://lewinz.org/categories/#golang" title="golang">golang</a> </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://lewinz.org/categories/#string" title="string">string</a> </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://lewinz.org/categories/#byte" title="byte">byte</a> </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://lewinz.org/categories/#coverted" title="coverted">coverted</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 8288 字，约 24 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" > <ins class="adsbygoogle content-header-ad" data-ad-client="ca-pub-7093222719567591" data-ad-slot="1650902835"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script> <br /><article class="article-content markdown-body"><p>string 类型和 [] byte 类型是我们编程时最常使用到的数据结构。本文将探讨两者之间的转换方式，通过分析它们之间的内在联系来拨开迷雾。</p><h2 id="两种转换方式">两种转换方式</h2><h3 id="标准转换">标准转换</h3><p>go 中 string 与 [] byte 的互换，相信每一位 gopher 都能立刻想到以下的转换方式，我们将之称为标准转换。</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// string to []byte</span>
<span class="n">s1</span> <span class="o">:=</span> <span class="s">"hello"</span>
<span class="n">b</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>

<span class="c">// []byte to string</span>
<span class="n">s2</span> <span class="o">:=</span> <span class="kt">string</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
</code></pre></div></div><h3 id="强转换">强转换</h3><p>通过 unsafe 和 reflect 包，可以实现另外一种转换方式，我们将之称为强转换（也常常被人称作黑魔法）。</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">String2Bytes</span><span class="p">(</span><span class="n">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
    <span class="n">sh</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="n">reflect</span><span class="o">.</span><span class="n">StringHeader</span><span class="p">)(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">))</span>
    <span class="n">bh</span> <span class="o">:=</span> <span class="n">reflect</span><span class="o">.</span><span class="n">SliceHeader</span><span class="p">{</span>
        <span class="n">Data</span><span class="o">:</span> <span class="n">sh</span><span class="o">.</span><span class="n">Data</span><span class="p">,</span>
        <span class="n">Len</span><span class="o">:</span>  <span class="n">sh</span><span class="o">.</span><span class="n">Len</span><span class="p">,</span>
        <span class="n">Cap</span><span class="o">:</span>  <span class="n">sh</span><span class="o">.</span><span class="n">Len</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">[]</span><span class="kt">byte</span><span class="p">)(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bh</span><span class="p">))</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Bytes2String</span><span class="p">(</span><span class="n">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">string</span><span class="p">)(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div><h2 id="性能对比">性能对比</h2><p>既然有两种转换方式，那么我们有必要对它们做性能对比。</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// 测试强转换功能</span>
<span class="k">func</span> <span class="n">TestBytes2String</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">(</span><span class="s">"Hello Gopher!"</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">:=</span> <span class="n">Bytes2String</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">:=</span> <span class="kt">string</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">y</span> <span class="o">!=</span> <span class="n">z</span> <span class="p">{</span>
        <span class="n">t</span><span class="o">.</span><span class="n">Fail</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c">// 测试强转换功能</span>
<span class="k">func</span> <span class="n">TestString2Bytes</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">:=</span> <span class="s">"Hello Gopher!"</span>
    <span class="n">y</span> <span class="o">:=</span> <span class="n">String2Bytes</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">if</span> <span class="o">!</span><span class="n">bytes</span><span class="o">.</span><span class="n">Equal</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">t</span><span class="o">.</span><span class="n">Fail</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c">// 测试标准转换 string() 性能</span>
<span class="k">func</span> <span class="n">Benchmark_NormalBytes2String</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">(</span><span class="s">"Hello Gopher! Hello Gopher! Hello Gopher!"</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">.</span><span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">_</span> <span class="o">=</span> <span class="kt">string</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c">// 测试强转换[]byte 到 string 性能</span>
<span class="k">func</span> <span class="n">Benchmark_Byte2String</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">(</span><span class="s">"Hello Gopher! Hello Gopher! Hello Gopher!"</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">.</span><span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">Bytes2String</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c">// 测试标准转换[]byte 性能</span>
<span class="k">func</span> <span class="n">Benchmark_NormalString2Bytes</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">:=</span> <span class="s">"Hello Gopher! Hello Gopher! Hello Gopher!"</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">.</span><span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">_</span> <span class="o">=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c">// 测试强转换 string 到[]byte 性能</span>
<span class="k">func</span> <span class="n">Benchmark_String2Bytes</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">:=</span> <span class="s">"Hello Gopher! Hello Gopher! Hello Gopher!"</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">.</span><span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">String2Bytes</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>测试结果如下</p><div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>go <span class="nb">test</span> <span class="nt">-bench</span><span class="o">=</span><span class="s2">"."</span> <span class="nt">-benchmem</span>
goos: darwin
goarch: amd64
pkg: workspace/example/stringBytes
Benchmark_NormalBytes2String-8          38363413                27.9 ns/op            48 B/op          1 allocs/op
Benchmark_Byte2String-8                 1000000000               0.265 ns/op           0 B/op          0 allocs/op
Benchmark_NormalString2Bytes-8          32577080                34.8 ns/op            48 B/op          1 allocs/op
Benchmark_String2Bytes-8                1000000000               0.532 ns/op           0 B/op          0 allocs/op
PASS
ok      workspace/example/stringBytes   3.170s
</code></pre></div></div><p>注意，-benchmem 可以提供每次操作分配内存的次数，以及每次操作分配的字节数。</p><p>当 x 的数据均为 “Hello Gopher!” 时，测试结果如下</p><div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>go <span class="nb">test</span> <span class="nt">-bench</span><span class="o">=</span><span class="s2">"."</span> <span class="nt">-benchmem</span>
goos: darwin
goarch: amd64
pkg: workspace/example/stringBytes
Benchmark_NormalBytes2String-8          245907674                4.86 ns/op            0 B/op          0 allocs/op
Benchmark_Byte2String-8                 1000000000               0.266 ns/op           0 B/op          0 allocs/op
Benchmark_NormalString2Bytes-8          202329386                5.92 ns/op            0 B/op          0 allocs/op
Benchmark_String2Bytes-8                1000000000               0.532 ns/op           0 B/op          0 allocs/op
PASS
ok      workspace/example/stringBytes   4.383s
</code></pre></div></div><p>强转换方式的性能会明显优于标准转换。</p><p>读者可以思考以下问题</p><ol><li>为啥强转换性能会比标准转换好？</li><li>为啥在上述测试中，当 x 的数据较大时，标准转换方式会有一次分配内存的操作，从而导致其性能更差，而强转换方式却不受影响？</li><li>既然强转换方式性能这么好，为啥 go 语言提供给我们使用的是标准转换方式？</li></ol><h2 id="原理分析">原理分析</h2><p>要回答以上三个问题，首先要明白是 string 和 [] byte 在 go 中到底是什么。</p><h3 id="byte">[]byte</h3><p>在 go 中，byte 是 uint8 的别名，在 go 标准库 builtin 中有如下说明：</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// byte is an alias for uint8 and is equivalent to uint8 in all ways. It is</span>
<span class="c">// used, by convention, to distinguish byte values from 8-bit unsigned</span>
<span class="c">// integer values.</span>
<span class="k">type</span> <span class="kt">byte</span> <span class="o">=</span> <span class="kt">uint8</span>
</code></pre></div></div><p>在 go 的源码中 src/runtime/slice.go，slice 的定义如下：</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">slice</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">array</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span>
    <span class="nb">len</span>   <span class="kt">int</span>
    <span class="nb">cap</span>   <span class="kt">int</span>
<span class="p">}</span>
</code></pre></div></div><p>array 是底层数组的指针，len 表示长度，cap 表示容量。对于 [] byte 来说，array 指向的就是 byte 数组。</p><p><img src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/golang_string_byte_coverted_1.png" alt="golang_string_byte_coverted_1" /></p><h3 id="string">string</h3><p>关于 string 类型，在 go 标准库 builtin 中有如下说明：</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// string is the set of all strings of 8-bit bytes, conventionally but not</span>
<span class="c">// necessarily representing UTF-8-encoded text. A string may be empty, but</span>
<span class="c">// not nil. Values of string type are immutable.</span>
<span class="k">type</span> <span class="kt">string</span> <span class="kt">string</span>
</code></pre></div></div><p>翻译过来就是：string 是 8 位字节的集合，通常但不一定代表 UTF-8 编码的文本。string 可以为空，但是不能为 nil。string 的值是不能改变的。</p><p>在 go 的源码中 src/runtime/string.go，string 的定义如下：</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">stringStruct</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">str</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span>
    <span class="nb">len</span> <span class="kt">int</span>
<span class="p">}</span>
</code></pre></div></div><p>stringStruct 代表的就是一个 string 对象，str 指针指向的是某个数组的首地址，len 代表的数组长度。那么这个数组是什么呢？我们可以在实例化 stringStruct 对象时找到答案。</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">//go:nosplit</span>
<span class="k">func</span> <span class="n">gostringnocopy</span><span class="p">(</span><span class="n">str</span> <span class="o">*</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="n">ss</span> <span class="o">:=</span> <span class="n">stringStruct</span><span class="p">{</span><span class="n">str</span><span class="o">:</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="n">str</span><span class="p">),</span> <span class="nb">len</span><span class="o">:</span> <span class="n">findnull</span><span class="p">(</span><span class="n">str</span><span class="p">)}</span>
    <span class="n">s</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">string</span><span class="p">)(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ss</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">s</span>
<span class="p">}</span>
</code></pre></div></div><p>可以看到，入参 str 指针就是指向 byte 的指针，那么我们可以确定 string 的底层数据结构就是 byte 数组。</p><p><img src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/golang_string_byte_coverted_2.png" alt="golang_string_byte_coverted_2" /></p><p>综上，string 与 [] byte 在底层结构上是非常的相近（后者的底层表达仅多了一个 cap 属性，因此它们在内存布局上是可对齐的），这也就是为何 builtin 中内置函数 copy 会有一种特殊情况 copy(dst []byte, src string) int 的原因了。</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// The copy built-in function copies elements from a source slice into a</span>
<span class="c">// destination slice. (As a special case, it also will copy bytes from a</span>
<span class="c">// string to a slice of bytes.) The source and destination may overlap. Copy</span>
<span class="c">// returns the number of elements copied, which will be the minimum of</span>
<span class="c">// len(src) and len(dst).</span>
<span class="k">func</span> <span class="nb">copy</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span> <span class="p">[]</span><span class="n">Type</span><span class="p">)</span> <span class="kt">int</span>
</code></pre></div></div><h3 id="区别">区别</h3><p>对于 [] byte 与 string 而言，两者之间最大的区别就是 string 的值不能改变。这该如何理解呢？下面通过两个例子来说明。</p><p>对于 [] byte 来说，以下操作是可行的：</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">b</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">(</span><span class="s">"Hello Gopher!"</span><span class="p">)</span>
<span class="n">b</span> <span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'T'</span>
</code></pre></div></div><p>string，修改操作是被禁止的：</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">s</span> <span class="o">:=</span> <span class="s">"Hello Gopher!"</span>
<span class="n">s</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'T'</span>
</code></pre></div></div><p>而 string 能支持这样的操作：</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">s</span> <span class="o">:=</span> <span class="s">"Hello Gopher!"</span>
<span class="n">s</span> <span class="o">=</span> <span class="s">"Tello Gopher!"</span>
</code></pre></div></div><p>字符串的值不能被更改，但可以被替换。 string 在底层都是结构体 stringStruct{str: str_point, len: str_len}，string 结构体的 str 指针指向的是一个字符常量的地址， 这个地址里面的内容是不可以被改变的，因为它是只读的，但是这个指针可以指向不同的地址。</p><p>那么，以下操作的含义是不同的：</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">s</span> <span class="o">:=</span> <span class="s">"S1"</span> <span class="c">// 分配存储"S1"的内存空间，s 结构体里的 str 指针指向这块内存</span>
<span class="n">s</span> <span class="o">=</span> <span class="s">"S2"</span>  <span class="c">// 分配存储"S2"的内存空间，s 结构体里的 str 指针转为指向这块内存</span>

<span class="n">b</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">{</span><span class="m">1</span><span class="p">}</span> <span class="c">// 分配存储 '1' 数组的内存空间，b 结构体的 array 指针指向这个数组。</span>
<span class="n">b</span> <span class="o">=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">{</span><span class="m">2</span><span class="p">}</span>  <span class="c">// 将 array 的内容改为 '2'</span>
</code></pre></div></div><p>图解如下 <img src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/golang_string_byte_coverted_3.png" alt="golang_string_byte_coverted_3" /></p><p>因为 string 的指针指向的内容是不可以更改的，所以每更改一次字符串，就得重新分配一次内存，之前分配的空间还需要 gc 回收，这是导致 string 相较于 [] byte 操作低效的根本原因。</p><h3 id="标准转换的实现细节">标准转换的实现细节</h3><p>[] byte (string) 的实现（源码在 src/runtime/string.go 中）</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// The constant is known to the compiler.</span>
<span class="c">// There is no fundamental theory behind this number.</span>
<span class="k">const</span> <span class="n">tmpStringBufSize</span> <span class="o">=</span> <span class="m">32</span>

<span class="k">type</span> <span class="n">tmpBuf</span> <span class="p">[</span><span class="n">tmpStringBufSize</span><span class="p">]</span><span class="kt">byte</span>

<span class="k">func</span> <span class="n">stringtoslicebyte</span><span class="p">(</span><span class="n">buf</span> <span class="o">*</span><span class="n">tmpBuf</span><span class="p">,</span> <span class="n">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">b</span> <span class="p">[]</span><span class="kt">byte</span>
    <span class="k">if</span> <span class="n">buf</span> <span class="o">!=</span> <span class="no">nil</span> <span class="o">&amp;&amp;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">tmpBuf</span><span class="p">{}</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">buf</span><span class="p">[</span><span class="o">:</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)]</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">rawbyteslice</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
    <span class="p">}</span>
    <span class="nb">copy</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">b</span>
<span class="p">}</span>

<span class="c">// rawbyteslice allocates a new byte slice. The byte slice is not zeroed.</span>
<span class="k">func</span> <span class="n">rawbyteslice</span><span class="p">(</span><span class="n">size</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">cap</span> <span class="o">:=</span> <span class="n">roundupsize</span><span class="p">(</span><span class="kt">uintptr</span><span class="p">(</span><span class="n">size</span><span class="p">))</span>
    <span class="n">p</span> <span class="o">:=</span> <span class="n">mallocgc</span><span class="p">(</span><span class="nb">cap</span><span class="p">,</span> <span class="no">nil</span><span class="p">,</span> <span class="no">false</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">cap</span> <span class="o">!=</span> <span class="kt">uintptr</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">memclrNoHeapPointers</span><span class="p">(</span><span class="n">add</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="kt">uintptr</span><span class="p">(</span><span class="n">size</span><span class="p">)),</span> <span class="nb">cap</span><span class="o">-</span><span class="kt">uintptr</span><span class="p">(</span><span class="n">size</span><span class="p">))</span>
    <span class="p">}</span>

    <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">slice</span><span class="p">)(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">))</span> <span class="o">=</span> <span class="n">slice</span><span class="p">{</span><span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span><span class="p">(</span><span class="nb">cap</span><span class="p">)}</span>
    <span class="k">return</span>
<span class="p">}</span>
</code></pre></div></div><p>这里有两种情况：s 的长度是否大于 32。当大于 32 时，go 需要调用 mallocgc 分配一块新的内存（大小由 s 决定），这也就回答了上文中的问题 2：当 x 的数据较大时，标准转换方式会有一次分配内存的操作。</p><p>最后通过 copy 函数实现 string 到 [] byte 的拷贝，具体实现在 src/runtime/slice.go 中的 slicestringcopy 方法。</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">slicestringcopy</span><span class="p">(</span><span class="n">to</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="n">fm</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fm</span><span class="p">)</span> <span class="o">==</span> <span class="m">0</span> <span class="o">||</span> <span class="nb">len</span><span class="p">(</span><span class="n">to</span><span class="p">)</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="m">0</span>
    <span class="p">}</span>

  <span class="c">// copy 的长度取决与 string 和[]byte 的长度最小值</span>
    <span class="n">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fm</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">to</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="p">{</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">to</span><span class="p">)</span>
    <span class="p">}</span>

  <span class="c">// 如果开启了竞态检测 -race</span>
    <span class="k">if</span> <span class="n">raceenabled</span> <span class="p">{</span>
        <span class="n">callerpc</span> <span class="o">:=</span> <span class="n">getcallerpc</span><span class="p">()</span>
        <span class="n">pc</span> <span class="o">:=</span> <span class="n">funcPC</span><span class="p">(</span><span class="n">slicestringcopy</span><span class="p">)</span>
        <span class="n">racewriterangepc</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">to</span><span class="p">[</span><span class="m">0</span><span class="p">]),</span> <span class="kt">uintptr</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">callerpc</span><span class="p">,</span> <span class="n">pc</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="c">// 如果开启了 memory sanitizer -msan</span>
    <span class="k">if</span> <span class="n">msanenabled</span> <span class="p">{</span>
        <span class="n">msanwrite</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">to</span><span class="p">[</span><span class="m">0</span><span class="p">]),</span> <span class="kt">uintptr</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="p">}</span>

  <span class="c">// 该方法将 string 的底层数组从头部复制 n 个到[]byte 对应的底层数组中去（这里就是 copy 实现的核心方法，在汇编层面实现 源文件为 memmove_*.s）</span>
    <span class="n">memmove</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">to</span><span class="p">[</span><span class="m">0</span><span class="p">]),</span> <span class="n">stringStructOf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fm</span><span class="p">)</span><span class="o">.</span><span class="n">str</span><span class="p">,</span> <span class="kt">uintptr</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">n</span>
<span class="p">}</span>
</code></pre></div></div><p>copy 实现过程图解如下</p><p><img src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/golang_string_byte_coverted_4.png" alt="golang_string_byte_coverted_4" /></p><p>string ([] byte) 的实现（源码也在 src/runtime/string.go 中）</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Buf is a fixed-size buffer for the result,</span>
<span class="c">// it is not nil if the result does not escape.</span>
<span class="k">func</span> <span class="n">slicebytetostring</span><span class="p">(</span><span class="n">buf</span> <span class="o">*</span><span class="n">tmpBuf</span><span class="p">,</span> <span class="n">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">str</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">l</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
        <span class="c">// Turns out to be a relatively common case.</span>
        <span class="c">// Consider that you want to parse out data between parens in "foo()bar",</span>
        <span class="c">// you find the indices and convert the subslice to string.</span>
        <span class="k">return</span> <span class="s">""</span>
    <span class="p">}</span>
  <span class="c">// 如果开启了竞态检测 -race</span>
    <span class="k">if</span> <span class="n">raceenabled</span> <span class="p">{</span>
        <span class="n">racereadrangepc</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">[</span><span class="m">0</span><span class="p">]),</span>
            <span class="kt">uintptr</span><span class="p">(</span><span class="n">l</span><span class="p">),</span>
            <span class="n">getcallerpc</span><span class="p">(),</span>
            <span class="n">funcPC</span><span class="p">(</span><span class="n">slicebytetostring</span><span class="p">))</span>
    <span class="p">}</span>
  <span class="c">// 如果开启了 memory sanitizer -msan</span>
    <span class="k">if</span> <span class="n">msanenabled</span> <span class="p">{</span>
        <span class="n">msanread</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">[</span><span class="m">0</span><span class="p">]),</span> <span class="kt">uintptr</span><span class="p">(</span><span class="n">l</span><span class="p">))</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="m">1</span> <span class="p">{</span>
        <span class="n">stringStructOf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">str</span><span class="p">)</span><span class="o">.</span><span class="n">str</span> <span class="o">=</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">staticbytes</span><span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="m">0</span><span class="p">]])</span>
        <span class="n">stringStructOf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">str</span><span class="p">)</span><span class="o">.</span><span class="nb">len</span> <span class="o">=</span> <span class="m">1</span>
        <span class="k">return</span>
    <span class="p">}</span>

    <span class="k">var</span> <span class="n">p</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span>
    <span class="k">if</span> <span class="n">buf</span> <span class="o">!=</span> <span class="no">nil</span> <span class="o">&amp;&amp;</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">mallocgc</span><span class="p">(</span><span class="kt">uintptr</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)),</span> <span class="no">nil</span><span class="p">,</span> <span class="no">false</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">stringStructOf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">str</span><span class="p">)</span><span class="o">.</span><span class="n">str</span> <span class="o">=</span> <span class="n">p</span>
    <span class="n">stringStructOf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">str</span><span class="p">)</span><span class="o">.</span><span class="nb">len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
  <span class="c">// 拷贝字节数组至字符串</span>
    <span class="n">memmove</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">slice</span><span class="p">)(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">)))</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="kt">uintptr</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)))</span>
    <span class="k">return</span>
<span class="p">}</span>

<span class="c">// 实例 stringStruct 对象</span>
<span class="k">func</span> <span class="n">stringStructOf</span><span class="p">(</span><span class="n">sp</span> <span class="o">*</span><span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="n">stringStruct</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">stringStruct</span><span class="p">)(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="n">sp</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div><p>可见，当数组长度超过 32 时，同样需要调用 mallocgc 分配一块新内存。最后通过 memmove 完成拷贝。</p><h3 id="强转换的实现细节">强转换的实现细节</h3><p>万能的 unsafe.Pointer 指针 在 go 中，任何类型的指针 \T 都可以转换为 unsafe.Pointer 类型的指针，它可以存储任何变量的地址。同时，unsafe.Pointer 类型的指针也可以转换回普通指针，而且可以不必和之前的类型 \T 相同。另外，unsafe.Pointer 类型还可以转换为 uintptr 类型，该类型保存了指针所指向地址的数值，从而可以使我们对地址进行数值计算。以上就是强转换方式的实现依据。</p><p>而 string 和 slice 在 reflect 包中，对应的结构体是 reflect.StringHeader 和 reflect.SliceHeader，它们是 string 和 slice 的运行时表达。</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">StringHeader</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">Data</span> <span class="kt">uintptr</span>
    <span class="n">Len</span>  <span class="kt">int</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">SliceHeader</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">Data</span> <span class="kt">uintptr</span>
    <span class="n">Len</span>  <span class="kt">int</span>
    <span class="n">Cap</span>  <span class="kt">int</span>
<span class="p">}</span>
</code></pre></div></div><h2 id="内存布局">内存布局</h2><p>从 string 和 slice 的运行时表达可以看出，除了 SilceHeader 多了一个 int 类型的 Cap 字段，Date 和 Len 字段是一致的。所以，它们的内存布局是可对齐的，这说明我们就可以直接通过 unsafe.Pointer 进行转换。</p><p>[] byte 转 string 图解</p><p><img src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/golang_string_byte_coverted_5.png" alt="golang_string_byte_coverted_5" /></p><p>string 转 [] byte 图解</p><p><img src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/golang_string_byte_coverted_6.png" alt="golang_string_byte_coverted_6" /></p><h2 id="qa">Q&amp;A</h2><ol><li><p>为啥强转换性能会比标准转换好？ 对于标准转换，无论是从 [] byte 转 string 还是 string 转 [] byte 都会涉及底层数组的拷贝。而强转换是直接替换指针的指向，从而使得 string 和 [] byte 指向同一个底层数组。这样，当然后者的性能会更好。</p></li><li><p>为啥在上述测试中，当 x 的数据较大时，标准转换方式会有一次分配内存的操作，从而导致其性能更差，而强转换方式却不受影响？ 标准转换时，当数据长度大于 32 个字节时，需要通过 mallocgc 申请新的内存，之后再进行数据拷贝工作。而强转换只是更改指针指向。所以，当转换数据较大时，两者性能差距会愈加明显。</p></li><li><p>既然强转换方式性能这么好，为啥 go 语言提供给我们使用的是标准转换方式？ 首先，我们需要知道 Go 是一门类型安全的语言，而安全的代价就是性能的妥协。但是，性能的对比是相对的，这点性能的妥协对于现在的机器而言微乎其微。另外强转换的方式，会给我们的程序带来极大的安全隐患。</p></li></ol><p>如下示例</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">:=</span> <span class="s">"hello"</span>
<span class="n">b</span> <span class="o">:=</span> <span class="n">String2Bytes</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">b</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'H'</span>
</code></pre></div></div><p>a 是 string 类型，前面我们讲到它的值是不可修改的。通过强转换将 a 的底层数组赋给 b，而 b 是一个 [] byte 类型，它的值是可以修改的，所以这时对底层数组的值进行修改，将会造成严重的错误（通过 defer+recover 也不能捕获）。</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">unexpected</span> <span class="n">fault</span> <span class="n">address</span> <span class="m">0x10b6139</span>
<span class="n">fatal</span> <span class="kt">error</span><span class="o">:</span> <span class="n">fault</span>
<span class="p">[</span><span class="n">signal</span> <span class="n">SIGBUS</span><span class="o">:</span> <span class="n">bus</span> <span class="kt">error</span> <span class="n">code</span><span class="o">=</span><span class="m">0x2</span> <span class="n">addr</span><span class="o">=</span><span class="m">0x10b6139</span> <span class="n">pc</span><span class="o">=</span><span class="m">0x1088f2c</span><span class="p">]</span>
</code></pre></div></div><ol><li>为啥 string 要设计为不可修改的？</li></ol><p>我认为有必要思考一下该问题。string 不可修改，意味它是只读属性，这样的好处就是：在并发场景下，我们可以在不加锁的控制下，多次使用同一字符串，在保证高效共享的情况下而不用担心安全问题。</p><h2 id="取舍场景">取舍场景</h2><p>在你不确定安全隐患的条件下，尽量采用标准方式进行数据转换。<br /> 当程序对运行性能有高要求，同时满足对数据仅仅只有读操作的条件，且存在频繁转换（例如消息转发场景），可以使用强转换。</p><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="https://lewinz.org" target="_blank">Lewin</a></li><li>本文链接：<a href="https://lewinz.org/2021/07/26/golang-string-covert/" target="_blank">https://lewinz.org/2021/07/26/golang-string-covert/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名</li></ul></div></article><div class="share"><div class="share-component" data-disabled='qq,weibo,qzone'></div></div><div class="comment"><div id="gitalk-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/vendor/gitalk/gitalk.css"> <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> <script> var gitalk = new Gitalk({ id: '/2021/07/26/golang-string-covert/', clientID: '831a35f6d4f6fc049209', clientSecret: '6e80f9a3e9b50b498553e32179ad3adbd893ab7e', repo: 'blog-comments', owner: 'Lewinz', admin: ['Lewinz'], labels: ['gitment'], perPage: 50, }); gitalk.render('gitalk-container'); </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@built/assets/search_data.json?v=1628076667', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"> <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-7093222719567591" data-ad-slot="5263168187" data-ad-format="auto" data-full-width-responsive="true"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2021 <span title="Lewin">Lewin</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/Lewinz/lewinz.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://lewinz.org/" title="首页" target="">首页</a></li><li> <a href="https://lewinz.org/categories/" title="分类" target="">分类</a></li><li> <a href="https://lewinz.org/wiki/" title="维基" target="">维基</a></li><li> <a href="https://lewinz.org/links/" title="链接" target="">链接</a></li><li> <a href="https://lewinz.org/about/" title="关于" target="">关于</a></li><li><a href="https://lewinz.org/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul><script async src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/vendor/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="mobile-hidden" style="margin-top:8px"> <span id="busuanzi_container_site_pv" style="display:none"> 本站访问量<span id="busuanzi_value_site_pv"></span>次 </span> <span id="busuanzi_container_site_uv" style="display:none"> / 本站访客数<span id="busuanzi_value_site_uv"></span>人 </span> <span id="busuanzi_container_page_pv" style="display:none"> / 本页访问量<span id="busuanzi_value_page_pv"></span>次 / 统计始于2021-04-21 </span></div></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/vendor/share.js/dist/js/share.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script><div style="display:none"> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-80669434-1', 'auto'); ga('send', 'pageview'); </script></div></body></html>
