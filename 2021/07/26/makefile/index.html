<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>Makefile &mdash; 阿嫂</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/rouge-themes@master/dist/github.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/vendor/share.js/dist/css/share.min.css"><link rel="canonical" href="https://lewinz.org/2021/07/26/makefile/"><link rel="alternate" type="application/atom+xml" title="阿嫂" href="https://lewinz.org/feed.xml"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/favicon.ico"><meta property="og:title" content="Makefile"><meta name="keywords" content="makefile"><meta name="og:keywords" content="makefile"><meta name="description" content="makefile 介绍make 命令执行时，需要一个 makefile 文件，以告诉 make 命令需要怎么样的去编译和链接程序。"><meta name="og:description" content="makefile 介绍make 命令执行时，需要一个 makefile 文件，以告诉 make 命令需要怎么样的去编译和链接程序。"><meta property="og:url" content="https://lewinz.org/2021/07/26/makefile/"><meta property="og:site_name" content="阿嫂"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2021-07-26"> <script src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/js/main.js"></script> <script data-ad-client="ca-pub-7093222719567591" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://lewinz.org/" title="阿嫂"><span class="octicon octicon-mark-github"></span> 阿嫂</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://lewinz.org/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="https://lewinz.org/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="https://lewinz.org/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="https://lewinz.org/links/" class=" site-header-nav-item" target="" title="链接">链接</a> <a href="https://lewinz.org/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="Makefile"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">Makefile</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2021/07/26 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://lewinz.org/categories/#makefile" title="makefile">makefile</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 8125 字，约 24 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" > <ins class="adsbygoogle content-header-ad" data-ad-client="ca-pub-7093222719567591" data-ad-slot="1650902835"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script> <br /><article class="article-content markdown-body"><h2 id="makefile-介绍">makefile 介绍</h2><p>make 命令执行时，需要一个 makefile 文件，以告诉 make 命令需要怎么样的去编译和链接程序。</p><p>首先，我们用一个示例来说明 makefile 的书写规则，以便给大家一个感性认识。这个示例来源于 gnu 的 make 使用手册，在这个示例中，我们的工程有 8 个 c 文件，和 3 个头文件，我们要写一个 makefile 来告诉 make 命令如何编译和链接这几个文件。我们的规则是：</p><ol><li>如果这个工程没有编译过，那么我们的所有 c 文件都要编译并被链接。</li><li>如果这个工程的某几个 c 文件被修改，那么我们只编译被修改的 c 文件，并链接目标程序。</li><li>如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的 c 文件，并链接目标程序。</li></ol><p>只要我们的 makefile 写得够好，所有的这一切，我们只用一个 make 命令就可以完成，make 命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自动编译所需要的文件和链接目标程序。</p><h2 id="makefile-的规则">makefile 的规则</h2><p>在讲述这个 makefile 之前，还是让我们先来粗略地看一看 makefile 的规则。</p><div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">target ... </span><span class="o">:</span> <span class="nf">prerequisites ...</span>
    <span class="err">command</span>
    <span class="err">...</span>
    <span class="err">...</span>
</code></pre></div></div><h3 id="target">target</h3><blockquote><p>可以是一个 object file（目标文件），也可以是一个执行文件，还可以是一个标签（label）。对于标签这种特性，在后续的 “伪目标” 章节中会有叙述。</p></blockquote><h3 id="prerequisites">prerequisites</h3><blockquote><p>生成该 target 所依赖的文件和 / 或 target</p></blockquote><h3 id="command">command</h3><blockquote><p>该 target 要执行的命令（任意的 shell 命令）</p></blockquote><p>这是一个文件的依赖关系，也就是说，target 这一个或多个的目标文件依赖于 prerequisites 中的文件，其生成规则定义在 command 中。说白一点就是说:</p><blockquote><p>prerequisites 中如果有一个以上的文件比 target 文件要新的话，command 所定义的命令就会被执行。 这就是 makefile 的规则，也就是 makefile 中最核心的内容。</p></blockquote><p>说到底，makefile 的东西就是这样一点，好像我的这篇文档也该结束了。呵呵。还不尽然，这是 makefile 的主线和核心，但要写好一个 makefile 还不够，我会在后面一点一点地结合我的工作经验给你慢慢道来。内容还多着呢。:)</p><h2 id="一个示例">一个示例</h2><p>正如前面所说，如果一个工程有 3 个头文件和 8 个 c 文件，为了完成前面所述的那三个规则，我们的 makefile 应该是下面的这个样子的。</p><div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">edit </span><span class="o">:</span> <span class="nf">main.o kbd.o command.o display.o </span>\
<span class="nf">        insert.o search.o files.o utils.o</span>
    <span class="err">cc</span> <span class="err">-o</span> <span class="err">edit</span> <span class="err">main.o</span> <span class="err">kbd.o</span> <span class="err">command.o</span> <span class="err">display.o</span> <span class="err">\</span>
        <span class="err">insert.o</span> <span class="err">search.o</span> <span class="err">files.o</span> <span class="err">utils.o</span>

<span class="nl">main.o </span><span class="o">:</span> <span class="nf">main.c defs.h</span>
    <span class="err">cc</span> <span class="err">-c</span> <span class="err">main.c</span>
<span class="nl">kbd.o </span><span class="o">:</span> <span class="nf">kbd.c defs.h command.h</span>
    <span class="err">cc</span> <span class="err">-c</span> <span class="err">kbd.c</span>
<span class="nl">command.o </span><span class="o">:</span> <span class="nf">command.c defs.h command.h</span>
    <span class="err">cc</span> <span class="err">-c</span> <span class="err">command.c</span>
<span class="nl">display.o </span><span class="o">:</span> <span class="nf">display.c defs.h buffer.h</span>
    <span class="err">cc</span> <span class="err">-c</span> <span class="err">display.c</span>
<span class="nl">insert.o </span><span class="o">:</span> <span class="nf">insert.c defs.h buffer.h</span>
    <span class="err">cc</span> <span class="err">-c</span> <span class="err">insert.c</span>
<span class="nl">search.o </span><span class="o">:</span> <span class="nf">search.c defs.h buffer.h</span>
    <span class="err">cc</span> <span class="err">-c</span> <span class="err">search.c</span>
<span class="nl">files.o </span><span class="o">:</span> <span class="nf">files.c defs.h buffer.h command.h</span>
    <span class="err">cc</span> <span class="err">-c</span> <span class="err">files.c</span>
<span class="nl">utils.o </span><span class="o">:</span> <span class="nf">utils.c defs.h</span>
    <span class="err">cc</span> <span class="err">-c</span> <span class="err">utils.c</span>
<span class="nl">clean </span><span class="o">:</span>
    <span class="err">rm</span> <span class="err">edit</span> <span class="err">main.o</span> <span class="err">kbd.o</span> <span class="err">command.o</span> <span class="err">display.o</span> <span class="err">\</span>
        <span class="err">insert.o</span> <span class="err">search.o</span> <span class="err">files.o</span> <span class="err">utils.o</span>
</code></pre></div></div><p>反斜杠（ \ ）是换行符的意思。这样比较便于 makefile 的阅读。我们可以把这个内容保存在名字为 “makefile” 或 “Makefile” 的文件中，然后在该目录下直接输入命令 make 就可以生成执行文件 edit。如果要删除执行文件和所有的中间目标文件，那么，只要简单地执行一下 make clean 就可以了。</p><p>在这个 makefile 中，目标文件（target）包含：执行文件 edit 和中间目标文件（ *.o ），依赖文件（prerequisites）就是冒号后面的那些 .c 文件和 .h 文件。每一个 .o 文件都有一组依赖文件，而这些 .o 文件又是执行文件 edit 的依赖文件。依赖关系的实质就是说明了目标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的。</p><p>在定义好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令，一定要以一个 Tab 键作为开头。记住，make 并不管命令是怎么工作的，他只管执行所定义的命令。make 会比较 targets 文件和 prerequisites 文件的修改日期，如果 prerequisites 文件的日期要比 targets 文件的日期要新，或者 target 不存在的话，那么，make 就会执行后续定义的命令。</p><p>这里要说明一点的是， clean 不是一个文件，它只不过是一个动作名字，有点像 c 语言中的 label 一样，其冒号后什么也没有，那么，make 就不会自动去找它的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在 make 命令后明显得指出这个 label 的名字。这样的方法非常有用，我们可以在一个 makefile 中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。</p><h2 id="make-是如何工作的">make 是如何工作的</h2><p>在默认的方式下，也就是我们只输入 make 命令。那么，</p><ol><li>make 会在当前目录下找名字叫 “Makefile” 或 “makefile” 的文件。</li><li>如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到 “edit” 这个文件，并把这个文件作为最终的目标文件。</li><li>如果 edit 文件不存在，或是 edit 所依赖的后面的 .o 文件的文件修改时间要比 edit 这个文件新，那么，他就会执行后面所定义的命令来生成 edit 这个文件。</li><li>如果 edit 所依赖的 .o 文件也不存在，那么 make 会在当前文件中找目标为 .o 文件的依赖性，如果找到则再根据那一个规则生成 .o 文件。（这有点像一个堆栈的过程）</li><li>当然，你的 C 文件和 H 文件是存在的啦，于是 make 会生成 .o 文件，然后再用 .o 文件生成 make 的终极任务，也就是执行文件 edit 了。</li></ol><p>这就是整个 make 的依赖性，make 会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么 make 就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make 根本不理。make 只管文件的依赖性，即，如果在我找了依赖关系之后，冒号后面的文件还是不在，那么对不起，我就不工作啦。</p><p>通过上述分析，我们知道，像 clean 这种，没有被第一个目标文件直接或间接关联，那么它后面所定义的命令将不会被自动执行，不过，我们可以显示要 make 执行。即命令 —— make clean ，以此来清除所有的目标文件，以便重编译。</p><p>于是在我们编程中，如果这个工程已被编译过了，当我们修改了其中一个源文件，比如 file.c ，那么根据我们的依赖性，我们的目标 file.o 会被重编译（也就是在这个依性关系后面所定义的命令），于是 file.o 的文件也是最新的啦，于是 file.o 的文件修改时间要比 edit 要新，所以 edit 也会被重新链接了（详见 edit 目标文件后定义的命令）。</p><p>而如果我们改变了 command.h ，那么， kdb.o 、 command.o 和 files.o 都会被重编译，并且， edit 会被重链接。</p><h2 id="makefile-中使用变量">makefile 中使用变量</h2><p>在上面的例子中，先让我们看看 edit 的规则：</p><div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">edit </span><span class="o">:</span> <span class="nf">main.o kbd.o command.o display.o </span>\
<span class="nf">        insert.o search.o files.o utils.o</span>
    <span class="err">cc</span> <span class="err">-o</span> <span class="err">edit</span> <span class="err">main.o</span> <span class="err">kbd.o</span> <span class="err">command.o</span> <span class="err">display.o</span> <span class="err">\</span>
        <span class="err">insert.o</span> <span class="err">search.o</span> <span class="err">files.o</span> <span class="err">utils.o</span>
</code></pre></div></div><p>我们可以看到 .o 文件的字符串被重复了两次，如果我们的工程需要加入一个新的 .o 文件，那么我们需要在两个地方加（应该是三个地方，还有一个地方在 clean 中）。当然，我们的 makefile 并不复杂，所以在两个地方加也不累，但如果 makefile 变得复杂，那么我们就有可能会忘掉一个需要加入的地方，而导致编译失败。所以，为了 makefile 的易维护，在 makefile 中我们可以使用变量。makefile 的变量也就是一个字符串，理解成 C 语言中的宏可能会更好。</p><p>比如，我们声明一个变量，叫 objects ， OBJECTS ， objs ， OBJS ， obj 或是 OBJ ，反正不管什么啦，只要能够表示 obj 文件就行了。我们在 makefile 一开始就这样定义：</p><div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">objects</span> <span class="o">=</span> main.o kbd.o command.o display.o <span class="se">\</span>
     insert.o search.o files.o utils.o
</code></pre></div></div><p>于是，我们就可以很方便地在我们的 makefile 中以 $(objects) 的方式来使用这个变量了，于是我们的改良版 makefile 就变成下面这个样子：</p><div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">objects</span> <span class="o">=</span> main.o kbd.o command.o display.o <span class="se">\</span>
    insert.o search.o files.o utils.o

<span class="nl">edit </span><span class="o">:</span> <span class="nf">$(objects)</span>
    <span class="err">cc</span> <span class="err">-o</span> <span class="err">edit</span> <span class="err">$(objects)</span>
<span class="nl">main.o </span><span class="o">:</span> <span class="nf">main.c defs.h</span>
    <span class="err">cc</span> <span class="err">-c</span> <span class="err">main.c</span>
<span class="nl">kbd.o </span><span class="o">:</span> <span class="nf">kbd.c defs.h command.h</span>
    <span class="err">cc</span> <span class="err">-c</span> <span class="err">kbd.c</span>
<span class="nl">command.o </span><span class="o">:</span> <span class="nf">command.c defs.h command.h</span>
    <span class="err">cc</span> <span class="err">-c</span> <span class="err">command.c</span>
<span class="nl">display.o </span><span class="o">:</span> <span class="nf">display.c defs.h buffer.h</span>
    <span class="err">cc</span> <span class="err">-c</span> <span class="err">display.c</span>
<span class="nl">insert.o </span><span class="o">:</span> <span class="nf">insert.c defs.h buffer.h</span>
    <span class="err">cc</span> <span class="err">-c</span> <span class="err">insert.c</span>
<span class="nl">search.o </span><span class="o">:</span> <span class="nf">search.c defs.h buffer.h</span>
    <span class="err">cc</span> <span class="err">-c</span> <span class="err">search.c</span>
<span class="nl">files.o </span><span class="o">:</span> <span class="nf">files.c defs.h buffer.h command.h</span>
    <span class="err">cc</span> <span class="err">-c</span> <span class="err">files.c</span>
<span class="nl">utils.o </span><span class="o">:</span> <span class="nf">utils.c defs.h</span>
    <span class="err">cc</span> <span class="err">-c</span> <span class="err">utils.c</span>
<span class="nl">clean </span><span class="o">:</span>
    <span class="err">rm</span> <span class="err">edit</span> <span class="err">$(objects)</span>
</code></pre></div></div><p>于是如果有新的 .o 文件加入，我们只需简单地修改一下 objects 变量就可以了。</p><h2 id="让-make-自动推导">让 make 自动推导</h2><p>GNU 的 make 很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个 .o 文件后都写上类似的命令，因为，我们的 make 会自动识别，并自己推导命令。</p><p>只要 make 看到一个 .o 文件，它就会自动的把 .c 文件加在依赖关系中，如果 make 找到一个 whatever.o ，那么 whatever.c 就会是 whatever.o 的依赖文件。并且 cc -c whatever.c 也会被推导出来，于是，我们的 makefile 再也不用写得这么复杂。我们的新 makefile 又出炉了。</p><div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">objects</span> <span class="o">=</span> main.o kbd.o command.o display.o <span class="se">\</span>
    insert.o search.o files.o utils.o

<span class="nl">edit </span><span class="o">:</span> <span class="nf">$(objects)</span>
    <span class="err">cc</span> <span class="err">-o</span> <span class="err">edit</span> <span class="err">$(objects)</span>

<span class="nl">main.o </span><span class="o">:</span> <span class="nf">defs.h</span>
<span class="nl">kbd.o </span><span class="o">:</span> <span class="nf">defs.h command.h</span>
<span class="nl">command.o </span><span class="o">:</span> <span class="nf">defs.h command.h</span>
<span class="nl">display.o </span><span class="o">:</span> <span class="nf">defs.h buffer.h</span>
<span class="nl">insert.o </span><span class="o">:</span> <span class="nf">defs.h buffer.h</span>
<span class="nl">search.o </span><span class="o">:</span> <span class="nf">defs.h buffer.h</span>
<span class="nl">files.o </span><span class="o">:</span> <span class="nf">defs.h buffer.h command.h</span>
<span class="nl">utils.o </span><span class="o">:</span> <span class="nf">defs.h</span>

<span class="nl">.PHONY </span><span class="o">:</span> <span class="nf">clean</span>
<span class="nl">clean </span><span class="o">:</span>
    <span class="err">rm</span> <span class="err">edit</span> <span class="err">$(objects)</span>
</code></pre></div></div><p>这种方法，也就是 make 的 “隐晦规则”。上面文件内容中， .PHONY 表示 clean 是个伪目标文件。</p><h2 id="另类风格的-makefiles">另类风格的 makefiles</h2><p>既然我们的 make 可以自动推导命令，那么我看到那堆 .o 和 .h 的依赖就有点不爽，那么多的重复的 .h ，能不能把其收拢起来，好吧，没有问题，这个对于 make 来说很容易，谁叫它提供了自动推导命令和文件的功能呢？来看看最新风格的 makefile 吧。</p><div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">objects</span> <span class="o">=</span> main.o kbd.o command.o display.o <span class="se">\</span>
    insert.o search.o files.o utils.o

<span class="nl">edit </span><span class="o">:</span> <span class="nf">$(objects)</span>
    <span class="err">cc</span> <span class="err">-o</span> <span class="err">edit</span> <span class="err">$(objects)</span>

<span class="nl">$(objects) </span><span class="o">:</span> <span class="nf">defs.h</span>
<span class="nl">kbd.o command.o files.o </span><span class="o">:</span> <span class="nf">command.h</span>
<span class="nl">display.o insert.o search.o files.o </span><span class="o">:</span> <span class="nf">buffer.h</span>

<span class="nl">.PHONY </span><span class="o">:</span> <span class="nf">clean</span>
<span class="nl">clean </span><span class="o">:</span>
    <span class="err">rm</span> <span class="err">edit</span> <span class="err">$(objects)</span>
</code></pre></div></div><p>这种风格，让我们的 makefile 变得很简单，但我们的文件依赖关系就显得有点凌乱了。鱼和熊掌不可兼得。还看你的喜好了。我是不喜欢这种风格的，一是文件的依赖关系看不清楚，二是如果文件一多，要加入几个新的 .o 文件，那就理不清楚了。</p><h2 id="清空目标文件的规则">清空目标文件的规则</h2><p>每个 Makefile 中都应该写一个清空目标文件（ .o 和执行文件）的规则，这不仅便于重编译，也很利于保持文件的清洁。这是一个 “修养”（呵呵，还记得我的《编程修养》吗）。一般的风格都是：</p><div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">clean</span><span class="o">:</span>
    <span class="err">rm</span> <span class="err">edit</span> <span class="err">$(objects)</span>
</code></pre></div></div><p>更为稳健的做法是：</p><div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">.PHONY </span><span class="o">:</span> <span class="nf">clean</span>
<span class="nl">clean </span><span class="o">:</span>
    <span class="err">-rm</span> <span class="err">edit</span> <span class="err">$(objects)</span>
</code></pre></div></div><p>前面说过， .PHONY 表示 clean 是一个 “伪目标”。而在 rm 命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。当然， clean 的规则不要放在文件的开头，不然，这就会变成 make 的默认目标，相信谁也不愿意这样。不成文的规矩是 ——“clean 从来都是放在文件的最后”。</p><p>上面就是一个 makefile 的概貌，也是 makefile 的基础，下面还有很多 makefile 的相关细节，准备好了吗？准备好了就来。</p><h2 id="makefile-里有什么">Makefile 里有什么？</h2><p>Makefile 里主要包含了五个东西：<strong>显式规则</strong>、<strong>隐晦规则</strong>、<strong>变量定义</strong>、<strong>文件指示和注释</strong>。</p><h3 id="显式规则">显式规则</h3><p>显式规则说明了如何生成一个或多个目标文件。这是由 Makefile 的书写者明显指出要生成的文件、文件的依赖文件和生成的命令。</p><h3 id="隐晦规则">隐晦规则</h3><p>由于我们的 make 有自动推导的功能，所以隐晦的规则可以让我们比较简略地书写 Makefile，这是由 make 所支持的。</p><h3 id="变量定义">变量定义</h3><p>在 Makefile 中我们要定义一系列的变量，变量一般都是字符串，这个有点像你 C 语言中的宏，当 Makefile 被执行时，其中的变量都会被扩展到相应的引用位置上。</p><h3 id="文件指示">文件指示</h3><p>其包括了三个部分，一个是在一个 Makefile 中引用另一个 Makefile，就像 C 语言中的 include 一样；另一个是指根据某些情况指定 Makefile 中的有效部分，就像 C 语言中的预编译 #if 一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。</p><h3 id="注释">注释</h3><p>Makefile 中只有行注释，和 UNIX 的 Shell 脚本一样，其注释是用 # 字符，这个就像 C/C++ 中的 // 一样。如果你要在你的 Makefile 中使用 # 字符，可以用反斜杠进行转义，如： # 。</p><p><strong>最后，还值得一提的是，在 Makefile 中的命令，必须要以 Tab 键开始。</strong></p><h2 id="makefile-的文件名">Makefile 的文件名</h2><p>默认的情况下，make 命令会在当前目录下按顺序找寻文件名为 “GNUmakefile”、“makefile”、“Makefile” 的文件，找到了解释这个文件。在这三个文件名中，最好使用 “Makefile” 这个文件名，因为，这个文件名第一个字符为大写，这样有一种显目的感觉。最好不要用 “GNUmakefile”，这个文件是 GNU 的 make 识别的。有另外一些 make 只对全小写的 “makefile” 文件名敏感，但是基本上来说，大多数的 make 都支持 “makefile” 和 “Makefile” 这两种默认文件名。</p><p>当然，你可以使用别的文件名来书写 Makefile，比如：“Make.Linux”，“Make.Solaris”，“Make.AIX” 等，如果要指定特定的 Makefile，你可以使用 make 的 -f 和 –file 参数，如： make -f Make.Linux 或 make –file Make.AIX 。</p><h2 id="引用其它的-makefile">引用其它的 Makefile</h2><p>在 Makefile 使用 include 关键字可以把别的 Makefile 包含进来，这很像 C 语言的 #include ，被包含的文件会原模原样的放在当前文件的包含位置。 include 的语法是：<br /> <code class="language-plaintext highlighter-rouge">include &lt;filename&gt;</code></p><p>filename 可以是当前操作系统 Shell 的文件模式（可以包含路径和通配符）。</p><p>在 include 前面可以有一些空字符，但是绝不能是 Tab 键开始。 include 和 <filename> 可以用一个或多个空格隔开。举个例子，你有这样几个 Makefile： a.mk 、 b.mk 、 c.mk ，还有一个文件叫 foo.make ，以及一个变量 $(bar) ，其包含了 e.mk 和 f.mk ，那么，下面的语句：</filename></p><p><code class="language-plaintext highlighter-rouge">include foo.make *.mk $(bar)</code><br /> 等价于：<br /> <code class="language-plaintext highlighter-rouge">include foo.make a.mk b.mk c.mk e.mk f.mk</code></p><p>make 命令开始时，会找寻 include 所指出的其它 Makefile，并把其内容安置在当前的位置。就好像 C/C++ 的 #include 指令一样。如果文件都没有指定绝对路径或是相对路径的话，make 会在当前目录下首先寻找，如果当前目录下没有找到，那么，make 还会在下面的几个目录下找：</p><p>如果 make 执行时，有 -I 或 –include-dir 参数，那么 make 就会在这个参数所指定的目录下去寻找。<br /> 如果目录fix>/include （一般是： /usr/local/bin 或 /usr/include ）存在的话，make 也会去找。 如果有文件没有找到的话，make 会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成 makefile 的读取，make 会再重试这些没有找到，或是不能读取的文件，如果还是不行，make 才会出现一条致命信息。如果你想让 make 不理那些无法读取的文件，而继续执行，你可以在 include 前加一个减号 “-”。如： `-include <filename>`</filename></prefix></p><p>其表示，无论 include 过程中出现什么错误，都不要报错继续执行。和其它版本 make 兼容的相关命令是 sinclude，其作用和这一个是一样的。</p><h2 id="环境变量-makefiles">环境变量 MAKEFILES</h2><p>如果你的当前环境中定义了环境变量 MAKEFILES ，那么，make 会把这个变量中的值做一个类似于 include 的动作。这个变量中的值是其它的 Makefile，用空格分隔。只是，它和 include 不同的是，从这个环境变量中引入的 Makefile 的 “目标” 不会起作用，如果环境变量中定义的文件发现错误，make 也会不理。</p><p>但是在这里我还是建议不要使用这个环境变量，因为只要这个变量一被定义，那么当你使用 make 时，所有的 Makefile 都会受到它的影响，这绝不是你想看到的。在这里提这个事，只是为了告诉大家，也许有时候你的 Makefile 出现了怪事，那么你可以看看当前环境中有没有定义这个变量。</p><h2 id="make-的工作方式">make 的工作方式</h2><p>GNU 的 make 工作时的执行步骤如下：（想来其它的 make 也是类似）</p><ol><li>读入所有的 Makefile。</li><li>读入被 include 的其它 Makefile。</li><li>初始化文件中的变量。</li><li>推导隐晦规则，并分析所有规则。</li><li>为所有的目标文件创建依赖关系链。</li><li>根据依赖关系，决定哪些目标要重新生成。</li><li>执行生成命令。</li></ol><p>1-5 步为第一个阶段，6-7 为第二个阶段。第一个阶段中，如果定义的变量被使用了，那么，make 会把其展开在使用的位置。但 make 并不会完全马上展开，make 使用的是拖延战术，如果变量出现在依赖关系的规则中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。</p><p>当然，这个工作方式你不一定要清楚，但是知道这个方式你也会对 make 更为熟悉。有了这个基础，后续部分也就容易看懂了。</p><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="https://lewinz.org" target="_blank">Lewin</a></li><li>本文链接：<a href="https://lewinz.org/2021/07/26/makefile/" target="_blank">https://lewinz.org/2021/07/26/makefile/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名</li></ul></div></article><div class="share"><div class="share-component" data-disabled='qq,weibo,qzone'></div></div><div class="comment"><div id="gitalk-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/vendor/gitalk/gitalk.css"> <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> <script> var gitalk = new Gitalk({ id: '/2021/07/26/makefile/', clientID: '831a35f6d4f6fc049209', clientSecret: '6e80f9a3e9b50b498553e32179ad3adbd893ab7e', repo: 'blog-comments', owner: 'Lewinz', admin: ['Lewinz'], labels: ['gitment'], perPage: 50, }); gitalk.render('gitalk-container'); </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@built/assets/search_data.json?v=1637547479', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"> <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-7093222719567591" data-ad-slot="5263168187" data-ad-format="auto" data-full-width-responsive="true"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2021 <span title="Lewin">Lewin</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/Lewinz/lewinz.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://lewinz.org/" title="首页" target="">首页</a></li><li> <a href="https://lewinz.org/categories/" title="分类" target="">分类</a></li><li> <a href="https://lewinz.org/wiki/" title="维基" target="">维基</a></li><li> <a href="https://lewinz.org/links/" title="链接" target="">链接</a></li><li> <a href="https://lewinz.org/about/" title="关于" target="">关于</a></li><li><a href="https://lewinz.org/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul><script async src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/vendor/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="mobile-hidden" style="margin-top:8px"> <span id="busuanzi_container_site_pv" style="display:none"> 本站访问量<span id="busuanzi_value_site_pv"></span>次 </span> <span id="busuanzi_container_site_uv" style="display:none"> / 本站访客数<span id="busuanzi_value_site_uv"></span>人 </span> <span id="busuanzi_container_page_pv" style="display:none"> / 本页访问量<span id="busuanzi_value_page_pv"></span>次 / 统计始于2021-04-21 </span></div></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/vendor/share.js/dist/js/share.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script><div style="display:none"> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-80669434-1', 'auto'); ga('send', 'pageview'); </script></div></body></html>
