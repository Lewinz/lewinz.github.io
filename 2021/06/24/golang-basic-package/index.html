<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>Golang 基础包 &mdash; 阿嫂</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/rouge-themes@master/dist/github.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/vendor/share.js/dist/css/share.min.css"><link rel="canonical" href="https://lewinzheng.com/2021/06/24/golang-basic-package/"><link rel="alternate" type="application/atom+xml" title="阿嫂" href="https://lewinzheng.com/feed.xml"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/favicon.ico"><meta property="og:title" content="Golang 基础包"><meta name="keywords" content="golang, 基础包"><meta name="og:keywords" content="golang, 基础包"><meta name="description" content="time 包"><meta name="og:description" content="time 包"><meta property="og:url" content="https://lewinzheng.com/2021/06/24/golang-basic-package/"><meta property="og:site_name" content="阿嫂"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2021-06-24"> <script src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/js/main.js"></script> <script data-ad-client="ca-pub-7093222719567591" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://lewinzheng.com/" title="阿嫂"><span class="octicon octicon-mark-github"></span> 阿嫂</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://lewinzheng.com/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="https://lewinzheng.com/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="https://lewinzheng.com/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="https://lewinzheng.com/links/" class=" site-header-nav-item" target="" title="链接">链接</a> <a href="https://lewinzheng.com/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="Golang 基础包"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">Golang 基础包</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2021/06/24 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://lewinzheng.com/categories/#golang" title="golang">golang</a> </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://lewinzheng.com/categories/#基础包" title="基础包">基础包</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 15071 字，约 44 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" > <ins class="adsbygoogle content-header-ad" data-ad-client="ca-pub-7093222719567591" data-ad-slot="1650902835"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script> <br /><article class="article-content markdown-body"><h2 id="time-包">time 包</h2><p>golang 时间可分为时间点和时间段</p><ul><li>时间点 (Time)</li><li>时间段 (Duration)</li></ul><p>除此之外，还提供了其他几种类型</p><ul><li>时区 (Location)</li><li>Ticker</li><li>Timer (定时器)</li></ul><h3 id="时间点-time">时间点 (Time)</h3><h4 id="初始化">初始化</h4><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// func Now() Time</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">())</span>

<span class="c">// func Parse(layout, value string) (Time, error)</span>
<span class="n">time</span><span class="o">.</span><span class="n">Parse</span><span class="p">(</span><span class="s">"2016-01-02 15:04:05"</span><span class="p">,</span> <span class="s">"2018-04-23 12:24:51"</span><span class="p">)</span>

<span class="c">// func ParseInLocation(layout, value string, loc *Location) (Time, error) (layout 已带时区时可直接用 Parse)</span>
<span class="n">time</span><span class="o">.</span><span class="n">ParseInLocation</span><span class="p">(</span><span class="s">"2006-01-02 15:04:05"</span><span class="p">,</span> <span class="s">"2017-05-11 14:06:06"</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">Local</span><span class="p">)</span>

<span class="c">// func Unix(sec int64, nsec int64) Time</span>
<span class="n">time</span><span class="o">.</span><span class="n">Unix</span><span class="p">(</span><span class="m">1e9</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>

<span class="c">// func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time</span>
<span class="n">time</span><span class="o">.</span><span class="n">Date</span><span class="p">(</span><span class="m">2018</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">15</span><span class="p">,</span> <span class="m">30</span><span class="p">,</span> <span class="m">10</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">Local</span><span class="p">)</span>

<span class="c">// func (t Time) In(loc *Location) Time 当前时间对应指定时区的时间</span>
<span class="n">loc</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">LoadLocation</span><span class="p">(</span><span class="s">"America/Los_Angeles"</span><span class="p">)</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span><span class="o">.</span><span class="n">In</span><span class="p">(</span><span class="n">loc</span><span class="p">))</span>

<span class="c">// func (t Time) Local() Time</span>
<span class="n">t</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span><span class="o">.</span><span class="n">Local</span><span class="p">()</span>
</code></pre></div></div><h4 id="格式化">格式化</h4><h5 id="to-string">to string</h5><p>格式化为字符串我们需要使用 <code class="language-plaintext highlighter-rouge">time.Format</code> 方法来转换成我们想要的格式</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span><span class="o">.</span><span class="n">Format</span><span class="p">(</span><span class="s">"2006-01-02 15:04:05"</span><span class="p">))</span>  <span class="c">// 2018-04-24 10:11:20</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span><span class="o">.</span><span class="n">Format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">UnixDate</span><span class="p">))</span>         <span class="c">// Tue Apr 24 09:59:02 CST 2018</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">Format</code> 函数中可以指定你想使用的格式，同时 <code class="language-plaintext highlighter-rouge">time</code> 包中也给了一些我们常用的格式</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="p">(</span>
    <span class="n">ANSIC</span>       <span class="o">=</span> <span class="s">"Mon Jan _2 15:04:05 2006"</span>
    <span class="n">UnixDate</span>    <span class="o">=</span> <span class="s">"Mon Jan _2 15:04:05 MST 2006"</span>
    <span class="n">RubyDate</span>    <span class="o">=</span> <span class="s">"Mon Jan 02 15:04:05 -0700 2006"</span>
    <span class="n">RFC822</span>      <span class="o">=</span> <span class="s">"02 Jan 06 15:04 MST"</span>
    <span class="n">RFC822Z</span>     <span class="o">=</span> <span class="s">"02 Jan 06 15:04 -0700"</span> <span class="c">// RFC822 with numeric zone</span>
    <span class="n">RFC850</span>      <span class="o">=</span> <span class="s">"Monday, 02-Jan-06 15:04:05 MST"</span>
    <span class="n">RFC1123</span>     <span class="o">=</span> <span class="s">"Mon, 02 Jan 2006 15:04:05 MST"</span>
    <span class="n">RFC1123Z</span>    <span class="o">=</span> <span class="s">"Mon, 02 Jan 2006 15:04:05 -0700"</span> <span class="c">// RFC1123 with numeric zone</span>
    <span class="n">RFC3339</span>     <span class="o">=</span> <span class="s">"2006-01-02T15:04:05Z07:00"</span>
    <span class="n">RFC3339Nano</span> <span class="o">=</span> <span class="s">"2006-01-02T15:04:05.999999999Z07:00"</span>
    <span class="n">Kitchen</span>     <span class="o">=</span> <span class="s">"3:04PM"</span>
    <span class="c">// Handy time stamps.</span>
    <span class="n">Stamp</span>      <span class="o">=</span> <span class="s">"Jan _2 15:04:05"</span>
    <span class="n">StampMilli</span> <span class="o">=</span> <span class="s">"Jan _2 15:04:05.000"</span>
    <span class="n">StampMicro</span> <span class="o">=</span> <span class="s">"Jan _2 15:04:05.000000"</span>
    <span class="n">StampNano</span>  <span class="o">=</span> <span class="s">"Jan _2 15:04:05.000000000"</span>
<span class="p">)</span>
</code></pre></div></div><p>** 注意 **: <code class="language-plaintext highlighter-rouge">galang</code> 中指定的特定时间格式为 <code class="language-plaintext highlighter-rouge">"2006-01-02 15:04:05 -0700 MST"</code>， 为了记忆方便，按照美式时间格式 月日时分秒年 外加时区 排列起来依次是 01/02 03:04:05PM ‘06 -0700，刚开始使用时需要注意。</p><h5 id="to-time-stamp">to time stamp</h5><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="n">Time</span><span class="p">)</span> <span class="n">Unix</span><span class="p">()</span> <span class="kt">int64</span>
<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="n">Time</span><span class="p">)</span> <span class="n">UnixNano</span><span class="p">()</span> <span class="kt">int64</span>

<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span><span class="o">.</span><span class="n">Unix</span><span class="p">())</span>

<span class="c">// 获取指定日期的时间戳</span>
<span class="n">dt</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">Parse</span><span class="p">(</span><span class="s">"2016-01-02 15:04:05"</span><span class="p">,</span> <span class="s">"2018-04-23 12:24:51"</span><span class="p">)</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">Unix</span><span class="p">())</span>

<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Date</span><span class="p">(</span><span class="m">2018</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="m">15</span><span class="p">,</span><span class="m">30</span><span class="p">,</span><span class="m">10</span><span class="p">,</span><span class="m">0</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">Local</span><span class="p">)</span><span class="o">.</span><span class="n">Unix</span><span class="p">())</span>
</code></pre></div></div><h4 id="其他">其他</h4><p><code class="language-plaintext highlighter-rouge">time</code> 包还提供了一些常用的方法，基本覆盖了大多数业务，从方法名就能知道代表的含义就不一一说明了。</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="n">Time</span><span class="p">)</span> <span class="n">Date</span><span class="p">()</span> <span class="p">(</span><span class="n">year</span> <span class="kt">int</span><span class="p">,</span> <span class="n">month</span> <span class="n">Month</span><span class="p">,</span> <span class="n">day</span> <span class="kt">int</span><span class="p">)</span>
<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="n">Time</span><span class="p">)</span> <span class="n">Clock</span><span class="p">()</span> <span class="p">(</span><span class="n">hour</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="n">sec</span> <span class="kt">int</span><span class="p">)</span>
<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="n">Time</span><span class="p">)</span> <span class="n">Year</span><span class="p">()</span> <span class="kt">int</span>
<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="n">Time</span><span class="p">)</span> <span class="n">Month</span><span class="p">()</span> <span class="n">Month</span>
<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="n">Time</span><span class="p">)</span> <span class="n">Day</span><span class="p">()</span> <span class="kt">int</span>
<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="n">Time</span><span class="p">)</span> <span class="n">Hour</span><span class="p">()</span> <span class="kt">int</span>
<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="n">Time</span><span class="p">)</span> <span class="n">Minute</span><span class="p">()</span> <span class="kt">int</span>
<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="n">Time</span><span class="p">)</span> <span class="n">Second</span><span class="p">()</span> <span class="kt">int</span>
<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="n">Time</span><span class="p">)</span> <span class="n">Nanosecond</span><span class="p">()</span> <span class="kt">int</span>
<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="n">Time</span><span class="p">)</span> <span class="n">YearDay</span><span class="p">()</span> <span class="kt">int</span>
<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="n">Time</span><span class="p">)</span> <span class="n">Weekday</span><span class="p">()</span> <span class="n">Weekday</span>
<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="n">Time</span><span class="p">)</span> <span class="n">ISOWeek</span><span class="p">()</span> <span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="n">week</span> <span class="kt">int</span><span class="p">)</span>
<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="n">Time</span><span class="p">)</span> <span class="n">IsZero</span><span class="p">()</span> <span class="kt">bool</span>
<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="n">Time</span><span class="p">)</span> <span class="n">Local</span><span class="p">()</span> <span class="n">Time</span>
<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="n">Time</span><span class="p">)</span> <span class="n">Location</span><span class="p">()</span> <span class="o">*</span><span class="n">Location</span>
<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="n">Time</span><span class="p">)</span> <span class="n">Zone</span><span class="p">()</span> <span class="p">(</span><span class="n">name</span> <span class="kt">string</span><span class="p">,</span> <span class="n">offset</span> <span class="kt">int</span><span class="p">)</span>
<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="n">Time</span><span class="p">)</span> <span class="n">Unix</span><span class="p">()</span> <span class="kt">int64</span>
</code></pre></div></div><h3 id="时间段-duartion">时间段 (Duartion)</h3><p>介绍完了时间点，我们再来介绍时间段，即 <code class="language-plaintext highlighter-rouge">Duartion</code> 类型， 我们业务也是很常用的类型。</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// func ParseDuration(s string) (Duration, error)</span>
<span class="n">tp</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">ParseDuration</span><span class="p">(</span><span class="s">"1.5s"</span><span class="p">)</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">tp</span><span class="o">.</span><span class="n">Truncate</span><span class="p">(</span><span class="m">1000</span><span class="p">),</span> <span class="n">tp</span><span class="o">.</span><span class="n">Seconds</span><span class="p">(),</span> <span class="n">tp</span><span class="o">.</span><span class="n">Nanoseconds</span><span class="p">())</span>

<span class="k">func</span> <span class="p">(</span><span class="n">d</span> <span class="n">Duration</span><span class="p">)</span> <span class="n">Hours</span><span class="p">()</span> <span class="kt">float64</span>
<span class="k">func</span> <span class="p">(</span><span class="n">d</span> <span class="n">Duration</span><span class="p">)</span> <span class="n">Minutes</span><span class="p">()</span> <span class="kt">float64</span>
<span class="k">func</span> <span class="p">(</span><span class="n">d</span> <span class="n">Duration</span><span class="p">)</span> <span class="n">Seconds</span><span class="p">()</span> <span class="kt">float64</span>
<span class="k">func</span> <span class="p">(</span><span class="n">d</span> <span class="n">Duration</span><span class="p">)</span> <span class="n">Nanoseconds</span><span class="p">()</span> <span class="kt">int64</span>
<span class="k">func</span> <span class="p">(</span><span class="n">d</span> <span class="n">Duration</span><span class="p">)</span> <span class="n">Round</span><span class="p">(</span><span class="n">m</span> <span class="n">Duration</span><span class="p">)</span> <span class="n">Duration</span>         <span class="c">// 四舍五入</span>
<span class="k">func</span> <span class="p">(</span><span class="n">d</span> <span class="n">Duration</span><span class="p">)</span> <span class="n">Truncate</span><span class="p">(</span><span class="n">m</span> <span class="n">Duration</span><span class="p">)</span> <span class="n">Duration</span>      <span class="c">// 向下取整</span>
</code></pre></div></div><h3 id="时区-location">时区 (Location)</h3><p>我们在来介绍一下时区的相关的函数</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// 默认 UTC    </span>
<span class="n">loc</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">LoadLocation</span><span class="p">(</span><span class="s">""</span><span class="p">)</span> 
<span class="c">// 服务器设定的时区，一般为 CST</span>
<span class="n">loc</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">LoadLocation</span><span class="p">(</span><span class="s">"Local"</span><span class="p">)</span>
<span class="c">// 美国洛杉矶 PDT</span>
<span class="n">loc</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">LoadLocation</span><span class="p">(</span><span class="s">"America/Los_Angeles"</span><span class="p">)</span>

<span class="c">// 获取指定时区的时间点</span>
<span class="n">local</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">LoadLocation</span><span class="p">(</span><span class="s">"America/Los_Angeles"</span><span class="p">)</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Date</span><span class="p">(</span><span class="m">2018</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">12</span><span class="p">,</span><span class="m">0</span><span class="p">,</span><span class="m">0</span><span class="p">,</span><span class="m">0</span><span class="p">,</span> <span class="n">local</span><span class="p">))</span>
</code></pre></div></div><p>可以在 <code class="language-plaintext highlighter-rouge">$GOROOT/lib/time/zoneinfo.zip</code> 文件下看到所有时区。</p><h3 id="时间运算">时间运算</h3><p>好了，基础的类型我们介绍完，现在开始时间运算相关的函数，也是日常业务中我们大量应用的。</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// func Sleep(d Duration)   休眠多少时间，休眠时处于阻塞状态，后续程序无法执行</span>
<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Duration</span><span class="p">(</span><span class="m">10</span><span class="p">)</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>

<span class="c">// func After(d Duration) &lt;-chan Time  非阻塞, 可用于延迟</span>
<span class="n">time</span><span class="o">.</span><span class="n">After</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Duration</span><span class="p">(</span><span class="m">10</span><span class="p">)</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>

<span class="c">// func Since(t Time) Duration 两个时间点的间隔</span>
<span class="n">start</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Since</span><span class="p">(</span><span class="n">start</span><span class="p">))</span>   <span class="c">// 等价于 Now().Sub(t)， 可用来计算一段业务的消耗时间</span>

<span class="k">func</span> <span class="n">Until</span><span class="p">(</span><span class="n">t</span> <span class="n">Time</span><span class="p">)</span> <span class="n">Duration</span>     <span class="c">//  等价于 t.Sub(Now())，t 与当前时间的间隔</span>

<span class="c">// func (t Time) Add(d Duration) Time</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Duration</span><span class="p">(</span><span class="m">10</span><span class="p">)</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">))</span>   <span class="c">// 加</span>

<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="n">Time</span><span class="p">)</span> <span class="n">Sub</span><span class="p">(</span><span class="n">u</span> <span class="n">Time</span><span class="p">)</span> <span class="n">Duration</span>                    <span class="c">// 减 </span>

<span class="c">// func (t Time) AddDate(years int, months int, days int) Time</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">AddDate</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">1</span><span class="p">))</span>

<span class="c">// func (t Time) Before(u Time) bool</span>
<span class="c">// func (t Time) After(u Time) bool</span>
<span class="c">// func (t Time) Equal(u Time) bool          比较时间点时尽量使用 Equal 函数</span>
</code></pre></div></div><h3 id="使用场景">使用场景</h3><h4 id="日期时间差">日期时间差</h4><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dt1</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">Date</span><span class="p">(</span><span class="m">2018</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">10</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">100</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">Local</span><span class="p">)</span>
<span class="n">dt2</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">Date</span><span class="p">(</span><span class="m">2018</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">9</span><span class="p">,</span> <span class="m">23</span><span class="p">,</span> <span class="m">59</span><span class="p">,</span> <span class="m">22</span><span class="p">,</span> <span class="m">100</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">Local</span><span class="p">)</span>
<span class="c">// 不用关注时区，go 会转换成时间戳进行计算</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">dt1</span><span class="o">.</span><span class="n">Sub</span><span class="p">(</span><span class="n">dt2</span><span class="p">))</span>
</code></pre></div></div><h4 id="基于当前时间的前后运算">基于当前时间的前后运算</h4><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">now</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span>

<span class="c">// 一年零一个月一天之后</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">now</span><span class="o">.</span><span class="n">Date</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">))</span>
<span class="c">// 一段时间之后</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">now</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Duration</span><span class="p">(</span><span class="m">10</span><span class="p">)</span><span class="o">*</span><span class="n">time</span><span class="o">.</span><span class="n">Minute</span><span class="p">))</span>

<span class="c">// 计算两个时间点的相差天数</span>
<span class="n">dt1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">Date</span><span class="p">(</span><span class="n">dt1</span><span class="o">.</span><span class="n">Year</span><span class="p">(),</span> <span class="n">dt1</span><span class="o">.</span><span class="n">Month</span><span class="p">(),</span> <span class="n">dt1</span><span class="o">.</span><span class="n">Day</span><span class="p">(),</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">Local</span><span class="p">)</span>
<span class="n">dt2</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">Date</span><span class="p">(</span><span class="n">dt2</span><span class="o">.</span><span class="n">Year</span><span class="p">(),</span> <span class="n">dt2</span><span class="o">.</span><span class="n">Month</span><span class="p">(),</span> <span class="n">dt2</span><span class="o">.</span><span class="n">Day</span><span class="p">(),</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">Local</span><span class="p">)</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">Ceil</span><span class="p">(</span><span class="n">dt1</span><span class="o">.</span><span class="n">Sub</span><span class="p">(</span><span class="n">dt2</span><span class="p">)</span><span class="o">.</span><span class="n">Hours</span><span class="p">()</span> <span class="o">/</span> <span class="m">24</span><span class="p">)))</span>
</code></pre></div></div><h4 id="时区转换">时区转换</h4><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// time.Local 用来表示当前服务器时区</span>
<span class="c">// 自定义地区时间</span>
<span class="n">secondsEastOfUTC</span> <span class="o">:=</span> <span class="kt">int</span><span class="p">((</span><span class="m">8</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Hour</span><span class="p">)</span><span class="o">.</span><span class="n">Seconds</span><span class="p">())</span>
<span class="n">beijing</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">FixedZone</span><span class="p">(</span><span class="s">"Beijing Time"</span><span class="p">,</span> <span class="n">secondsEastOfUTC</span><span class="p">)</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Date</span><span class="p">(</span><span class="m">2018</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="m">0</span><span class="p">,</span><span class="m">0</span><span class="p">,</span><span class="m">0</span><span class="p">,</span><span class="m">0</span><span class="p">,</span> <span class="n">beijing</span><span class="p">))</span>  <span class="c">// 2018-01-02 00:00:00 +0800 Beijing Time  </span>

<span class="c">// 当前时间转为指定时区时间</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span><span class="o">.</span><span class="n">In</span><span class="p">(</span><span class="n">beijing</span><span class="p">))</span>

<span class="c">// 指定时间转换成指定时区对应的时间</span>
<span class="n">dt</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">ParseInLocation</span><span class="p">(</span><span class="s">"2006-01-02 15:04:05"</span><span class="p">,</span> <span class="s">"2017-05-11 14:06:06"</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">Local</span><span class="p">)</span>

<span class="c">// 当前时间在零时区年月日   时分秒  时区</span>
<span class="n">year</span><span class="p">,</span> <span class="n">mon</span><span class="p">,</span> <span class="n">day</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span><span class="o">.</span><span class="n">UTC</span><span class="p">()</span><span class="o">.</span><span class="n">Date</span><span class="p">()</span>     <span class="c">// 2018 April 24 </span>
<span class="n">hour</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="n">sec</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span><span class="o">.</span><span class="n">UTC</span><span class="p">()</span><span class="o">.</span><span class="n">Clock</span><span class="p">()</span>    <span class="c">// 3 47 15</span>
<span class="n">zone</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span><span class="o">.</span><span class="n">UTC</span><span class="p">()</span><span class="o">.</span><span class="n">Zone</span><span class="p">()</span>            <span class="c">// UTC</span>
</code></pre></div></div><h4 id="比较两个时间点">比较两个时间点</h4><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dt</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">Date</span><span class="p">(</span><span class="m">2018</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">10</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">100</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">Local</span><span class="p">)</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span><span class="o">.</span><span class="n">After</span><span class="p">(</span><span class="n">dt</span><span class="p">))</span>     <span class="c">// true</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span><span class="o">.</span><span class="n">Before</span><span class="p">(</span><span class="n">dt</span><span class="p">))</span>    <span class="c">// false</span>

<span class="c">// 是否相等 判断两个时间点是否相等时推荐使用 Equal 函数</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">Equal</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()))</span>
</code></pre></div></div><h4 id="设置执行时间">设置执行时间</h4><p>通过 <code class="language-plaintext highlighter-rouge">time.After</code> 函数与 <code class="language-plaintext highlighter-rouge">select</code> 结合使用可用于处理程序超时设定</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">m</span> <span class="o">:=</span> <span class="o">&lt;-</span> <span class="n">c</span><span class="o">:</span>
    <span class="c">// do something</span>
  <span class="k">case</span> <span class="o">&lt;-</span> <span class="n">time</span><span class="o">.</span><span class="n">After</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Duration</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="o">*</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span><span class="o">:</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"time out"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div><h4 id="ticker-类型">Ticker 类型</h4><p><code class="language-plaintext highlighter-rouge">Ticker</code> 类型包含一个 <code class="language-plaintext highlighter-rouge">channel</code> ，有时我们会遇到每隔一段时间执行的业务 (比如设置心跳时间等)，就可以用它来处理，这是一个重复的过程</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// 无法取消</span>
<span class="n">tick</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">Tick</span><span class="p">(</span><span class="m">1</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Minute</span><span class="p">)</span>
<span class="k">for</span> <span class="n">_</span> <span class="o">=</span> <span class="k">range</span> <span class="n">tick</span> <span class="p">{</span>
  <span class="c">// do something</span>
<span class="p">}</span>

<span class="c">// 可通过调用 ticker.Stop 取消</span>
<span class="n">ticker</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">NewTicker</span><span class="p">(</span><span class="m">1</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Minute</span><span class="p">)</span>
<span class="k">for</span> <span class="n">_</span> <span class="o">=</span> <span class="k">range</span> <span class="n">tick</span> <span class="p">{</span>
  <span class="c">// do something</span>
<span class="p">}</span>
</code></pre></div></div><h4 id="timer-类型">Timer 类型</h4><p><code class="language-plaintext highlighter-rouge">Timer</code> 类型用来代表一个单独的事件，当设置的时间过期后，发送当前的时间到 <code class="language-plaintext highlighter-rouge">channel</code>, 我们可以通过以下两种方式来创建</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">AfterFunc</span><span class="p">(</span><span class="n">d</span> <span class="n">Duration</span><span class="p">,</span> <span class="n">f</span> <span class="k">func</span><span class="p">())</span> <span class="o">*</span><span class="n">Timer</span>   <span class="c">// 指定一段时间后指定的函数</span>
<span class="k">func</span> <span class="n">NewTimer</span><span class="p">(</span><span class="n">d</span> <span class="n">Duration</span><span class="p">)</span> <span class="o">*</span><span class="n">Timer</span>     
</code></pre></div></div><p>以上两函数都可以使用 <code class="language-plaintext highlighter-rouge">Reset</code>, 这个有个需要注意的地方是使用 <code class="language-plaintext highlighter-rouge">Reset</code> 时需要确保 <code class="language-plaintext highlighter-rouge">t.C</code> 通道被释放时才能调用，以防止发生资源竞争的问题，可通过以下方式解决</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">!</span><span class="n">t</span><span class="o">.</span><span class="n">Stop</span><span class="p">()</span> <span class="p">{</span>
  <span class="o">&lt;-</span><span class="n">t</span><span class="o">.</span><span class="n">C</span>
<span class="p">}</span>
<span class="n">t</span><span class="o">.</span><span class="n">Reset</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
</code></pre></div></div><h2 id="os-包">os 包</h2><p>Go 语言的 os 包中提供了操作系统函数的接口，是一个比较重要的包。顾名思义，os 包的作用主要是在服务器上进行系统的基本操作，如文件操作、目录操作、执行命令、信号与中断、进程、系统状态等等。</p><h3 id="常用函数">常用函数</h3><ul><li>Hostname 函数定义:<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">Hostname</span><span class="p">()</span> <span class="p">(</span><span class="n">name</span> <span class="kt">string</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></div></div></li></ul><p>Hostname 函数会返回内核提供的主机名。</p><ul><li>Environ 函数定义:<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">Environ</span><span class="p">()</span> <span class="p">[]</span><span class="kt">string</span>
</code></pre></div></div></li></ul><p>Environ 函数会返回所有的环境变量，返回值格式为 “key=value” 的字符串的切片拷贝。</p><ul><li>Getenv 函数定义:<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">Getenv</span><span class="p">(</span><span class="n">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span>
</code></pre></div></div></li></ul><p>Getenv 函数会检索并返回名为 key 的环境变量的值。如果不存在该环境变量则会返回空字符串。</p><ul><li>Setenv 函数定义:<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">Setenv</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span>
</code></pre></div></div></li></ul><p>Setenv 函数可以设置名为 key 的环境变量，如果出错会返回该错误。</p><ul><li>Exit 函数定义:<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">Exit</span><span class="p">(</span><span class="n">code</span> <span class="kt">int</span><span class="p">)</span>
</code></pre></div></div></li></ul><p>Exit 函数可以让当前程序以给出的状态码 code 退出。一般来说，状态码 0 表示成功，非 0 表示出错。程序会立刻终止，并且 defer 的函数不会被执行。</p><ul><li>Getuid 函数定义:<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">Getuid</span><span class="p">()</span> <span class="kt">int</span>
</code></pre></div></div></li></ul><p>Getuid 函数可以返回调用者的用户 ID。</p><ul><li>Getgid 函数定义:<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">Getgid</span><span class="p">()</span> <span class="kt">int</span>
</code></pre></div></div></li></ul><p>Getgid 函数可以返回调用者的组 ID。</p><ul><li>Getpid 函数定义:<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">Getpid</span><span class="p">()</span> <span class="kt">int</span>
</code></pre></div></div></li></ul><p>Getpid 函数可以返回调用者所在进程的进程 ID。</p><ul><li>Getwd 函数定义:<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">Getwd</span><span class="p">()</span> <span class="p">(</span><span class="n">dir</span> <span class="kt">string</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></div></div></li></ul><p>Getwd 函数可以返回一个对应当前工作目录的根路径。如果当前目录可以经过多条路径抵达（因为硬链接），Getwd 会返回其中一个。</p><ul><li>Mkdir 函数定义:<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">Mkdir</span><span class="p">(</span><span class="n">name</span> <span class="kt">string</span><span class="p">,</span> <span class="n">perm</span> <span class="n">FileMode</span><span class="p">)</span> <span class="kt">error</span>
</code></pre></div></div></li></ul><p>Mkdir 函数可以使用指定的权限和名称创建一个目录。如果出错，会返回 *PathError 底层类型的错误。</p><ul><li>MkdirAll 函数定义:<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">MkdirAll</span><span class="p">(</span><span class="n">path</span> <span class="kt">string</span><span class="p">,</span> <span class="n">perm</span> <span class="n">FileMode</span><span class="p">)</span> <span class="kt">error</span>
</code></pre></div></div></li></ul><p>MkdirAll 函数可以使用指定的权限和名称创建一个目录，包括任何必要的上级目录，并返回 nil，否则返回错误。权限位 perm 会应用在每一个被该函数创建的目录上。如果 path 指定了一个已经存在的目录，MkdirAll 不做任何操作并返回 nil。</p><ul><li>Remove 函数定义:<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">Remove</span><span class="p">(</span><span class="n">name</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span>
</code></pre></div></div></li></ul><p>Remove 函数会删除 name 指定的文件或目录。如果出错，会返回 *PathError 底层类型的错误。</p><p>RemoveAll 函数跟 Remove 用法一样，区别是会递归的删除所有子目录和文件。</p><h3 id="execsignaluser-子包">exec，signal，user 子包</h3><h4 id="exec">exec</h4><p>exec 包可以执行外部命令，它包装了 os.StartProcess 函数以便更容易的修正输入和输出，使用管道连接 I/O，以及作其它的一些调整。</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">LookPath</span><span class="p">(</span><span class="n">file</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></div></div><p>在环境变量 PATH 指定的目录中搜索可执行文件，如果 file 中有斜杠，则只在当前目录搜索。返回完整路径或者相对于当前目录的一个相对路径。</p><p>示例代码如下：</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>
<span class="k">import</span> <span class="p">(</span>
    <span class="s">"fmt"</span>
    <span class="s">"os/exec"</span>
<span class="p">)</span>
<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">f</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">exec</span><span class="o">.</span><span class="n">LookPath</span><span class="p">(</span><span class="s">"main"</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div><p>运行结果如下：</p><div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>main.exe
</code></pre></div></div><h4 id="user">user</h4><p>可以通过 os/user 包中的 Current () 函数来获取当前用户信息，该函数会返回一个 User 结构体，结构体中的 Username、Uid、HomeDir、Gid 分别表示当前用户的名称、用户 id、用户主目录和用户所属组 id，函数原型如下：</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">Current</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="n">User</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></div></div><p>示例代码如下：</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>
<span class="k">import</span> <span class="p">(</span>
    <span class="s">"log"</span>
    <span class="s">"os/user"</span>
<span class="p">)</span>
<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">user</span><span class="o">.</span><span class="n">Current</span><span class="p">()</span>
    <span class="n">log</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"用户名："</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Username</span><span class="p">)</span>
    <span class="n">log</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"用户 id"</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Uid</span><span class="p">)</span>
    <span class="n">log</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"用户主目录："</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">HomeDir</span><span class="p">)</span>
    <span class="n">log</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"主组 id："</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Gid</span><span class="p">)</span>
    <span class="c">// 用户所在的所有的组的 id</span>
    <span class="n">s</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">u</span><span class="o">.</span><span class="n">GroupIds</span><span class="p">()</span>
    <span class="n">log</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"用户所在的所有组："</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div><p>运行结果如下：</p><div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2019/12/13 15:12:14 用户名： LENOVO-PC<span class="se">\A</span>dministrator
2019/12/13 15:12:14 用户 <span class="nb">id </span>S-1-5-21-711400000-2334436127-1750000211-000
2019/12/13 15:12:14 用户主目录： C:<span class="se">\U</span>sers<span class="se">\A</span>dministrator
2019/12/13 15:12:14 主组 <span class="nb">id</span>： S-1-5-22-766000000-2300000100-1050000262-000
2019/12/13 15:12:14 用户所在的所有组： <span class="o">[</span>S-1-5-32-544 S-1-5-22-000 S-1-5-21-777400999-2344436111-1750000262-003]
</code></pre></div></div><h4 id="signal">signal</h4><p>一个运行良好的程序在退出（正常退出或者强制退出，如 Ctrl+C，kill 等）时是可以执行一段清理代码的，将收尾工作做完后再真正退出。一般采用系统 Signal 来通知系统退出，如 kill pid，在程序中针对一些系统信号设置了处理函数，当收到信号后，会执行相关清理程序或通知各个子进程做自清理。</p><p>Go 语言中对信号的处理主要使用 os/signal 包中的两个方法，一个是 Notify 方法用来监听收到的信号，一个是 stop 方法用来取消监听。</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">Notify</span><span class="p">(</span><span class="n">c</span> <span class="k">chan</span><span class="o">&lt;-</span> <span class="n">os</span><span class="o">.</span><span class="n">Signal</span><span class="p">,</span> <span class="n">sig</span> <span class="o">...</span><span class="n">os</span><span class="o">.</span><span class="n">Signal</span><span class="p">)</span>
</code></pre></div></div><p>其中，第一个参数表示接收信号的 channel，第二个及后面的参数表示设置要监听的信号，如果不设置表示监听所有的信号。</p><p>【示例 1】使用 Notify 方法来监听收到的信号：</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>
<span class="k">import</span> <span class="p">(</span>
    <span class="s">"fmt"</span>
    <span class="s">"os"</span>
    <span class="s">"os/signal"</span>
<span class="p">)</span>
<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="n">os</span><span class="o">.</span><span class="n">Signal</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
    <span class="n">signal</span><span class="o">.</span><span class="n">Notify</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="c">// Block until a signal is received.</span>
    <span class="n">s</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">c</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Got signal:"</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div><p>运行该程序，然后在 CMD 窗口中通过 Ctrl+C 来结束该程序，便会得到输出结果：</p><div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Got signal: interrupt
</code></pre></div></div><p>【示例 2】使用 stop 方法来取消监听：</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>
<span class="k">import</span> <span class="p">(</span>
    <span class="s">"fmt"</span>
    <span class="s">"os"</span>
    <span class="s">"os/signal"</span>
<span class="p">)</span>
<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="n">os</span><span class="o">.</span><span class="n">Signal</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
    <span class="n">signal</span><span class="o">.</span><span class="n">Notify</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="n">signal</span><span class="o">.</span><span class="n">Stop</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="c">// 不允许继续往 c 中存入内容</span>
    <span class="n">s</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">c</span>       <span class="c">//c 无内容，此处阻塞，所以不会执行下面的语句，也就没有输出</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Got signal:"</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div><p>因为使用 Stop 方法取消了 Notify 方法的监听，所以运行程序没有输出结果。</p><h3 id="osopen-参数">os.Open 参数</h3><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">os</span><span class="o">.</span><span class="n">OpenFile</span><span class="p">(</span><span class="n">name</span> <span class="kt">string</span><span class="p">,</span> <span class="n">flag</span> <span class="kt">int</span><span class="p">,</span> <span class="n">perm</span> <span class="n">os</span><span class="o">.</span><span class="n">FileMode</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="n">os</span><span class="o">.</span><span class="n">File</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></div></div><p>flag 参数： | 参数名 | 含义 | | O_RDONLY | 打开只读文件 | | O_WRONLY | 打开只写文件 | | O_RDWR | 打开既可以读取又可以写入文件 | | O_APPEND | 写入文件时将数据追加到文件尾部 | | O_CREATE | 如果文件不存在，则创建一个新的文件 | | O_EXCL | 文件必须不存在，然后会创建一个新的文件 | | O_SYNC | 打开同步 I/0 | | O_TRUNC | 文件打开时可以截断 |</p><p>示例：</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">file</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">os</span><span class="o">.</span><span class="n">OpenFile</span><span class="p">(</span><span class="s">"a.txt"</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">O_APPEND</span><span class="o">|</span><span class="n">os</span><span class="o">.</span><span class="n">O_WRONLY</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">ModeAppend</span><span class="p">)</span>
</code></pre></div></div><h2 id="sync-包">sync 包</h2><p><code class="language-plaintext highlighter-rouge">sync</code> 整个包都围绕这 <code class="language-plaintext highlighter-rouge">Locker</code> 进行，这是一个 <code class="language-plaintext highlighter-rouge">interface</code> ：</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Locker</span> <span class="k">interface</span> <span class="p">{</span>
        <span class="n">Lock</span><span class="p">()</span>
        <span class="n">Unlock</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div><p>只有两个方法，Lock() 和 Unlock()。</p><p>另外该包下的对象，在使用过之后，** 千万不要复制 **。</p><h3 id="为什么需要锁">为什么需要锁？</h3><p>在并发的情况下，多个线程或协程同时去修改一个变量，可能会出现如下情况：</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
    <span class="s">"fmt"</span>
    <span class="s">"sync"</span>
    <span class="s">"time"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">a</span> <span class="o">=</span> <span class="m">0</span>

    <span class="c">// 启动 100 个协程，需要足够大</span>
    <span class="c">// var lock sync.Mutex</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">go</span> <span class="k">func</span><span class="p">(</span><span class="n">idx</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
            <span class="c">// lock.Lock()</span>
            <span class="c">// defer lock.Unlock()</span>
            <span class="n">a</span> <span class="o">+=</span> <span class="m">1</span>
            <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"goroutine %d, a=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
        <span class="p">}(</span><span class="n">i</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c">// 等待 1s 结束主程序</span>
    <span class="c">// 确保所有协程执行完</span>
    <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div><p>观察打印结果，是否出现 a 的值是相同的情况（未出现则重试或调大协程数），答案：是的。</p><p>显然这不是我们想要的结果。出现这种情况的原因是，协程依次执行：<br /> 从寄存器读取 a 的值 -&gt; 然后做加法运算 -&gt; 最后写会寄存器。</p><p>试想，此时一个协程取出 a 的值 3，正在做加法运算（还未写回寄存器）。同时另一个协程此时去取，取出了同样的 a 的值 3。最终导致的结果是，两个协程产出的结果相同，a 相当于只增加了 1。</p><p>所以，锁的概念就是，我正在处理 a（锁定），你们谁都别和我抢，等我处理完了（解锁），你们再处理。这样就实现了，同时处理 a 的协程只有一个，就实现了同步。</p><p>把上面代码里的注释取消掉再试下。</p><h3 id="什么是互斥锁-mutex">什么是互斥锁 Mutex？</h3><p>什么是互斥锁？它是锁的一种具体实现，有两个方法：</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">m</span> <span class="o">*</span><span class="n">Mutex</span><span class="p">)</span> <span class="n">Lock</span><span class="p">()</span>
<span class="k">func</span> <span class="p">(</span><span class="n">m</span> <span class="o">*</span><span class="n">Mutex</span><span class="p">)</span> <span class="n">Unlock</span><span class="p">()</span>
</code></pre></div></div><p>在首次使用后不要复制该互斥锁。对一个未锁定的互斥锁解锁将会产生运行时错误。</p><p>一个互斥锁只能同时被一个 goroutine 锁定，其它 goroutine 将阻塞直到互斥锁被解锁（重新争抢对互斥锁的锁定）。如：</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
    <span class="s">"fmt"</span>
    <span class="s">"sync"</span>
    <span class="s">"time"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="k">struct</span><span class="p">{},</span> <span class="m">2</span><span class="p">)</span>

    <span class="k">var</span> <span class="n">l</span> <span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span>
    <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">l</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
        <span class="k">defer</span> <span class="n">l</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"goroutine1: 我会锁定大概 2s"</span><span class="p">)</span>
        <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span> <span class="o">*</span> <span class="m">2</span><span class="p">)</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"goroutine1: 我解锁了，你们去抢吧"</span><span class="p">)</span>
        <span class="n">ch</span> <span class="o">&lt;-</span> <span class="k">struct</span><span class="p">{}{}</span>
    <span class="p">}()</span>

    <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"groutine2: 等待解锁"</span><span class="p">)</span>
        <span class="n">l</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
        <span class="k">defer</span> <span class="n">l</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"goroutine2: 哈哈，我锁定了"</span><span class="p">)</span>
        <span class="n">ch</span> <span class="o">&lt;-</span> <span class="k">struct</span><span class="p">{}{}</span>
    <span class="p">}()</span>

    <span class="c">// 等待 goroutine 执行结束</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="o">&lt;-</span><span class="n">ch</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>注意，平时所说的锁定，其实就是去锁定互斥锁，而不是说去锁定一段代码。也就是说，当代码执行到有锁的地方时，它获取不到互斥锁的锁定，会阻塞在那里，从而达到控制同步的目的。</p><h3 id="什么是读写锁-rwmutex">什么是读写锁 RWMutex?</h3><p>那么什么是读写锁呢？它是针对读写操作的互斥锁，读写锁与互斥锁最大的不同就是可以分别对 读、写 进行锁定。一般用在大量读操作、少量写操作的情况：</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">rw</span> <span class="o">*</span><span class="n">RWMutex</span><span class="p">)</span> <span class="n">Lock</span><span class="p">()</span>
<span class="k">func</span> <span class="p">(</span><span class="n">rw</span> <span class="o">*</span><span class="n">RWMutex</span><span class="p">)</span> <span class="n">Unlock</span><span class="p">()</span>

<span class="k">func</span> <span class="p">(</span><span class="n">rw</span> <span class="o">*</span><span class="n">RWMutex</span><span class="p">)</span> <span class="n">RLock</span><span class="p">()</span>
<span class="k">func</span> <span class="p">(</span><span class="n">rw</span> <span class="o">*</span><span class="n">RWMutex</span><span class="p">)</span> <span class="n">RUnlock</span><span class="p">()</span>
</code></pre></div></div><p>由于这里需要区分读写锁定，我们这样定义：</p><ul><li>读锁定（RLock），对读操作进行锁定</li><li>读解锁（RUnlock），对读锁定进行解锁</li><li>写锁定（Lock），对写操作进行锁定</li><li>写解锁（Unlock），对写锁定进行解锁</li></ul><p>在首次使用之后，不要复制该读写锁。不要混用锁定和解锁，如：Lock 和 RUnlock、RLock 和 Unlock。因为对未读锁定的读写锁进行读解锁或对未写锁定的读写锁进行写解锁将会引起运行时错误。</p><p>如何理解读写锁呢？</p><ul><li>同时只能有一个 goroutine 能够获得写锁定。</li><li>同时可以有任意多个 gorouinte 获得读锁定。</li><li>同时只能存在写锁定或读锁定（读和写互斥）。</li></ul><p>也就是说，当有一个 goroutine 获得写锁定，其它无论是读锁定还是写锁定都将阻塞直到写解锁；当有一个 goroutine 获得读锁定，其它读锁定任然可以继续；当有一个或任意多个读锁定，写锁定将等待所有读锁定解锁之后才能够进行写锁定。所以说这里的读锁定（RLock）目的其实是告诉写锁定：有很多人正在读取数据，你给我站一边去，等它们读（读解锁）完你再来写（写锁定）。</p><p>使用例子：</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
    <span class="s">"fmt"</span>
    <span class="s">"math/rand"</span>
    <span class="s">"sync"</span>
<span class="p">)</span>

<span class="k">var</span> <span class="n">count</span> <span class="kt">int</span>
<span class="k">var</span> <span class="n">rw</span> <span class="n">sync</span><span class="o">.</span><span class="n">RWMutex</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="k">struct</span><span class="p">{},</span> <span class="m">10</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">go</span> <span class="n">read</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ch</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">go</span> <span class="n">write</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ch</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="o">&lt;-</span><span class="n">ch</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">read</span><span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">,</span> <span class="n">ch</span> <span class="k">chan</span> <span class="k">struct</span><span class="p">{})</span> <span class="p">{</span>
    <span class="n">rw</span><span class="o">.</span><span class="n">RLock</span><span class="p">()</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"goroutine %d 进入读操作...</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">:=</span> <span class="n">count</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"goroutine %d 读取结束，值为：%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="n">rw</span><span class="o">.</span><span class="n">RUnlock</span><span class="p">()</span>
    <span class="n">ch</span> <span class="o">&lt;-</span> <span class="k">struct</span><span class="p">{}{}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">write</span><span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">,</span> <span class="n">ch</span> <span class="k">chan</span> <span class="k">struct</span><span class="p">{})</span> <span class="p">{</span>
    <span class="n">rw</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"goroutine %d 进入写操作...</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">:=</span> <span class="n">rand</span><span class="o">.</span><span class="n">Intn</span><span class="p">(</span><span class="m">1000</span><span class="p">)</span>
    <span class="n">count</span> <span class="o">=</span> <span class="n">v</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"goroutine %d 写入结束，新值为：%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="n">rw</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
    <span class="n">ch</span> <span class="o">&lt;-</span> <span class="k">struct</span><span class="p">{}{}</span>
<span class="p">}</span>
</code></pre></div></div><h3 id="waitgroup-例子">WaitGroup 例子</h3><p>WaitGroup 用于等待一组 goroutine 结束，用法很简单。它有三个方法：</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">wg</span> <span class="o">*</span><span class="n">WaitGroup</span><span class="p">)</span> <span class="n">Add</span><span class="p">(</span><span class="n">delta</span> <span class="kt">int</span><span class="p">)</span>
<span class="k">func</span> <span class="p">(</span><span class="n">wg</span> <span class="o">*</span><span class="n">WaitGroup</span><span class="p">)</span> <span class="n">Done</span><span class="p">()</span>
<span class="k">func</span> <span class="p">(</span><span class="n">wg</span> <span class="o">*</span><span class="n">WaitGroup</span><span class="p">)</span> <span class="n">Wait</span><span class="p">()</span>
</code></pre></div></div><p>Add 用来添加 goroutine 的个数。Done 执行一次数量减 1。Wait 用来等待结束：</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
    <span class="s">"fmt"</span>
    <span class="s">"sync"</span>
    <span class="s">"time"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">wg</span> <span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span>

    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="c">// 计数加 1</span>
        <span class="n">wg</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
        <span class="k">go</span> <span class="k">func</span><span class="p">(</span><span class="n">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
            <span class="c">// 计数减 1</span>
            <span class="k">defer</span> <span class="n">wg</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span>
            <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Duration</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
            <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"goroutine%d 结束 </span><span class="err">\ </span><span class="s">n"</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="p">}(</span><span class="n">i</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c">// 等待执行结束</span>
    <span class="n">wg</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"所有 goroutine 执行结束"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div><p>注意，<code class="language-plaintext highlighter-rouge">wg.Add()</code> 方法一定要在 <code class="language-plaintext highlighter-rouge">goroutine</code> 开始前执行哦。</p><h3 id="cond-条件变量">Cond 条件变量</h3><p>Cond 实现一个条件变量，即等待或宣布事件发生的 goroutines 的会合点，它会保存一个通知列表。基本思想是当某中状态达成，goroutine 将会等待（Wait）在那里，当某个时刻状态改变时通过通知的方式（Broadcast，Signal）的方式通知等待的 goroutine。这样，不满足条件的 goroutine 唤醒继续向下执行，满足条件的重新进入等待序列。</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Cond</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">noCopy</span> <span class="n">noCopy</span>
  
    <span class="c">// L is held while observing or changing the condition</span>
    <span class="n">L</span> <span class="n">Locker</span>
  
    <span class="n">notify</span>  <span class="n">notifyList</span> <span class="c">// 通知列表</span>
    <span class="n">checker</span> <span class="n">copyChecker</span>
<span class="p">}</span>
</code></pre></div></div><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">NewCond</span><span class="p">(</span><span class="n">l</span> <span class="n">Locker</span><span class="p">)</span> <span class="o">*</span><span class="n">Cond</span>
<span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">Cond</span><span class="p">)</span> <span class="n">Broadcast</span><span class="p">()</span>
<span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">Cond</span><span class="p">)</span> <span class="n">Signal</span><span class="p">()</span>
<span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">Cond</span><span class="p">)</span> <span class="n">Wait</span><span class="p">()</span>
</code></pre></div></div><p>Wait 方法、Signal 方法和 Broadcast 方法。它们分别代表了等待通知、单发通知和广播通知的操作。</p><p>我们来看一下 Wait 方法：</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">Cond</span><span class="p">)</span> <span class="n">Wait</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">c</span><span class="o">.</span><span class="n">checker</span><span class="o">.</span><span class="n">check</span><span class="p">()</span>
    <span class="n">t</span> <span class="o">:=</span> <span class="n">runtime_notifyListAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">.</span><span class="n">notify</span><span class="p">)</span>
    <span class="n">c</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
    <span class="n">runtime_notifyListWait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">.</span><span class="n">notify</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">c</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div><p>它的操作为：加入到通知列表 -&gt; 解锁 L -&gt; 等待通知 -&gt; 锁定 L。其使用方法是：</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">c</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
<span class="k">for</span> <span class="o">!</span><span class="n">condition</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">c</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span>
<span class="p">}</span>
<span class="o">...</span> <span class="nb">make</span> <span class="n">use</span> <span class="n">of</span> <span class="n">condition</span> <span class="o">...</span>
<span class="n">c</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
</code></pre></div></div><p>举个例子：</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Package main provides ...</span>
<span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
    <span class="s">"fmt"</span>
    <span class="s">"sync"</span>
    <span class="s">"time"</span>
<span class="p">)</span>

<span class="k">var</span> <span class="n">count</span> <span class="kt">int</span> <span class="o">=</span> <span class="m">4</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="k">struct</span><span class="p">{},</span> <span class="m">5</span><span class="p">)</span>

    <span class="c">// 新建 cond</span>
    <span class="k">var</span> <span class="n">l</span> <span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span>
    <span class="n">cond</span> <span class="o">:=</span> <span class="n">sync</span><span class="o">.</span><span class="n">NewCond</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">go</span> <span class="k">func</span><span class="p">(</span><span class="n">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
            <span class="c">// 争抢互斥锁的锁定</span>
            <span class="n">cond</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
            <span class="k">defer</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">cond</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
                <span class="n">ch</span> <span class="o">&lt;-</span> <span class="k">struct</span><span class="p">{}{}</span>
            <span class="p">}()</span>

            <span class="c">// 条件是否达成</span>
            <span class="k">for</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="n">i</span> <span class="p">{</span>
                <span class="n">cond</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span>
                <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"收到一个通知 goroutine%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="p">}</span>
            
            <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"goroutine%d 执行结束 </span><span class="err">\ </span><span class="s">n"</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="p">}(</span><span class="n">i</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c">// 确保所有 goroutine 启动完成</span>
    <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Millisecond</span> <span class="o">*</span> <span class="m">20</span><span class="p">)</span>
    
    <span class="c">// 锁定一下</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"broadcast..."</span><span class="p">)</span>
    <span class="n">cond</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
    <span class="n">count</span> <span class="o">-=</span> <span class="m">1</span>
    <span class="n">cond</span><span class="o">.</span><span class="n">Broadcast</span><span class="p">()</span>
    <span class="n">cond</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>

    <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"signal..."</span><span class="p">)</span>
    <span class="n">cond</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
    <span class="n">count</span> <span class="o">-=</span> <span class="m">2</span>
    <span class="n">cond</span><span class="o">.</span><span class="n">Signal</span><span class="p">()</span>
    <span class="n">cond</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>

    <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"broadcast..."</span><span class="p">)</span>
    <span class="n">cond</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
    <span class="n">count</span> <span class="o">-=</span> <span class="m">1</span>
    <span class="n">cond</span><span class="o">.</span><span class="n">Broadcast</span><span class="p">()</span>
    <span class="n">cond</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="o">&lt;-</span><span class="n">ch</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><h3 id="pool-临时对象池">Pool 临时对象池</h3><p><code class="language-plaintext highlighter-rouge">sync.Pool</code> 可以作为临时对象的保存和复用的集合。其结构为：</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Pool</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">noCopy</span> <span class="n">noCopy</span>

    <span class="n">local</span>     <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span> <span class="c">// local fixed-size per-P pool, actual type is [P]poolLocal</span>
    <span class="n">localSize</span> <span class="kt">uintptr</span>        <span class="c">// size of the local array</span>

    <span class="c">// New optionally specifies a function to generate</span>
    <span class="c">// a value when Get would otherwise return nil.</span>
    <span class="c">// It may not be changed concurrently with calls to Get.</span>
    <span class="n">New</span> <span class="k">func</span><span class="p">()</span> <span class="k">interface</span><span class="p">{}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">Pool</span><span class="p">)</span> <span class="n">Get</span><span class="p">()</span> <span class="k">interface</span><span class="p">{}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">Pool</span><span class="p">)</span> <span class="n">Put</span><span class="p">(</span><span class="n">x</span> <span class="k">interface</span><span class="p">{})</span>
</code></pre></div></div><p>新键 Pool 需要提供一个 New 方法，目的是当获取不到临时对象时自动创建一个（不会主动加入到 Pool 中），Get 和 Put 方法都很好理解。</p><p>深入了解过 Go 的同学应该知道，Go 的重要组成结构为 M、P、G。Pool 实际上会为每一个操作它的 goroutine 相关联的 P 都生成一个本地池。如果从本地池 Get 对象的时候，本地池没有，则会从其它的 P 本地池获取。因此，Pool 的一个特点就是：可以把由其中的对象值产生的存储压力进行分摊。</p><p>它有着以下特点：</p><ul><li>Pool 中的对象在仅有 Pool 有着唯一索引的情况下可能会被自动删除（取决于下一次 GC 执行的时间）。</li><li>goroutines 协程安全，可以同时被多个协程使用。</li></ul><blockquote><p>GC 的执行一般会使 Pool 中的对象全部移除。</p></blockquote><p>那么 Pool 都适用于什么场景呢？从它的特点来说，适用与无状态的对象的复用，而不适用与如连接池之类的。在 fmt 包中有一个很好的使用池的例子，它维护一个动态大小的临时输出缓冲区。</p><p>官方例子：</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
    <span class="s">"bytes"</span>
    <span class="s">"io"</span>
    <span class="s">"os"</span>
    <span class="s">"sync"</span>
    <span class="s">"time"</span>
<span class="p">)</span>

<span class="k">var</span> <span class="n">bufPool</span> <span class="o">=</span> <span class="n">sync</span><span class="o">.</span><span class="n">Pool</span><span class="p">{</span>
    <span class="n">New</span><span class="o">:</span> <span class="k">func</span><span class="p">()</span> <span class="k">interface</span><span class="p">{}</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">new</span><span class="p">(</span><span class="n">bytes</span><span class="o">.</span><span class="n">Buffer</span><span class="p">)</span>
    <span class="p">},</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">timeNow</span><span class="p">()</span> <span class="n">time</span><span class="o">.</span><span class="n">Time</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">time</span><span class="o">.</span><span class="n">Unix</span><span class="p">(</span><span class="m">1136214245</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Log</span><span class="p">(</span><span class="n">w</span> <span class="n">io</span><span class="o">.</span><span class="n">Writer</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">// 获取临时对象，没有的话会自动创建</span>
    <span class="n">b</span> <span class="o">:=</span> <span class="n">bufPool</span><span class="o">.</span><span class="n">Get</span><span class="p">()</span><span class="o">.</span><span class="p">(</span><span class="o">*</span><span class="n">bytes</span><span class="o">.</span><span class="n">Buffer</span><span class="p">)</span>
    <span class="n">b</span><span class="o">.</span><span class="n">Reset</span><span class="p">()</span>
    <span class="n">b</span><span class="o">.</span><span class="n">WriteString</span><span class="p">(</span><span class="n">timeNow</span><span class="p">()</span><span class="o">.</span><span class="n">UTC</span><span class="p">()</span><span class="o">.</span><span class="n">Format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">RFC3339</span><span class="p">))</span>
    <span class="n">b</span><span class="o">.</span><span class="n">WriteByte</span><span class="p">(</span><span class="sc">' '</span><span class="p">)</span>
    <span class="n">b</span><span class="o">.</span><span class="n">WriteString</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="n">b</span><span class="o">.</span><span class="n">WriteByte</span><span class="p">(</span><span class="sc">'='</span><span class="p">)</span>
    <span class="n">b</span><span class="o">.</span><span class="n">WriteString</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
    <span class="n">w</span><span class="o">.</span><span class="n">Write</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">Bytes</span><span class="p">())</span>
    <span class="c">// 将临时对象放回到 Pool 中</span>
    <span class="n">bufPool</span><span class="o">.</span><span class="n">Put</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Log</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">Stdout</span><span class="p">,</span> <span class="s">"path"</span><span class="p">,</span> <span class="s">"/search?q=flowers"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div><p>打印结果：<br /> <code class="language-plaintext highlighter-rouge">2006-01-02T15:04:05Z path=/search?q=flowers</code></p><h3 id="once-执行一次">Once 执行一次</h3><p>使用 sync.Once 对象可以使得函数多次调用只执行一次。其结构为：</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Once</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">m</span>    <span class="n">Mutex</span>
    <span class="n">done</span> <span class="kt">uint32</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">o</span> <span class="o">*</span><span class="n">Once</span><span class="p">)</span> <span class="n">Do</span><span class="p">(</span><span class="n">f</span> <span class="k">func</span><span class="p">())</span>
</code></pre></div></div><p>用 done 来记录执行次数，用 m 来保证保证仅被执行一次。只有一个 Do 方法，调用执行。</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
    <span class="s">"fmt"</span>
    <span class="s">"sync"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">once</span> <span class="n">sync</span><span class="o">.</span><span class="n">Once</span>
    <span class="n">onceBody</span> <span class="o">:=</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Only once"</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">done</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">bool</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">once</span><span class="o">.</span><span class="n">Do</span><span class="p">(</span><span class="n">onceBody</span><span class="p">)</span>
            <span class="n">done</span> <span class="o">&lt;-</span> <span class="no">true</span>
        <span class="p">}()</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="o">&lt;-</span><span class="n">done</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>打印结果：<br /> <code class="language-plaintext highlighter-rouge">Only once</code></p><h2 id="content-包">content 包</h2><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="https://lewinzheng.com" target="_blank">Lewin</a></li><li>本文链接：<a href="https://lewinzheng.com/2021/06/24/golang-basic-package/" target="_blank">https://lewinzheng.com/2021/06/24/golang-basic-package/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名</li></ul></div></article><div class="share"><div class="share-component" data-disabled='qq,weibo,qzone'></div></div><div class="comment"><div id="gitalk-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/vendor/gitalk/gitalk.css"> <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> <script> var gitalk = new Gitalk({ id: '/2021/06/24/golang-basic-package/', clientID: '831a35f6d4f6fc049209', clientSecret: '6e80f9a3e9b50b498553e32179ad3adbd893ab7e', repo: 'blog-comments', owner: 'Lewinz', admin: ['Lewinz'], labels: ['gitment'], perPage: 50, }); gitalk.render('gitalk-container'); </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@built/assets/search_data.json?v=1653837067', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"> <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-7093222719567591" data-ad-slot="5263168187" data-ad-format="auto" data-full-width-responsive="true"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2021 <span title="Lewin">Lewin</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/Lewinz/lewinz.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://lewinzheng.com/" title="首页" target="">首页</a></li><li> <a href="https://lewinzheng.com/categories/" title="分类" target="">分类</a></li><li> <a href="https://lewinzheng.com/wiki/" title="维基" target="">维基</a></li><li> <a href="https://lewinzheng.com/links/" title="链接" target="">链接</a></li><li> <a href="https://lewinzheng.com/about/" title="关于" target="">关于</a></li><li><a href="https://lewinzheng.com/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul><script async src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/vendor/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="mobile-hidden" style="margin-top:8px"> <span id="busuanzi_container_site_pv" style="display:none"> 本站访问量<span id="busuanzi_value_site_pv"></span>次 </span> <span id="busuanzi_container_site_uv" style="display:none"> / 本站访客数<span id="busuanzi_value_site_uv"></span>人 </span> <span id="busuanzi_container_page_pv" style="display:none"> / 本页访问量<span id="busuanzi_value_page_pv"></span>次 / 统计始于2021-04-21 </span></div></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/vendor/share.js/dist/js/share.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script><div style="display:none"> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-80669434-1', 'auto'); ga('send', 'pageview'); </script></div></body></html>
