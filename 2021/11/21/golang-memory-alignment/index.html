<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>golang 中的内存对齐和 unsafe 初探 &mdash; 阿嫂</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/rouge-themes@master/dist/github.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/vendor/share.js/dist/css/share.min.css"><link rel="canonical" href="https://lewinzheng.com/2021/11/21/golang-memory-alignment/"><link rel="alternate" type="application/atom+xml" title="阿嫂" href="https://lewinzheng.com/feed.xml"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/favicon.ico"><meta property="og:title" content="golang 中的内存对齐和 unsafe 初探"><meta name="keywords" content="memory alignment, unsafe"><meta name="og:keywords" content="memory alignment, unsafe"><meta name="description" content="unsafe 包简单说明unsafe，顾名思义，是不安全的，Go 定义这个包名也是这个意思，让我们尽可能的不要使用它，如果你使用它，看到了这个名字，也会想到尽可能的不要使用它，或者更小心的使用它。 使用 unsafe 包的同时也放弃了 Go 语言保证与未来版本的兼容性的承诺，因为它必然会有意无意中使用很多非公开的实现细节，而这些实现的细节在未来的 Go 语言中很可能会被改变。unsafe 包被广泛地用于比较低级的包，例如 runtime、os、syscall 还有 net 包等，因为它们需要和操作系统密切配合，但是对于普通的程序一般是不需要使用 unsafe 包的。"><meta name="og:description" content="unsafe 包简单说明unsafe，顾名思义，是不安全的，Go 定义这个包名也是这个意思，让我们尽可能的不要使用它，如果你使用它，看到了这个名字，也会想到尽可能的不要使用它，或者更小心的使用它。 使用 unsafe 包的同时也放弃了 Go 语言保证与未来版本的兼容性的承诺，因为它必然会有意无意中使用很多非公开的实现细节，而这些实现的细节在未来的 Go 语言中很可能会被改变。unsafe 包被广泛地用于比较低级的包，例如 runtime、os、syscall 还有 net 包等，因为它们需要和操作系统密切配合，但是对于普通的程序一般是不需要使用 unsafe 包的。"><meta property="og:url" content="https://lewinzheng.com/2021/11/21/golang-memory-alignment/"><meta property="og:site_name" content="阿嫂"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2021-11-21"> <script src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/js/main.js"></script> <script data-ad-client="ca-pub-7093222719567591" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://lewinzheng.com/" title="阿嫂"><span class="octicon octicon-mark-github"></span> 阿嫂</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://lewinzheng.com/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="https://lewinzheng.com/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="https://lewinzheng.com/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="https://lewinzheng.com/links/" class=" site-header-nav-item" target="" title="链接">链接</a> <a href="https://lewinzheng.com/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="golang 中的内存对齐和 "><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">golang 中的内存对齐和 unsafe 初探</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2021/11/21 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://lewinzheng.com/categories/#memory alignment" title="memory alignment">memory alignment</a> </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://lewinzheng.com/categories/#unsafe" title="unsafe">unsafe</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 6541 字，约 19 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" > <ins class="adsbygoogle content-header-ad" data-ad-client="ca-pub-7093222719567591" data-ad-slot="1650902835"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script> <br /><article class="article-content markdown-body"><h2 id="unsafe-包简单说明">unsafe 包简单说明</h2><p>unsafe，顾名思义，是不安全的，Go 定义这个包名也是这个意思，让我们尽可能的不要使用它，如果你使用它，看到了这个名字，也会想到尽可能的不要使用它，或者更小心的使用它。</p><blockquote><p>使用 unsafe 包的同时也放弃了 Go 语言保证与未来版本的兼容性的承诺，因为它必然会有意无意中使用很多非公开的实现细节，而这些实现的细节在未来的 Go 语言中很可能会被改变。 unsafe 包被广泛地用于比较低级的包，例如 runtime、os、syscall 还有 net 包等，因为它们需要和操作系统密切配合，但是对于普通的程序一般是不需要使用 unsafe 包的。</p></blockquote><p>虽然这个包不安全，但是它也有它的优势，那就是可以绕过 Go 的内存安全机制，直接对内存进行读写，所以有时候因为性能的需要，会冒一些风险使用该包，对内存进行操作。</p><h3 id="unsafesizeof-函数">unsafe.Sizeof 函数</h3><p>Sizeof 函数返回操作数在内存中的字节大小（返回该类型所占用的内存大小），参数可以是任意类型的表达式，但是它并不会对表达式进行求值。</p><p>一个 Sizeof 函数调用是一个对应 uintptr 类型的常量表达式，因此返回的结果可以用作数组类型的长度大小，或者用作计算其他的常量。</p><p>Sizeof 函数可以返回一个类型所占用的内存大小，这个大小只有类型有关，和类型对应的变量存储的内容大小无关，比如 bool 型占用一个字节、int8 也占用一个字节。</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="s">"unsafe"</span>
 

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="s">"true"</span><span class="p">))</span>                <span class="c">// 16</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="no">true</span><span class="p">))</span>                  <span class="c">// 1</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="kt">int8</span><span class="p">(</span><span class="m">0</span><span class="p">)))</span>               <span class="c">// 1</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="kt">int16</span><span class="p">(</span><span class="m">10</span><span class="p">)))</span>             <span class="c">// 2</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="kt">int32</span><span class="p">(</span><span class="m">10000000</span><span class="p">)))</span>       <span class="c">// 4</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="kt">int64</span><span class="p">(</span><span class="m">10000000000000</span><span class="p">)))</span> <span class="c">// 8</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="m">1</span><span class="p">)))</span>                <span class="c">// 8</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="kt">float64</span><span class="p">(</span><span class="m">0</span><span class="p">)))</span>            <span class="c">// 8</span>
<span class="p">}</span>
</code></pre></div></div><p>对于整型来说，占用的字节数意味着这个类型存储数字范围的大小，比如 int8 占用一个字节，也就是 8bit，所以它可以存储的大小范围是 - 128~~127, 也就是−2^(n-1) 到 2^(n-1)−1，n 表示 bit，int8 表示 8bit，int16 表示 16bit，其他以此类推。</p><p>对于和平台有关的 int 类型，这个要看平台是 32 位还是 64 位，会取最大的。比如我自己测试，以上输出，会发现 int 和 int64 的大小是一样的，因为我的是 64 位平台的电脑。</p><p><code class="language-plaintext highlighter-rouge">func Sizeof(x ArbitraryType) uintptr</code></p><p>以上是 Sizeof 的函数定义，它接收一个 ArbitraryType 类型的参数，返回一个 uintptr 类型的值。这里的 ArbitraryType 不用关心，他只是一个占位符，为了文档的考虑导出了该类型，但是一般不会使用它，我们只需要知道它表示任何类型，也就是我们这个函数可以接收任意类型的数据。</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// ArbitraryType is here for the purposes of documentation only and is not actually</span>
<span class="c">// part of the unsafe package. It represents the type of an arbitrary Go expression.</span>
<span class="k">type</span> <span class="n">ArbitraryType</span> <span class="kt">int</span>
</code></pre></div></div><h3 id="alignof-函数">Alignof 函数</h3><p>Alignof 返回一个类型的对齐值，也可以叫做对齐系数或者对齐倍数。对齐值是一个和内存对齐有关的值，合理的内存对齐可以提高内存读写的性能。</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">var</span> <span class="n">b</span> <span class="kt">bool</span>
	<span class="k">var</span> <span class="n">i8</span> <span class="kt">int8</span>
	<span class="k">var</span> <span class="n">i16</span> <span class="kt">int16</span>
	<span class="k">var</span> <span class="n">i64</span> <span class="kt">int64</span>

	<span class="k">var</span> <span class="n">f32</span> <span class="kt">float32</span>

	<span class="k">var</span> <span class="n">s</span> <span class="kt">string</span>

	<span class="k">var</span> <span class="n">m</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span>

	<span class="k">var</span> <span class="n">p</span> <span class="o">*</span><span class="kt">int32</span>

	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Alignof</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>   <span class="c">// 1</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Alignof</span><span class="p">(</span><span class="n">i8</span><span class="p">))</span>  <span class="c">// 1</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Alignof</span><span class="p">(</span><span class="n">i16</span><span class="p">))</span> <span class="c">// 2</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Alignof</span><span class="p">(</span><span class="n">i64</span><span class="p">))</span> <span class="c">// 8</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Alignof</span><span class="p">(</span><span class="n">f32</span><span class="p">))</span> <span class="c">// 4</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Alignof</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>   <span class="c">// 8</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Alignof</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>   <span class="c">// 8</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Alignof</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>   <span class="c">// 8</span>
<span class="p">}</span>
</code></pre></div></div><p>从以上例子的输出，可以看到，对齐值一般是 2^n, 最大不会超过 8（原因见下面的内存对齐规则）。Alignof 的函数定义和 Sizeof 基本上一样。这里需要注意的是每个人的电脑运行的结果可能不一样，大同小异。</p><p><code class="language-plaintext highlighter-rouge">func Alignof(x ArbitraryType) uintptr</code></p><p>获取对齐值还可以使用反射包的函数，也就是说：unsafe.Alignof (x) 等价于 reflect.TypeOf (x).Align ()。</p><h3 id="offsetof-函数">Offsetof 函数</h3><p>Offsetof 函数只适用于 struct 结构体中的字段相对于结构体的内存位置偏移量。结构体的第一个字段的偏移量都是 0。</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">u1</span> <span class="n">user1</span>

	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Offsetof</span><span class="p">(</span><span class="n">u1</span><span class="o">.</span><span class="n">b</span><span class="p">))</span> <span class="c">// 0</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Offsetof</span><span class="p">(</span><span class="n">u1</span><span class="o">.</span><span class="n">i</span><span class="p">))</span> <span class="c">// 4</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Offsetof</span><span class="p">(</span><span class="n">u1</span><span class="o">.</span><span class="n">j</span><span class="p">))</span> <span class="c">// 8</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="n">u1</span><span class="p">))</span>     <span class="c">// 16</span>

<span class="p">}</span>


<span class="k">type</span> <span class="n">user1</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">b</span> <span class="kt">byte</span>
	<span class="n">i</span> <span class="kt">int32</span>
	<span class="n">j</span> <span class="kt">int64</span>
<span class="p">}</span>
</code></pre></div></div><p>字段的偏移量，就是该字段在 struct 结构体内存布局中的起始位置 (内存位置索引从 0 开始)。</p><p>根据字段的偏移量，我们可以定位结构体的字段，进而可以读写该结构体的字段，哪怕他们是私有的。这里可以直接用汇编获取对应偏移量的字段值。</p><p>同样也可以用反射表示：</p><p><code class="language-plaintext highlighter-rouge">unsafe.Offsetof (u1.i)</code> 等价于 <code class="language-plaintext highlighter-rouge">reflect.TypeOf (u1).Field (i).Offset</code></p><h3 id="struct-字段顺序不同最终大小可能不同">struct 字段顺序不同，最终大小可能不同</h3><p>首先来看个栗子：</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Part1</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">a</span> <span class="kt">bool</span>
    <span class="n">b</span> <span class="kt">int32</span>
    <span class="n">c</span> <span class="kt">int8</span>
    <span class="n">d</span> <span class="kt">int64</span>
    <span class="n">e</span> <span class="kt">byte</span>
<span class="p">}</span>
</code></pre></div></div><p>来看一下 Part1 共占用的大小是多少呢？</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"bool size: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="kt">bool</span><span class="p">(</span><span class="no">true</span><span class="p">)))</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"int32 size: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="kt">int32</span><span class="p">(</span><span class="m">0</span><span class="p">)))</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"int8 size: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="kt">int8</span><span class="p">(</span><span class="m">0</span><span class="p">)))</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"int64 size: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="kt">int64</span><span class="p">(</span><span class="m">0</span><span class="p">)))</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"byte size: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="kt">byte</span><span class="p">(</span><span class="m">0</span><span class="p">)))</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"string size: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="s">"EDDYCJY"</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div><p>结果如下：</p><div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bool size: 1
int32 size: 4
int8 size: 1
int64 size: 8
byte size: 1
string size: 16
</code></pre></div></div><p>然后你也许就会得出这个结果：</p><p>Part1 这一个结构体的占用内存大小为 1+4+1+8+1 = 15 个字节。相信有的小伙伴是这么算的，看上去也没什么毛病</p><p>但是实际答案却是：</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Part1</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">a</span> <span class="kt">bool</span>
    <span class="n">b</span> <span class="kt">int32</span>
    <span class="n">c</span> <span class="kt">int8</span>
    <span class="n">d</span> <span class="kt">int64</span>
    <span class="n">e</span> <span class="kt">byte</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">part1</span> <span class="o">:=</span> <span class="n">Part1</span><span class="p">{}</span>

    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"part1 size: %d, align: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="n">part1</span><span class="p">),</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Alignof</span><span class="p">(</span><span class="n">part1</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div><p>输出结果：</p><div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>part1 size: 32, align: 8
</code></pre></div></div><p>最终输出为占用 32 个字节。这与前面所预期的结果完全不一样。这充分地说明了先前的计算方式是错误的。</p><p>为什么呢？</p><p>在这里要提到 “内存对齐” 这一概念，才能够用正确的姿势去计算，接下来我们详细的讲讲它是什么</p><h2 id="内存对齐">内存对齐</h2><p>有的小伙伴可能会认为内存读取，就是一个简单的字节数组摆放</p><p><img src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/golang-memory-alignment_1.png" alt="golang-memory-alignment_1" /></p><p>上图表示一个坑一个萝卜的内存读取方式。但实际上 CPU 并不会以一个一个字节去读取和写入内存。</p><h3 id="敲重点啦">敲重点啦：</h3><p>相反 CPU 读取内存是一块一块读取的，块的大小可以为 2、4、6、8、16 字节等大小。块大小我们称其为内存访问粒度。如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/golang-memory-alignment_2.png" alt="golang-memory-alignment_2" /></p><p>在样例中，假设访问粒度为 4。 CPU 是以每 4 个字节大小的访问粒度去读取和写入内存的。这才是正确的姿势</p><h3 id="为什么要关心对齐">为什么要关心对齐？</h3><ul><li>你正在编写的代码在性能（CPU、Memory）方面有一定的要求</li><li>你正在处理向量方面的指令</li><li>某些硬件平台（ARM）体系不支持未对齐的内存访问</li></ul><h3 id="为什么要做对齐">为什么要做对齐</h3><ul><li><p>平台（移植性）原因：不是所有的硬件平台都能够访问任意地址上的任意数据。例如：特定的硬件平台只允许在特定地址获取特定类型的数据，否则会导致异常情况</p></li><li><p>性能原因：若访问未对齐的内存，将会导致 CPU 进行两次内存访问，并且要花费额外的时钟周期来处理对齐及运算。而本身就对齐的内存仅需要一次访问就可以完成读取动作</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/images/posts/golang-memory-alignment_3.png" alt="golang-memory-alignment_3" /></p><p>在上图中，假设从 Index 1 开始读取，将会出现很崩溃的问题。因为它的内存访问边界是不对齐的。因此 CPU 会做一些额外的处理工作。如下：</p><ul><li>CPU 首次读取未对齐地址的第一个内存块，读取 0-3 字节。并移除不需要的字节 0</li><li>CPU 再次读取未对齐地址的第二个内存块，读取 4-7 字节。并移除不需要的字节 5、6、7 字节</li><li>合并 1-4 字节的数据</li><li>合并后放入寄存器</li></ul><p>从上述流程可得出，不做 “内存对齐” 是一件有点 “麻烦” 的事。因为它会增加许多耗费时间的动作</p><p>而假设做了内存对齐，从 Index 0 开始读取 4 个字节，只需要读取一次，也不需要额外的运算。</p><h3 id="这显然高效很多是标准的空间换时间做法">这显然高效很多，是标准的空间换时间做法</h3><h4 id="默认对齐系数">默认对齐系数</h4><p>在不同平台上的编译器都有自己默认的 “对齐系数”，可通过预编译命令 #pragma pack (n) 进行变更，n 就是代指 “对齐系数”。一般来讲，我们常用的平台的系数如下：</p><ul><li>32 位：4</li><li>64 位：8</li></ul><p>另外要注意，不同硬件平台占用的大小和对齐值都可能是不一样的。因此本文的值不是唯一的，调试的时候需按本机的实际情况考虑</p><h4 id="成员对齐">成员对齐</h4><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"bool align: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Alignof</span><span class="p">(</span><span class="kt">bool</span><span class="p">(</span><span class="no">true</span><span class="p">)))</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"int32 align: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Alignof</span><span class="p">(</span><span class="kt">int32</span><span class="p">(</span><span class="m">0</span><span class="p">)))</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"int8 align: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Alignof</span><span class="p">(</span><span class="kt">int8</span><span class="p">(</span><span class="m">0</span><span class="p">)))</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"int64 align: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Alignof</span><span class="p">(</span><span class="kt">int64</span><span class="p">(</span><span class="m">0</span><span class="p">)))</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"byte align: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Alignof</span><span class="p">(</span><span class="kt">byte</span><span class="p">(</span><span class="m">0</span><span class="p">)))</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"string align: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Alignof</span><span class="p">(</span><span class="s">"EDDYCJY"</span><span class="p">))</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"map align: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Alignof</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">{}))</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">align</span><span class="o">:</span> <span class="m">1</span>
<span class="kt">int32</span> <span class="n">align</span><span class="o">:</span> <span class="m">4</span>
<span class="kt">int8</span> <span class="n">align</span><span class="o">:</span> <span class="m">1</span>
<span class="kt">int64</span> <span class="n">align</span><span class="o">:</span> <span class="m">8</span>
<span class="kt">byte</span> <span class="n">align</span><span class="o">:</span> <span class="m">1</span>
<span class="kt">string</span> <span class="n">align</span><span class="o">:</span> <span class="m">8</span>
<span class="k">map</span> <span class="n">align</span><span class="o">:</span> <span class="m">8</span>
</code></pre></div></div><p>关于 unsafe.Alignof 是用来来返回相应类型的对齐系数，上面已经说了。</p><p>通过观察输出结果，可得知基本都是 2^n，最大也不会超过 8。这是因为我本机（64 位）编译器默认对齐系数是 8，因此最大值不会超过这个数</p><h3 id="整体对齐-结构体本身也要对齐">整体对齐 （结构体本身也要对齐）</h3><p>上面提到了结构体中的成员变量要做字节对齐。那么想当然身为最终结果的结构体，也是需要做字节对齐的</p><h4 id="对齐规则">对齐规则</h4><p>结构体的成员变量，第一个成员变量的偏移量为 0。往后的每个成员变量的对齐值必须为编译器默认对齐长度（#pragma pack (n)）或当前成员变量类型的长度（unsafe.Sizeof），取最小值作为当前类型的对齐值。其偏移量必须为对齐值的整数倍</p><p>结构体本身，对齐值必须为编译器默认对齐长度（#pragma pack (n)）或结构体的所有成员变量类型中的最大长度，取最大数的最小整数倍作为对齐值</p><p>结合以上两点，可得知若编译器默认对齐长度（#pragma pack (n)）超过结构体内成员变量的类型最大长度时，默认对齐长度是没有任何意义的</p><p>换个说法就是：</p><p>对于具体类型来说，对齐值 = min (编译器默认对齐值，类型大小 Sizeof 长度)。也就是在默认设置的对齐值和类型的内存占用大小之间，取最小值为该类型的对齐值。我的电脑默认是 8，所以最大值不会超过 8.</p><p>struct 在每个字段都内存对齐之后，其本身也要进行对齐，对齐值 = min (默认对齐值，字段最大类型长度)。这条也很好理解，struct 的所有字段中，最大的那个类型的长度以及默认对齐值之间，取最小的那个。</p><h4 id="分析流程">分析流程</h4><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Part1</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">a</span> <span class="kt">bool</span>
    <span class="n">b</span> <span class="kt">int32</span>
    <span class="n">c</span> <span class="kt">int8</span>
    <span class="n">d</span> <span class="kt">int64</span>
    <span class="n">e</span> <span class="kt">byte</span>
<span class="p">}</span>
</code></pre></div></div><table><thead><tr><th>成员变量</th><th>类型</th><th>偏移量</th><th>自身占用</th></tr></thead><tbody><tr><td>a</td><td>bool</td><td>0</td><td>1</td></tr><tr><td>字节对齐</td><td>无</td><td>1</td><td>3</td></tr><tr><td>b</td><td>int32</td><td>4</td><td>4</td></tr><tr><td>c</td><td>int8</td><td>8</td><td>1</td></tr><tr><td>字节对齐</td><td>无</td><td>9</td><td>7</td></tr><tr><td>d</td><td>int64</td><td>16</td><td>8</td></tr><tr><td>e</td><td>byte</td><td>24</td><td>1</td></tr><tr><td>字节对齐</td><td>无</td><td>25</td><td>7</td></tr><tr><td>总占用大小</td><td>-</td><td>- 32</td><td> </td></tr></tbody></table><h4 id="成员对齐-1">成员对齐：</h4><ul><li>第一个成员 a<ul><li>类型为 bool</li><li>对齐值为 1 字节</li><li>初始地址，偏移量为 0。占用了第 1 位</li></ul></li><li>第二个成员 b<ul><li>类型为 int32</li><li>大小 / 对齐值为 4 字节</li><li><table><tbody><tr><td>根据规则 1，其偏移量必须为 4 的整数倍。确定偏移量为 4，因此 2-4 位为 Padding。而当前数值从第 5 位开始填充，到第 8 位。如下：axxx</td><td>bbbb</td></tr></tbody></table></li></ul></li><li>第三个成员 c<ul><li>类型为 int8</li><li>大小 / 对齐值为 1 字节</li><li><table><tbody><tr><td>根据规则 1，其偏移量必须为 1 的整数倍。当前偏移量为 8。不需要额外对齐，填充 1 个字节到第 9 位。如下：axxx</td><td>bbbb</td><td>c…</td></tr></tbody></table></li></ul></li><li>第四个成员 d<ul><li>类型为 int64</li><li>大小 / 对齐值为 8 字节</li><li><table><tbody><tr><td>根据规则 1，其偏移量必须为 8 的整数倍。确定偏移量为 16，因此 9-16 位为 Padding。而当前数值从第 17 位开始写入，到第 24 位。如下：axxx</td><td>bbbb</td><td>cxxx</td><td>xxxx</td><td>dddd</td><td>dddd</td></tr></tbody></table></li></ul></li><li>第五个成员 e<ul><li>类型为 byte</li><li>大小 / 对齐值为 1 字节</li><li><table><tbody><tr><td>根据规则 1，其偏移量必须为 1 的整数倍。当前偏移量为 24。不需要额外对齐，填充 1 个字节到第 25 位。如下：axxx</td><td>bbbb</td><td>cxxx</td><td>xxxx</td><td>dddd</td><td>dddd</td><td>e…</td></tr></tbody></table></li></ul></li></ul><h4 id="整体对齐">整体对齐：</h4><p>在每个成员变量进行对齐后，根据规则 2，整个结构体本身也要进行字节对齐，因为可发现它可能并不是 2^n，不是偶数倍。显然不符合对齐的规则</p><p>根据规则 2，可得出对齐值为 8。现在的偏移量为 25，不是 8 的整倍数。因此确定偏移量为 32。对结构体进行对齐</p><p>结果： Part1 内存布局：<code class="language-plaintext highlighter-rouge">axxx|bbbb|cxxx|xxxx|dddd|dddd|exxx|xxxx</code></p><p>其中 xxx 表示为 “内存空洞”</p><h4 id="推论字段顺序可改变结构体大小">推论字段顺序可改变结构体大小</h4><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Part1</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">a</span> <span class="kt">bool</span>
    <span class="n">b</span> <span class="kt">int32</span>
    <span class="n">c</span> <span class="kt">int8</span>
    <span class="n">d</span> <span class="kt">int64</span>
    <span class="n">e</span> <span class="kt">byte</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Part2</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">e</span> <span class="kt">byte</span>
    <span class="n">c</span> <span class="kt">int8</span>
    <span class="n">a</span> <span class="kt">bool</span>
    <span class="n">b</span> <span class="kt">int32</span>
    <span class="n">d</span> <span class="kt">int64</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">part1</span> <span class="o">:=</span> <span class="n">Part1</span><span class="p">{}</span>
    <span class="n">part2</span> <span class="o">:=</span> <span class="n">Part2</span><span class="p">{}</span>

    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"part1 size: %d, align: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="n">part1</span><span class="p">),</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Alignof</span><span class="p">(</span><span class="n">part1</span><span class="p">))</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"part2 size: %d, align: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="n">part2</span><span class="p">),</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Alignof</span><span class="p">(</span><span class="n">part2</span><span class="p">))</span>
<span class="p">}</span>


<span class="n">part1</span> <span class="n">size</span><span class="o">:</span> <span class="m">32</span><span class="p">,</span> <span class="n">align</span><span class="o">:</span> <span class="m">8</span>
<span class="n">part2</span> <span class="n">size</span><span class="o">:</span> <span class="m">16</span><span class="p">,</span> <span class="n">align</span><span class="o">:</span> <span class="m">8</span>
</code></pre></div></div><p>分析过程和上面完全一样。</p><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="https://lewinzheng.com" target="_blank">Lewin</a></li><li>本文链接：<a href="https://lewinzheng.com/2021/11/21/golang-memory-alignment/" target="_blank">https://lewinzheng.com/2021/11/21/golang-memory-alignment/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名</li></ul></div></article><div class="share"><div class="share-component" data-disabled='qq,weibo,qzone'></div></div><div class="comment"><div id="gitalk-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/vendor/gitalk/gitalk.css"> <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> <script> var gitalk = new Gitalk({ id: '/2021/11/21/golang-memory-alignment/', clientID: '831a35f6d4f6fc049209', clientSecret: '6e80f9a3e9b50b498553e32179ad3adbd893ab7e', repo: 'blog-comments', owner: 'Lewinz', admin: ['Lewinz'], labels: ['gitment'], perPage: 50, }); gitalk.render('gitalk-container'); </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@built/assets/search_data.json?v=1653837068', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"> <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-7093222719567591" data-ad-slot="5263168187" data-ad-format="auto" data-full-width-responsive="true"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2021 <span title="Lewin">Lewin</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/Lewinz/lewinz.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://lewinzheng.com/" title="首页" target="">首页</a></li><li> <a href="https://lewinzheng.com/categories/" title="分类" target="">分类</a></li><li> <a href="https://lewinzheng.com/wiki/" title="维基" target="">维基</a></li><li> <a href="https://lewinzheng.com/links/" title="链接" target="">链接</a></li><li> <a href="https://lewinzheng.com/about/" title="关于" target="">关于</a></li><li><a href="https://lewinzheng.com/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul><script async src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/vendor/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="mobile-hidden" style="margin-top:8px"> <span id="busuanzi_container_site_pv" style="display:none"> 本站访问量<span id="busuanzi_value_site_pv"></span>次 </span> <span id="busuanzi_container_site_uv" style="display:none"> / 本站访客数<span id="busuanzi_value_site_uv"></span>人 </span> <span id="busuanzi_container_page_pv" style="display:none"> / 本页访问量<span id="busuanzi_value_page_pv"></span>次 / 统计始于2021-04-21 </span></div></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/vendor/share.js/dist/js/share.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script><div style="display:none"> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-80669434-1', 'auto'); ga('send', 'pageview'); </script></div></body></html>
