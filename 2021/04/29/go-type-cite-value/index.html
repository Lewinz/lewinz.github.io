<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>golang 中的值类型和引用类型 &mdash; 阿嫂</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/rouge-themes@master/dist/github.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/vendor/share.js/dist/css/share.min.css"><link rel="canonical" href="https://lewinz.org/2021/04/29/go-type-cite-value/"><link rel="alternate" type="application/atom+xml" title="阿嫂" href="https://lewinz.org/feed.xml"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/favicon.ico"><meta property="og:title" content="golang 中的值类型和引用类型"><meta name="keywords" content="go,值类型,引用类型"><meta name="og:keywords" content="go,值类型,引用类型"><meta name="description" content="值类型和引用类型"><meta name="og:description" content="值类型和引用类型"><meta property="og:url" content="https://lewinz.org/2021/04/29/go-type-cite-value/"><meta property="og:site_name" content="阿嫂"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2021-04-29"> <script src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/js/main.js"></script> <script data-ad-client="ca-pub-7093222719567591" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://lewinz.org/" title="阿嫂"><span class="octicon octicon-mark-github"></span> 阿嫂</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://lewinz.org/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="https://lewinz.org/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="https://lewinz.org/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="https://lewinz.org/links/" class=" site-header-nav-item" target="" title="链接">链接</a> <a href="https://lewinz.org/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="golang 中的值类型和引用"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">golang 中的值类型和引用类型</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2021/04/29 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://lewinz.org/categories/#go" title="go">go</a> </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://lewinz.org/categories/#值类型" title="值类型">值类型</a> </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://lewinz.org/categories/#引用类型" title="引用类型">引用类型</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 4968 字，约 15 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" > <ins class="adsbygoogle content-header-ad" data-ad-client="ca-pub-7093222719567591" data-ad-slot="1650902835"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script> <br /><article class="article-content markdown-body"><h2 id="值类型和引用类型">值类型和引用类型</h2><p>值类型：<strong>int</strong>、<strong>float</strong>、<strong>bool</strong>和<strong>string</strong>这些类型都属于值类型</p><p>使用这些类型的变量直接指向存在内存中的值，值类型的变量的值存储在栈中。当使用等号=将一个变量的值赋给另一个变量时，如 j = i ,实际上是在内存中将 i 的值进行了拷贝。可以通过 &amp;i 获取变量 i 的内存地址。值拷贝</p><p>引用类型：特指<strong>slice</strong>、<strong>map</strong>、<strong>channel</strong>这三种预定义类型。</p><p>引用类型拥有更复杂的存储结构:<br /> (1) 分配内存 <br /> (2) 初始化一系列属性等一个引用类型的变量 r1 存储的是 r1 的值所在的内存地址（数字），或内存地址中第一个字所在的位置，这个内存地址被称之为指针，这个指针实际上也被存在另外的某一个字中。  </p><p>两者的主要区别：拷贝操作和函数传参。</p><h2 id="数组-array-和切片-slice-的实例">数组 array 和切片 slice 的实例：</h2><p>定义了一个数组 a，它是值类型，复制给 b 是 copy，当 b 发生变化后 a 并不会发生任何变化，程序的执行结果如下所示：</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">//由 main 函数作为程序入口点启动</span>
<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">a</span> <span class="o">:=</span><span class="p">[</span><span class="m">5</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="m">3</span><span class="p">,</span><span class="m">4</span><span class="p">,</span><span class="m">5</span><span class="p">}</span>
	<span class="n">b</span> <span class="o">:=</span> <span class="n">a</span>
	<span class="n">b</span><span class="p">[</span><span class="m">2</span><span class="p">]</span> <span class="o">=</span> <span class="m">8</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div><p>切片则不然，如下代码所示：</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">//由 main 函数作为程序入口点启动</span>
<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">a</span> <span class="o">:=</span><span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="m">3</span><span class="p">,</span><span class="m">4</span><span class="p">,</span><span class="m">5</span><span class="p">}</span>
	<span class="n">b</span> <span class="o">:=</span> <span class="n">a</span>
	<span class="n">b</span><span class="p">[</span><span class="m">2</span><span class="p">]</span> <span class="o">=</span> <span class="m">8</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div><p>程序输出结果：a 和 b 本质上指向同一个底层数组。 切片的底层数据结构其实是一个指针、len、cap。</p><h2 id="值传递与引用传递">值传递与引用传递</h2><h3 id="什么是传值值传递">什么是传值（值传递）</h3><p>传值的意思是：函数传递的总是原来这个东西的一个副本，一副拷贝。比如我们传递一个 int 类型的参数，传递的其实是这个参数的一个副本；传递一个指针类型的参数，其实传递的是这个该指针的一份拷贝，而不是这个指针指向的值。</p><p>对于 int 这类基础类型我们可以很好的理解，它们就是一个拷贝，但是指针呢？我们觉得可以通过它修改原来的值，怎么会是一个拷贝呢？下面我们看个例子。</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">i</span><span class="o">:=</span><span class="m">10</span>
	<span class="n">ip</span><span class="o">:=&amp;</span><span class="n">i</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"原始指针的内存地址是：%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">ip</span><span class="p">)</span>
	<span class="n">modify</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"int值被修改了，新值为:"</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">modify</span><span class="p">(</span><span class="n">ip</span> <span class="o">*</span><span class="kt">int</span><span class="p">){</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"函数里接收到的指针的内存地址是：%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">ip</span><span class="p">)</span>
	<span class="o">*</span><span class="n">ip</span><span class="o">=</span><span class="m">1</span>
<span class="p">}</span>
</code></pre></div></div><p>我们运行，可以看到输入结果如下：</p><div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>原始指针的内存地址是：0xc42000c028
函数里接收到的指针的内存地址是：0xc42000c038
int值被修改了，新值为: 1
</code></pre></div></div><p>首先我们要知道，任何存放在内存里的东西都有自己的地址，指针也不例外，它虽然指向别的数据，但是也有存放该指针的内存。</p><p>所以通过输出我们可以看到，这是一个指针的拷贝，因为存放这两个指针的内存地址是不同的，虽然指针的值相同，但是是两个不同的指针。</p><h3 id="什么是传引用-引用传递">什么是传引用 (引用传递)</h3><p>Go 语言 (Golang) 是没有引用传递的，这里我不能使用 Go 举例子，但是可以通过说明描述。</p><p>以上面的例子为例，如果在 modify 函数里打印出来的内存地址是不变的，也是 0xc42000c028，那么就是引用传递。</p><h4 id="迷惑-map">迷惑 Map</h4><p>了解清楚了传值和传引用，但是对于 Map 类型来说，可能觉得还是迷惑，一来我们可以通过方法修改它的内容，二来它没有明显的指针。</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">persons</span><span class="o">:=</span><span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
	<span class="n">persons</span><span class="p">[</span><span class="s">"张三"</span><span class="p">]</span><span class="o">=</span><span class="m">19</span>

	<span class="n">mp</span><span class="o">:=&amp;</span><span class="n">persons</span>

	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"原始map的内存地址是：%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">mp</span><span class="p">)</span>
	<span class="n">modify</span><span class="p">(</span><span class="n">persons</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"map值被修改了，新值为:"</span><span class="p">,</span><span class="n">persons</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">modify</span><span class="p">(</span><span class="n">p</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">){</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"函数里接收到map的内存地址是：%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">p</span><span class="p">)</span>
	<span class="n">p</span><span class="p">[</span><span class="s">"张三"</span><span class="p">]</span><span class="o">=</span><span class="m">20</span>
<span class="p">}</span>
</code></pre></div></div><p>运行打印输出：</p><div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>原始map的内存地址是：0xc42000c028
函数里接收到map的内存地址是：0xc42000c038
map值被修改了，新值为: map[张三:20]
</code></pre></div></div><p>两个内存地址是不一样的，所以这又是一个值传递（值的拷贝），那么为什么我们可以修改 Map 的内容呢？先不急，我们先看一个自己实现的 struct。</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">p</span><span class="o">:=</span><span class="n">Person</span><span class="p">{</span><span class="s">"张三"</span><span class="p">}</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"原始Person的内存地址是：%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">p</span><span class="p">)</span>
	<span class="n">modify</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Person</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Name</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">modify</span><span class="p">(</span><span class="n">p</span> <span class="n">Person</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"函数里接收到Person的内存地址是：%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">p</span><span class="p">)</span>
	<span class="n">p</span><span class="o">.</span><span class="n">Name</span> <span class="o">=</span> <span class="s">"李四"</span>
<span class="p">}</span>
</code></pre></div></div><p>运行打印输出：</p><div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>原始Person的内存地址是：0xc4200721b0
函数里接收到Person的内存地址是：0xc4200721c0
<span class="o">{</span>张三<span class="o">}</span>
</code></pre></div></div><p>我们发现，我们自己定义的 Person 类型，在函数传参的时候也是值传递，但是它的值 (Name 字段) 并没有被修改，我们想改成李四，发现最后的结果还是张三。</p><p>这也就是说，map 类型和我们自己定义的 struct 类型是不一样的。我们尝试把 modify 函数的接收参数改为 Person 的指针。</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">p</span><span class="o">:=</span><span class="n">Person</span><span class="p">{</span><span class="s">"张三"</span><span class="p">}</span>
	<span class="n">modify</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Person</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Name</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">modify</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">Person</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">p</span><span class="o">.</span><span class="n">Name</span> <span class="o">=</span> <span class="s">"李四"</span>
<span class="p">}</span>
</code></pre></div></div><p>在运行查看输出，我们发现，这次被修改了。我们这里省略了内存地址的打印，因为我们上面 int 类型的例子已经证明了指针类型的参数也是值传递的。 指针类型可以修改，非指针类型不行，那么我们可以大胆的猜测，我们使用 make 函数创建的 map 是不是一个指针类型呢？看一下源代码:</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// makemap implements a Go map creation make(map[k]v, hint)</span>
<span class="c">// If the compiler has determined that the map or the first bucket</span>
<span class="c">// can be created on the stack, h and/or bucket may be non-nil.</span>
<span class="c">// If h != nil, the map can be created directly in h.</span>
<span class="c">// If bucket != nil, bucket can be used as the first bucket.</span>
<span class="k">func</span> <span class="n">makemap</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">maptype</span><span class="p">,</span> <span class="n">hint</span> <span class="kt">int64</span><span class="p">,</span> <span class="n">h</span> <span class="o">*</span><span class="n">hmap</span><span class="p">,</span> <span class="n">bucket</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">)</span> <span class="o">*</span><span class="n">hmap</span> <span class="p">{</span>
    <span class="c">//省略无关代码</span>
<span class="p">}</span>
</code></pre></div></div><p>通过查看 src/runtime/hashmap.go 源代码发现，的确和我们猜测的一样，make 函数返回的是一个 hmap 类型的指针 <em>hmap。也就是说 map===</em>hmap。 现在看 func modify(p map) 这样的函数，其实就等于 func modify(p *hmap)，和我们前面第一节什么是值传递里举的 func modify(ip *int) 的例子一样，可以参考分析。</p><p>所以在这里，Go 语言通过 make 函数，字面量的包装，为我们省去了指针的操作，让我们可以更容易的使用 map。这里的 map 可以理解为引用类型，但是记住引用类型不是传引用。</p><h4 id="chan-类型">chan 类型</h4><p>chan 类型本质上和 map 类型是一样的，这里不做过多的介绍，参考下源代码:</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">makechan</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">chantype</span><span class="p">,</span> <span class="n">size</span> <span class="kt">int64</span><span class="p">)</span> <span class="o">*</span><span class="n">hchan</span> <span class="p">{</span>
    <span class="c">//省略无关代码</span>
<span class="p">}</span>
</code></pre></div></div><p>chan 也是一个引用类型，和 map 相差无几，make 返回的是一个 *hchan。</p><h4 id="和-mapchan-都不一样的-slice">和 map、chan 都不一样的 slice</h4><p>slice 和 map、chan 都不太一样的，一样的是，它也是引用类型，它也可以在函数中修改对应的内容。</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">ages</span><span class="o">:=</span><span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="m">6</span><span class="p">,</span><span class="m">6</span><span class="p">,</span><span class="m">6</span><span class="p">}</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"原始slice的内存地址是%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">ages</span><span class="p">)</span>
	<span class="n">modify</span><span class="p">(</span><span class="n">ages</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">ages</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">modify</span><span class="p">(</span><span class="n">ages</span> <span class="p">[]</span><span class="kt">int</span><span class="p">){</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"函数里接收到slice的内存地址是%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">ages</span><span class="p">)</span>
	<span class="n">ages</span><span class="p">[</span><span class="m">0</span><span class="p">]</span><span class="o">=</span><span class="m">1</span>
<span class="p">}</span>
</code></pre></div></div><p>运行打印结果，发现的确是被修改了，而且我们这里打印 slice 的内存地址是可以直接通过 %p 打印的，不用使用 &amp; 取地址符转换。</p><p>这就可以证明 make 的 slice 也是一个指针了吗？不一定，也可能 fmt.Printf 把 slice 特殊处理了。</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">pp</span><span class="p">)</span> <span class="n">fmtPointer</span><span class="p">(</span><span class="n">value</span> <span class="n">reflect</span><span class="o">.</span><span class="n">Value</span><span class="p">,</span> <span class="n">verb</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">u</span> <span class="kt">uintptr</span>
	<span class="k">switch</span> <span class="n">value</span><span class="o">.</span><span class="n">Kind</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">reflect</span><span class="o">.</span><span class="n">Chan</span><span class="p">,</span> <span class="n">reflect</span><span class="o">.</span><span class="n">Func</span><span class="p">,</span> <span class="n">reflect</span><span class="o">.</span><span class="n">Map</span><span class="p">,</span> <span class="n">reflect</span><span class="o">.</span><span class="n">Ptr</span><span class="p">,</span> <span class="n">reflect</span><span class="o">.</span><span class="n">Slice</span><span class="p">,</span> <span class="n">reflect</span><span class="o">.</span><span class="n">UnsafePointer</span><span class="o">:</span>
		<span class="n">u</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">Pointer</span><span class="p">()</span>
	<span class="k">default</span><span class="o">:</span>
		<span class="n">p</span><span class="o">.</span><span class="n">badVerb</span><span class="p">(</span><span class="n">verb</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c">//省略部分代码</span>
<span class="p">}</span>
</code></pre></div></div><p>通过源代码发现，对于 chan、map、slice 等被当成指针处理，通过 value.Pointer() 获取对应的值的指针。</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// If v's Kind is Slice, the returned pointer is to the first</span>
<span class="c">// element of the slice. If the slice is nil the returned value</span>
<span class="c">// is 0.  If the slice is empty but non-nil the return value is non-zero.</span>
<span class="k">func</span> <span class="p">(</span><span class="n">v</span> <span class="n">Value</span><span class="p">)</span> <span class="n">Pointer</span><span class="p">()</span> <span class="kt">uintptr</span> <span class="p">{</span>
	<span class="c">// TODO: deprecate</span>
	<span class="n">k</span> <span class="o">:=</span> <span class="n">v</span><span class="o">.</span><span class="n">kind</span><span class="p">()</span>
	<span class="k">switch</span> <span class="n">k</span> <span class="p">{</span>
	<span class="c">//省略无关代码</span>
	<span class="k">case</span> <span class="n">Slice</span><span class="o">:</span>
		<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">SliceHeader</span><span class="p">)(</span><span class="n">v</span><span class="o">.</span><span class="n">ptr</span><span class="p">)</span><span class="o">.</span><span class="n">Data</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>很明显了，当是 slice 类型的时候，返回是 slice 这个结构体里，字段 Data 第一个元素的地址。</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">SliceHeader</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Data</span> <span class="kt">uintptr</span>
	<span class="n">Len</span>  <span class="kt">int</span>
	<span class="n">Cap</span>  <span class="kt">int</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">slice</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">array</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span>
	<span class="nb">len</span>   <span class="kt">int</span>
	<span class="nb">cap</span>   <span class="kt">int</span>
<span class="p">}</span>
</code></pre></div></div><p>所以我们通过 %p 打印的 slice 变量 ages 的地址其实就是内部存储数组元素的地址，slice 是一种结构体 + 元素指针的混合类型，通过元素 array(Data) 的指针，可以达到修改 slice 里存储元素的目的。</p><p>所以修改类型的内容的办法有很多种，类型本身作为指针可以，类型里有指针类型的字段也可以。</p><p>单纯的从 slice 这个结构体看，我们可以通过 modify 修改存储元素的内容，但是永远修改不了 len 和 cap，因为他们只是一个拷贝，如果要修改，那就要传递 *slice 作为参数才可以。</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">i</span><span class="o">:=</span><span class="m">19</span>
	<span class="n">p</span><span class="o">:=</span><span class="n">Person</span><span class="p">{</span><span class="n">name</span><span class="o">:</span><span class="s">"张三"</span><span class="p">,</span><span class="n">age</span><span class="o">:&amp;</span><span class="n">i</span><span class="p">}</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
	<span class="n">modify</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Person</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">name</span> <span class="kt">string</span>
	<span class="n">age</span>  <span class="o">*</span><span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="n">Person</span><span class="p">)</span> <span class="n">String</span><span class="p">()</span> <span class="kt">string</span><span class="p">{</span>
	<span class="k">return</span> <span class="s">"姓名为："</span> <span class="o">+</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s">",年龄为："</span><span class="o">+</span> <span class="n">strconv</span><span class="o">.</span><span class="n">Itoa</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="o">.</span><span class="n">age</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">modify</span><span class="p">(</span><span class="n">p</span> <span class="n">Person</span><span class="p">){</span>
	<span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">"李四"</span>
	<span class="o">*</span><span class="n">p</span><span class="o">.</span><span class="n">age</span> <span class="o">=</span> <span class="m">20</span>
<span class="p">}</span>
</code></pre></div></div><p>运行打印输出结果为：</p><div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>姓名为：张三,年龄为：19
姓名为：张三,年龄为：20
</code></pre></div></div><p>通过这个 Person 和 slice 对比，就更好理解了，Person 的 name 字段就类似于 slice 的 len 和 cap 字段，age 字段类似于 array 字段。在传参为非指针类型的情况下，只能修改 age 字段，name 字段无法修改。要修改 name 字段，就要把传参改为指针，比如：</p><div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">modify</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">)</span>
<span class="k">func</span> <span class="n">modify</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">Person</span><span class="p">){</span>
	<span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">"李四"</span>
	<span class="o">*</span><span class="n">p</span><span class="o">.</span><span class="n">age</span> <span class="o">=</span> <span class="m">20</span>
<span class="p">}</span>
</code></pre></div></div><p>这样 name 和 age 字段双双都被修改了。</p><p>所以 slice 类型也是引用类型。</p><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="https://lewinz.org" target="_blank">Lewin</a></li><li>本文链接：<a href="https://lewinz.org/2021/04/29/go-type-cite-value/" target="_blank">https://lewinz.org/2021/04/29/go-type-cite-value/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名</li></ul></div></article><div class="share"><div class="share-component" data-disabled='qq,weibo,qzone'></div></div><div class="comment"><div id="gitalk-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/vendor/gitalk/gitalk.css"> <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> <script> var gitalk = new Gitalk({ id: '/2021/04/29/go-type-cite-value/', clientID: '831a35f6d4f6fc049209', clientSecret: '6e80f9a3e9b50b498553e32179ad3adbd893ab7e', repo: 'blog-comments', owner: 'Lewinz', admin: ['Lewinz'], labels: ['gitment'], perPage: 50, }); gitalk.render('gitalk-container'); </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@built/assets/search_data.json?v=1645174330', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"> <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-7093222719567591" data-ad-slot="5263168187" data-ad-format="auto" data-full-width-responsive="true"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2021 <span title="Lewin">Lewin</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/Lewinz/lewinz.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://lewinz.org/" title="首页" target="">首页</a></li><li> <a href="https://lewinz.org/categories/" title="分类" target="">分类</a></li><li> <a href="https://lewinz.org/wiki/" title="维基" target="">维基</a></li><li> <a href="https://lewinz.org/links/" title="链接" target="">链接</a></li><li> <a href="https://lewinz.org/about/" title="关于" target="">关于</a></li><li><a href="https://lewinz.org/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul><script async src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/vendor/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="mobile-hidden" style="margin-top:8px"> <span id="busuanzi_container_site_pv" style="display:none"> 本站访问量<span id="busuanzi_value_site_pv"></span>次 </span> <span id="busuanzi_container_site_uv" style="display:none"> / 本站访客数<span id="busuanzi_value_site_uv"></span>人 </span> <span id="busuanzi_container_page_pv" style="display:none"> / 本页访问量<span id="busuanzi_value_page_pv"></span>次 / 统计始于2021-04-21 </span></div></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/vendor/share.js/dist/js/share.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/Lewinz/lewinz.github.io@master/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script><div style="display:none"> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-80669434-1', 'auto'); ga('send', 'pageview'); </script></div></body></html>
